<!DOCTYPE html>
<!-- saved from url=(0045)./10_modules.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <title>Modules :: Eloquent JavaScript</title>
  <link rel="stylesheet" href="./media/codemirror.css">
  <script src="./media/acorn_codemirror.js"></script>
  <link rel="stylesheet" href="./media/ejs.css">
  <script src="./media/sandbox.js"></script>
  <script src="./media/ejs.js"></script>
  <script>var chapNum = 10;var sandboxLoadFiles = ["code/chapter/10_modules.js", "code/loadfile.js"];</script>
</head>

<body><article>
<nav>
  <a href="./09_regexp.html" title="previous chapter">◀</a>
  <a href="./index.html" title="cover">◆</a>
  <a href="./11_language.html" title="next chapter">▶</a>
</nav>

<h1><div class="chap_num">Глава 10</div>Модули</h1>
<blockquote>
<p><a class="p_ident" id="p_PJiK2g1JXC" href="./10_modules.html#p_PJiK2g1JXC"></a>Начинаещ програмист пише своите програми, както една мравка изгражда хълм, едно цяло парче наведнъж, без да мисли за по-голяма структура. Неговите програми ще бъдат, като хлабав пясък. Те могат да издържат известно време, но растат прекалено големи и ще се разпаднат.</p>
<p><a class="p_ident" id="p_OfZWeuo+oF" href="./10_modules.html#p_OfZWeuo+oF"></a>Осъзнавайки този проблем, програмиста ще започне да прекарва много време мислейки за структурата. Неговите програми ще бъдат неподвижно структурирани, като скални скулптори. Те са солидни, но когато трябва да се променят, ще трябва да се приложи усилие.</p>
<p><a class="p_ident" id="p_fFMEGH1dk3" href="./10_modules.html#p_fFMEGH1dk3"></a>Майсторът програмист, знае кога да прилага структура и кога да остави нещата в тяхната проста форма. Неговите програми, са като глина, стегнати и същевременно ковки.”</p>
 <footer>Master Yuan-Ma, <cite>Книга за програмиране</cite></footer>
</blockquote>
<p><a class="p_ident" id="p_1aMUBkVbPd" href="./10_modules.html#p_1aMUBkVbPd"></a>Всяка програма има форма. На малък мащаб, тази форма се определя чрез разделяне на функции и блокове в тези функции. Програмистите имат много свобода в начина, по който да структурират своите програми. Формата следва повече вкуса на програмиста, от колкото предназначената функционалност на програмата.</p>
<p><a class="p_ident" id="p_NOETmtvWWx" href="./10_modules.html#p_NOETmtvWWx"></a>Когато търсите в по-голяма програма, която е цяла, отделни функции започват да се смесват с фона. Такива програми може да се направят по-разбираеми, ако имате по-добър начин на организация.</p>
<p><a class="p_ident" id="p_07zdYJYQ1M" href="./10_modules.html#p_07zdYJYQ1M"></a>Модулите разделят програми в групи от код, които по някои критерии са свързани заедно. Тази глава разглежда някои от ползите, които това разделяне осигурява и показва техники за изграждане на модули в JavaScript.</p>
<h2><a class="h_ident" id="h_0DSW4+9YVh" href="./10_modules.html#h_0DSW4+9YVh"></a>Защо  модулите  помагат</h2>
<p><a class="p_ident" id="p_ovuaejexnJ" href="./10_modules.html#p_ovuaejexnJ"></a>Има редица причини, поради които, автори разделят своите книги в глави и раздели. Тези разделения правят по-лесно за едни читател да види как е изградена книгата и да намира конкретни части от нея, които го интересуват. Те също помагат на автора, като му предоставят ясен фокус за всеки раздел.</p>
<p><a class="p_ident" id="p_QxCtWUR2zJ" href="./10_modules.html#p_QxCtWUR2zJ"></a>Ползите от организиране на програмата в няколко файла или модули са сходни. Структурата помага на хората, които все още не са запознати с кода, да намират това, което търсят и прави по-лесно за програмист да пази неща, които са тясно свързани заедно.</p>
<p><a class="p_ident" id="p_4vnN7lCDZy" href="./10_modules.html#p_4vnN7lCDZy"></a>Някои програми дори са организирани по модел на традиционен текст с ясно определена цел, с която читателя се насърчава да мине през програмата и с много проза (коментари) въвежда последоватено в описанието на кода. Това прави четенето на програмата много по-малко смущаващо, от колкото четене на неизвестен код, но има недостатък, който е повече работа за да се създаде. Този стил се нарича грамотно програмиране. Проектите в тази книга могат да се считат за грамотни програми.</p>
<p><a class="p_ident" id="p_Ou/d4KbIy/" href="./10_modules.html#p_Ou/d4KbIy/"></a>Като общо правило, структурирането на нещата има енергийни разходи. В ранните етапи на един проект, когато не сте съвсем сигурни какво се случва, когато или от какви модули се нуждае програмата, аз подкрепям минималистичния безструктурен подход. Просто сложете всичко там, където ви е удобно да го пускате, докато стабилизирате кода. По този начин, вие няма да губите време за преместване на части от програмата назад - напред, и вие няма да се заключите случайно в конструкция, която всъщност не е част от вашата програма.</p>
<h3><a class="h_ident" id="h_NitCO6r9Hn" href="./10_modules.html#h_NitCO6r9Hn"></a>Namespacing</h3>
<p><a class="p_ident" id="p_8S/+Hon3uA" href="./10_modules.html#p_8S/+Hon3uA"></a>Повечето съвременни езици за програмиране имат ниво на обхват между глобалното (видимо от всеки) и локално (видимо от функцията в която е), JavaScript няма такъв обхват. По този начин, по подразбиране, всичко което трябва да се вижда извън обхвата на функцията се вижда на всякъде до най-високото ниво.</p>
<p><a class="p_ident" id="p_QMB7RIsBay" href="./10_modules.html#p_QMB7RIsBay"></a>Именно проблемът със замърсяването на пространството с много несвързан код, налага да се споделя единен набор от глобални имена на променливи, за което се споменава в <a href="./04_data.html#namespace_pollution">Глава 4</a>, където обекта <code>Math</code> беше даден, като пример за обект, който действа, като модул чрез групиране на математика свързана с функционалноста.</p>
<p><a class="p_ident" id="p_bBKNVkrywA" href="./10_modules.html#p_bBKNVkrywA"></a>Въпреки, че JavaScript не дава действителна конструкция на модула все още, обектите могат да бъдат използвани за създаване на публично достъпни <em>subnamespaces</em> и функции, които могат да бъдат използвани за създаване на изолирано, лично пространство във вътрешността на модула. По късно в тази глава, аз ще обсъдя начин за изграждане на разумно и удобно пространство за изолиране на модули, с върха на най-примитивните концепции, които JavaScript ни дава.</p>
<h3><a class="h_ident" id="h_UuxJID5Z2e" href="./10_modules.html#h_UuxJID5Z2e"></a>Повторна  употреба</h3>
<p><a class="p_ident" id="p_0MwF7DbAP0" href="./10_modules.html#p_0MwF7DbAP0"></a>Във всеки “плосък” проект, който не е структуриран, като набор от модули, не е видно за кои части от кода трябва да се използва определена функция. В моята програма за шпиониране на враговете (виж <a href="./09_regexp.html#ini">Глава 9</a>), аз написах функция за четене на конфигурационни файлове. Ако искам да използвам тази функция в друг проект, аз трябва да отида и да препиша частите от старата програма, от които имам нужда свързани с функционалноста и да ги поставя в новата си програма. След това, ако намеря грешка в кода, аз ще го оправя само в зависимост от това в коя програма работя в момента и най-вероятно ще забравя да го оправя в другата програма.</p>
<p><a class="p_ident" id="p_n5Itkf6SsY" href="./10_modules.html#p_n5Itkf6SsY"></a>След като, имате много такива споделени, дублирани парчета код, постепенно с времето, вие ще откриете, че губите много време и енергия за да ги местите и съхранявате.</p>
<p><a class="p_ident" id="p_zwgHmRoxk9" href="./10_modules.html#p_zwgHmRoxk9"></a>Поставянето на самостоятелни парчета функционалност в отделни файлове и модули, ги прави по-лесно проследими за обновяване и споделяне, защото всички различни части от кода, който искате да използвате, като модул, са продължение на същия действителен файл.</p>
<p><a class="p_ident" id="p_D2yYhnbA9K" href="./10_modules.html#p_D2yYhnbA9K"></a>Тази идея получава още мощност, когато връзките между модулите - това кой модул от кой зависи - са изрично декларирани. След това може да се автоматизира процеса на инсталиране и обновяване на външни модули (библиотеки).</p>
<p><a class="p_ident" id="p_3ED8vjm59N" href="./10_modules.html#p_3ED8vjm59N"></a>Възползвайки се от тази идея, си представете онлайн услуга, която следи и разпределя стотици хиляди библиотеки, която ви позволява да търсите функционалноста, от която имате нужда и след като я намерите, вашия проект автоматично да я изтегли.</p>
<p id="modules_npm"><a class="p_ident" id="p_8hHGZUvmtE" href="./10_modules.html#p_8hHGZUvmtE"></a>Съществува такава услуга, тя се нарича NPM (<a href="http://npmjs.org/"><em>npmjs.org</em></a>). NPM се състои от онлайн база данни на модули  и е инструмент за изтегляне и обновяване на модулите в програмите. Тя се роди в резултат на Node.js среда на JavaScript , която ще обсъдим в 
<a href="./20_node.html#node">Глава 20</a>, но може да бъде полезна при програмирането на браузъра.</p>
<h3><a class="h_ident" id="h_qJacYNwWWL" href="./10_modules.html#h_qJacYNwWWL"></a>Отделяне</h3>
<p><a class="p_ident" id="p_BIr3LxVodJ" href="./10_modules.html#p_BIr3LxVodJ"></a>Друга важна роля на модулите е изолирането на части от код от друг, по същия начин, който интерфейсите на обектите правят в <a href="./06_object.html#interface">Глава 6</a>. Един добре проектиран модул ще предостави интерфейс за външен код, за да може да го използвате. Тъй като, модулът получава актуализация с корекции на грешки и нова функционалност - съществуващият интерфейс остава също (ако е стабилен) - така че и другите модули да могат да използват новата подобрена версия без никакви промени в себе си.</p>
<p><a class="p_ident" id="p_B3JCtLjLbo" href="./10_modules.html#p_B3JCtLjLbo"></a>Имайте в предвид, че един стабилен интерфейс не означава, че няма нови функции, методи или променливи, които да се добавят към него. Това просто означава, че съществуващата функционалност не е отстранена и нейното значение не се променя.</p>
<p><a class="p_ident" id="p_vcubl5qb7a" href="./10_modules.html#p_vcubl5qb7a"></a>Един добър интерфейс на модул трябва да даде възможност на модула да расте без да се счупи стария интерфейс. Това означава, че разкривайки някои от вътрешните концепции на модула (като възможност на езика) прави този интерфейс мощен и достатъчно гъвкав, за да се прилага в широк спектър от ситуации.</p>
<p><a class="p_ident" id="p_jT10dBy1PO" href="./10_modules.html#p_jT10dBy1PO"></a>За интерфейси, които излагат  единни, фиксирани концепции, като четец на конфигурационен файл, този дизайн идва естествено. За други, като текстов редактор, който има много различни аспекти, които се нуждаят от външен код за достъп(съдържание, стайлинг, действия на потребител и т.н.) се изисква внимателно планиране.</p>
<h2><a class="h_ident" id="h_FIe+oM6Cvt" href="./10_modules.html#h_FIe+oM6Cvt"></a>Използване  на  функциии, като namespaces</h2>
<p><a class="p_ident" id="p_Qi0v4Dtc05" href="./10_modules.html#p_Qi0v4Dtc05"></a>Функциите са единствените неща в JavaScript, които създават нов обхват. Така че, ако искаме нашите модули да имат свой собствен характер, ще трябва да ги основем на функции.</p>
<p><a class="p_ident" id="p_TJhIvzABX+" href="./10_modules.html#p_TJhIvzABX+"></a>Помислете за този тривиален модул, който асоциира имената на дните от седмицата с номера, като резултат от <code>Date</code> обекта на  <code>getDay</code> метода:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_0/+3DgqC3k" href="./10_modules.html#c_0/+3DgqC3k"></a><span class="cm-keyword">var</span> <span class="cm-variable">names</span> <span class="cm-operator">=</span> [<span class="cm-string">"Sunday"</span>, <span class="cm-string">"Monday"</span>, <span class="cm-string">"Tuesday"</span>, <span class="cm-string">"Wednesday"</span>,
             <span class="cm-string">"Thursday"</span>, <span class="cm-string">"Friday"</span>, <span class="cm-string">"Saturday"</span>];
<span class="cm-keyword">function</span> <span class="cm-variable">dayName</span>(<span class="cm-def">number</span>) {
  <span class="cm-keyword">return</span> <span class="cm-variable">names</span>[<span class="cm-variable-2">number</span>];
}

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">dayName</span>(<span class="cm-number">1</span>));
<span class="cm-comment">// → Monday</span></pre>
<p><a class="p_ident" id="p_lljN2eMCck" href="./10_modules.html#p_lljN2eMCck"></a>Функцията <code>dayName</code> е част от интерфейса на модула, но променливата <code>names</code> не е. Бихме предпочели да не я изсипваме в глобалния обхват.</p>
<p><a class="p_ident" id="p_NKmpNxgsFg" href="./10_modules.html#p_NKmpNxgsFg"></a>Можем да направим това:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_cQrjXVzz5t" href="./10_modules.html#c_cQrjXVzz5t"></a><span class="cm-keyword">var</span> <span class="cm-variable">dayName</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>() {
  <span class="cm-keyword">var</span> <span class="cm-def">names</span> <span class="cm-operator">=</span> [<span class="cm-string">"Sunday"</span>, <span class="cm-string">"Monday"</span>, <span class="cm-string">"Tuesday"</span>, <span class="cm-string">"Wednesday"</span>,
               <span class="cm-string">"Thursday"</span>, <span class="cm-string">"Friday"</span>, <span class="cm-string">"Saturday"</span>];
  <span class="cm-keyword">return</span> <span class="cm-keyword">function</span>(<span class="cm-def">number</span>) {
    <span class="cm-keyword">return</span> <span class="cm-variable-2">names</span>[<span class="cm-variable-2">number</span>];
  };
}();

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">dayName</span>(<span class="cm-number">3</span>));
<span class="cm-comment">// → Wednesday</span></pre>
<p><a class="p_ident" id="p_wFyqiGP0o5" href="./10_modules.html#p_wFyqiGP0o5"></a>Сега <code>names</code> е локална променлива в анонимна функция. Тази функция се създава и веднага се извиква, и нейната върната стойност (действителната <code>dayName</code> функция) е съхранена в променлива. Ние можем да имаме страници и страници код в тази функция, със сто локални променливи и всички ще бъдат в нашия вътрешен модул, видими за самия модул, но невидими от вън.</p>
<p><a class="p_ident" id="p_XMMYXbTqGr" href="./10_modules.html#p_XMMYXbTqGr"></a>Можем да използваме подобен модел да изолираме код изцяло от външния свят. Следващия модул логва стойност към конзолата, но всъщност не предоставя никакви стойности за ползване към други модули.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_HzELhaatCS" href="./10_modules.html#c_HzELhaatCS"></a>(<span class="cm-keyword">function</span>() {
  <span class="cm-keyword">function</span> <span class="cm-def">square</span>(<span class="cm-def">x</span>) { <span class="cm-keyword">return</span> <span class="cm-variable-2">x</span> <span class="cm-operator">*</span> <span class="cm-variable-2">x</span>; }
  <span class="cm-keyword">var</span> <span class="cm-def">hundred</span> <span class="cm-operator">=</span> <span class="cm-number">100</span>;

  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable-2">square</span>(<span class="cm-variable-2">hundred</span>));
})();
<span class="cm-comment">// → 10000</span></pre>
<p><a class="p_ident" id="p_NhLZMeErEJ" href="./10_modules.html#p_NhLZMeErEJ"></a>Този код просто извежда квадрата на 100, но в реалния свят това може да бъде един модул, който добавя метод към някой прототип или създава нещо в уеб страница. Той е увит във функция, за да предотврати променливите, които използва вътрешно да замърсят глобалния обхват.</p>
<p><a class="p_ident" id="p_TMPi6xxW7Y" href="./10_modules.html#p_TMPi6xxW7Y"></a>Защо увиваме <em>namespace</em> функциите в чифт скоби? Това е свързано с приумица в синтаксиса на JavaScript. Ако израза започва с думата <code>function</code>, това е израз на функция. Въпреки това, ако изявлението започва с <code>function</code>, това е декларация за функция, която изисква име и няма да бъде израз, който може да извика написаното в скобите след него. Може да мислите за допълнителните увиващи скоби, като трик да се принуди функцията да се мисли за израз.</p>
<h2><a class="h_ident" id="h_tbrMjRcajd" href="./10_modules.html#h_tbrMjRcajd"></a>Обекти,  като интерфейс</h2>
<p><a class="p_ident" id="p_jaxyyZ13ux" href="./10_modules.html#p_jaxyyZ13ux"></a>Сега си представете, че искаме да добавим друга функция в нашия модул на седмицата, която води от името на деня в номер. Не можем просто да върнем другата функция, трябва да увием двете функции в един обект.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_j+iqUdoU2O" href="./10_modules.html#c_j+iqUdoU2O"></a><span class="cm-keyword">var</span> <span class="cm-variable">weekDay</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>() {
  <span class="cm-keyword">var</span> <span class="cm-def">names</span> <span class="cm-operator">=</span> [<span class="cm-string">"Sunday"</span>, <span class="cm-string">"Monday"</span>, <span class="cm-string">"Tuesday"</span>, <span class="cm-string">"Wednesday"</span>,
               <span class="cm-string">"Thursday"</span>, <span class="cm-string">"Friday"</span>, <span class="cm-string">"Saturday"</span>];
  <span class="cm-keyword">return</span> {
    <span class="cm-property">name</span>: <span class="cm-keyword">function</span>(<span class="cm-def">number</span>) { <span class="cm-keyword">return</span> <span class="cm-variable-2">names</span>[<span class="cm-variable-2">number</span>]; },
    <span class="cm-property">number</span>: <span class="cm-keyword">function</span>(<span class="cm-def">name</span>) { <span class="cm-keyword">return</span> <span class="cm-variable-2">names</span>.<span class="cm-property">indexOf</span>(<span class="cm-variable-2">name</span>); }
  };
}();

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">weekDay</span>.<span class="cm-property">name</span>(<span class="cm-variable">weekDay</span>.<span class="cm-property">number</span>(<span class="cm-string">"Sunday"</span>)));
<span class="cm-comment">// → Sunday</span></pre>
<p><a class="p_ident" id="p_67L/Eo8MtL" href="./10_modules.html#p_67L/Eo8MtL"></a>За големи модули, събирането на всички изнасяни стойности в обект в края на функцията, става неудобно, тъй като много от изнесените функции има вероятност да бъдат големи и предпочитаме да ги напишем някъде другаде в района, свързани с вътрешен код. Удобна алтернатива е да се направи обект (условно наречен <code>exports</code>) и да добавим свойства всеки път, когато определяме нещо, което трябва да бъде изнесено. В следващия пример, функцията на модула взема интерфейса на обекта, като аргумент, позволявайки на кода извън функцията да го създаде и съхранява в променлива. (Извън функцията, <code>this</code> се отнася до глобалния обхват на обекта).</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_qHa2RFvopi" href="./10_modules.html#c_qHa2RFvopi"></a>(<span class="cm-keyword">function</span>(<span class="cm-def">exports</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">names</span> <span class="cm-operator">=</span> [<span class="cm-string">"Sunday"</span>, <span class="cm-string">"Monday"</span>, <span class="cm-string">"Tuesday"</span>, <span class="cm-string">"Wednesday"</span>,
               <span class="cm-string">"Thursday"</span>, <span class="cm-string">"Friday"</span>, <span class="cm-string">"Saturday"</span>];

  <span class="cm-variable-2">exports</span>.<span class="cm-property">name</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">number</span>) {
    <span class="cm-keyword">return</span> <span class="cm-variable-2">names</span>[<span class="cm-variable-2">number</span>];
  };
  <span class="cm-variable-2">exports</span>.<span class="cm-property">number</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">name</span>) {
    <span class="cm-keyword">return</span> <span class="cm-variable-2">names</span>.<span class="cm-property">indexOf</span>(<span class="cm-variable-2">name</span>);
  };
})(<span class="cm-keyword">this</span>.<span class="cm-property">weekDay</span> <span class="cm-operator">=</span> {});

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">weekDay</span>.<span class="cm-property">name</span>(<span class="cm-variable">weekDay</span>.<span class="cm-property">number</span>(<span class="cm-string">"Saturday"</span>)));
<span class="cm-comment">// → Saturday</span></pre>
<h2><a class="h_ident" id="h_ryZfYeSnJy" href="./10_modules.html#h_ryZfYeSnJy"></a>Отделяне  от  глобалния  обхват</h2>
<p><a class="p_ident" id="p_AfCtO+ifwZ" href="./10_modules.html#p_AfCtO+ifwZ"></a>Предишният модел обикновено се използва от JavaScript  за модули, предназначени за браузъра. Модулът ще регистрира една глобална променлива и ще увие нейния код във функция, така че да има свое собствено <em>namespace</em>. Но този модел все още създава проблеми, ако се случи множество модули да имат претенция към същото име или ако искате да заредите две версии на даден модул една до друга.</p>
<p><a class="p_ident" id="p_Y2ejGOe+u4" href="./10_modules.html#p_Y2ejGOe+u4"></a>С малко връзки, можем да създадем система, която позволява на един модул да попита директно за обекта на интерфейса на друг модул, без да минава през глобалния обхват. Нашата цел е <code>require</code> функцията, на която когато се подаде името на модула, ще зареди файл (от диск или от мрежата, в зависимост от платформата) върху чиито модул ще се изпълнява и ще върне съответната стойност на интерфейса.</p>
<p><a class="p_ident" id="p_6BOb5Vhxc7" href="./10_modules.html#p_6BOb5Vhxc7"></a>Този подход решава проблемите, споменати по-рано и има допълнителна полза от изричното вземане на зависимости в нашата програма, което прави по-трудно случайно да се възползва от някой модул, без да се посочва, че имаме нужда от него.</p>
<p><a class="p_ident" id="p_qsfTCs+Kiu" href="./10_modules.html#p_qsfTCs+Kiu"></a>За <code>require</code> имаме нужда от две неща. На първо място, ни трябва функцията <code>readFile</code>, която връща съдържанието на даден файл, като <em>string</em>. (Тази функция не е налична в стандартния JavaScript, но различни среди за JavaScript, като браузър и Node.js, предоставят свои собствени начини за достъп до файловете. За сега нека просто се преструваме, че имаме тази функция.) На второ място, всъщност се нуждаем от изпълнение на този <em>string</em>, като JavaScript код.</p>
<h2 id="eval"><a class="h_ident" id="h_oeOkEDaadU" href="./10_modules.html#h_oeOkEDaadU"></a>Оценяване  на  данни,  като  код</h2>
<p><a class="p_ident" id="p_jvij1au4eP" href="./10_modules.html#p_jvij1au4eP"></a>Има няколко начина да се вземат данни от <em>string</em> код и да се пуснат, като част от настоящата програма.</p>
<p><a class="p_ident" id="p_sQ1ASk7W7E" href="./10_modules.html#p_sQ1ASk7W7E"></a>Най-очевидният начин е със специалният оператор <code>eval</code>, който ще изпълни поредицата от код в текущия обект. Това обикновено е лоша идея, защото ще се разпадне от някое от здравомислещите свойства, които обикновено имат обхват, когато се изолират от външния свят.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_RanI4EdsYD" href="./10_modules.html#c_RanI4EdsYD"></a><span class="cm-keyword">function</span> <span class="cm-variable">evalAndReturnX</span>(<span class="cm-def">code</span>) {
  <span class="cm-variable">eval</span>(<span class="cm-variable-2">code</span>);
  <span class="cm-keyword">return</span> <span class="cm-variable">x</span>;
}

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">evalAndReturnX</span>(<span class="cm-string">"var x = 2"</span>));
<span class="cm-comment">// → 2</span></pre>
<p><a class="p_ident" id="p_dJLBESQexx" href="./10_modules.html#p_dJLBESQexx"></a>По добър начин за интерпретиране на данните, като код, е да се използва <code>Function</code> конструктора. Той взема два аргумента: <em>string</em>, съдържащ разделен със запетаи списък от имена на аргументи и <em>string</em>, съдържащ тяло на функция.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_cZ4LeZbFGl" href="./10_modules.html#c_cZ4LeZbFGl"></a><span class="cm-keyword">var</span> <span class="cm-variable">plusOne</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">Function</span>(<span class="cm-string">"n"</span>, <span class="cm-string">"return n + 1;"</span>);
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">plusOne</span>(<span class="cm-number">4</span>));
<span class="cm-comment">// → 5</span></pre>
<p><a class="p_ident" id="p_8DGWg5jk7v" href="./10_modules.html#p_8DGWg5jk7v"></a>Това е точно онова, от което се нуждаят нашите модули. Ние можем просто да увием кода на модула в една функция и обхвата на тази функция да е полето на модула.</p>
<h2 id="commonjs"><a class="h_ident" id="h_v/XE3QWFpP" href="./10_modules.html#h_v/XE3QWFpP"></a>Require</h2>
<p><a class="p_ident" id="p_hpfd8nPIk6" href="./10_modules.html#p_hpfd8nPIk6"></a>Следващото е минимално изпълнение на <code>require</code>:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_1+P7EyFe1w" href="./10_modules.html#c_1+P7EyFe1w"></a><span class="cm-keyword">function</span> <span class="cm-variable">require</span>(<span class="cm-def">name</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">code</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">Function</span>(<span class="cm-string">"exports"</span>, <span class="cm-variable">readFile</span>(<span class="cm-variable-2">name</span>));
  <span class="cm-keyword">var</span> <span class="cm-def">exports</span> <span class="cm-operator">=</span> {};
  <span class="cm-variable-2">code</span>(<span class="cm-variable-2">exports</span>);
  <span class="cm-keyword">return</span> <span class="cm-variable-2">exports</span>;
}

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">require</span>(<span class="cm-string">"weekDay"</span>).<span class="cm-property">name</span>(<span class="cm-number">1</span>));
<span class="cm-comment">// → Monday</span></pre>
<p><a class="p_ident" id="p_JrILpUgcrH" href="./10_modules.html#p_JrILpUgcrH"></a>Тъй като, <code>new Function</code> конструктора увива кодa на модула във функция, ние не трябва да пишем функция за опаковане на <em>namespace</em> пространства в модула на самия файл. И тъй като, правим <code>exports</code> аргумент на функцията на модула, самия модул не трябва да го декларира. Това премахва много елементарни неща от нашия примерен модул.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_UcVUK3ap0Z" href="./10_modules.html#c_UcVUK3ap0Z"></a><span class="cm-keyword">var</span> <span class="cm-variable">names</span> <span class="cm-operator">=</span> [<span class="cm-string">"Sunday"</span>, <span class="cm-string">"Monday"</span>, <span class="cm-string">"Tuesday"</span>, <span class="cm-string">"Wednesday"</span>,
             <span class="cm-string">"Thursday"</span>, <span class="cm-string">"Friday"</span>, <span class="cm-string">"Saturday"</span>];

<span class="cm-variable">exports</span>.<span class="cm-property">name</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">number</span>) {
  <span class="cm-keyword">return</span> <span class="cm-variable">names</span>[<span class="cm-variable-2">number</span>];
};
<span class="cm-variable">exports</span>.<span class="cm-property">number</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">name</span>) {
  <span class="cm-keyword">return</span> <span class="cm-variable">names</span>.<span class="cm-property">indexOf</span>(<span class="cm-variable-2">name</span>);
};</pre>
<p><a class="p_ident" id="p_B75dGyOs9V" href="./10_modules.html#p_B75dGyOs9V"></a>Когато използваме този модел, един модул обикновено започва с няколко декларации на променливи, от които модулите зависят.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_hczzYLixJt" href="./10_modules.html#c_hczzYLixJt"></a><span class="cm-keyword">var</span> <span class="cm-variable">weekDay</span> <span class="cm-operator">=</span> <span class="cm-variable">require</span>(<span class="cm-string">"weekDay"</span>);
<span class="cm-keyword">var</span> <span class="cm-variable">today</span> <span class="cm-operator">=</span> <span class="cm-variable">require</span>(<span class="cm-string">"today"</span>);

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">weekDay</span>.<span class="cm-property">name</span>(<span class="cm-variable">today</span>.<span class="cm-property">dayNumber</span>()));</pre>
<p><a class="p_ident" id="p_5GfcRhlMLC" href="./10_modules.html#p_5GfcRhlMLC"></a>На пръв поглед изпълнението на <code>require</code> дадено преди това, може да има няколко проблема. От една страна, то ще зареди и стартира модул всеки път когато се изисква, така че ако няколко модула имат същата зависимост или извикването на <code>require</code> се постави вътре във функция, която се извиква многократно, се губи време и енергия.</p>
<p><a class="p_ident" id="p_zLUwyIBMDV" href="./10_modules.html#p_zLUwyIBMDV"></a>Това може да бъде решено чрез съхраняване на модулите, които вече са заредени в обект и просто връщаме съществуващата стойност , когато някой е зареден многократно.</p>
<p><a class="p_ident" id="p_Ylx5bX6l+o" href="./10_modules.html#p_Ylx5bX6l+o"></a>Вторият проблем е, че не е възможно за един модул да изнася директно стойност, различна от <code>exports</code> обект, подобно на функция. Например, от един модул може да искате да експортирате само конструктора на типа на обекта, който го определя. Точно сега, той не може да направи това, защото <code>require</code> винаги използва <code>exports</code> обекта, който създава експортната стойност.</p>
<p><a class="p_ident" id="p_RwxY5rq2Qj" href="./10_modules.html#p_RwxY5rq2Qj"></a>Традиционното решение за това е да се осигури модул с друга променлива <code>module</code>, която е обект и има свойството <code>exports</code>. Това свойство първоначално посочва празен обект, създаден от <code>require</code> но може да бъде заменено с друга стойност, за да експортира нещо друго.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_cUUt/BCrSf" href="./10_modules.html#c_cUUt/BCrSf"></a><span class="cm-keyword">function</span> <span class="cm-variable">require</span>(<span class="cm-def">name</span>) {
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">name</span> <span class="cm-keyword">in</span> <span class="cm-variable">require</span>.<span class="cm-property">cache</span>)
    <span class="cm-keyword">return</span> <span class="cm-variable">require</span>.<span class="cm-property">cache</span>[<span class="cm-variable-2">name</span>];

  <span class="cm-keyword">var</span> <span class="cm-def">code</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">Function</span>(<span class="cm-string">"exports, module"</span>, <span class="cm-variable">readFile</span>(<span class="cm-variable-2">name</span>));
  <span class="cm-keyword">var</span> <span class="cm-def">exports</span> <span class="cm-operator">=</span> {}, <span class="cm-keyword">module</span> <span class="cm-operator">=</span> {<span class="cm-property">exports</span>: <span class="cm-variable-2">exports</span>};
  <span class="cm-variable-2">code</span>(<span class="cm-variable-2">exports</span>, <span class="cm-keyword">module</span>);

  <span class="cm-variable">require</span>.<span class="cm-property">cache</span>[<span class="cm-variable-2">name</span>] <span class="cm-operator">=</span> <span class="cm-keyword">module</span>.<span class="cm-variable-2">exports</span>;
  <span class="cm-keyword">return</span> <span class="cm-keyword">module</span>.<span class="cm-variable-2">exports</span>;
}
<span class="cm-variable">require</span>.<span class="cm-property">cache</span> <span class="cm-operator">=</span> <span class="cm-variable">Object</span>.<span class="cm-property">create</span>(<span class="cm-atom">null</span>);</pre>
<p><a class="p_ident" id="p_Dv+TulRay7" href="./10_modules.html#p_Dv+TulRay7"></a>Сега имаме система на модул, който използва една глобална променлива (<code>require</code>), която да позволи на модулите да се открият и използват взаимно, без да минават през глобалния обхват.</p>
<p><a class="p_ident" id="p_rvZ9T+1c9y" href="./10_modules.html#p_rvZ9T+1c9y"></a>Този стил на писане на система от модули се нарича <em>CommonJS modules</em>, след псевдо стандарт, който пръв го е определил. Тя е вградена система в Node.js. Реалните внедрявания в Node.js правят много повече от примера, който показах. Най-важното е, че имат много по-интелигентен начин за преминаване от името на модула до действителното парче код, който позволява и двете: пътищата и файлове, в сравнение на текущите файлове и имена на модули, които сочат директно към локално инсталираните модули.</p>
<h2 id="amd"><a class="h_ident" id="h_A4LDSlASUo" href="./10_modules.html#h_A4LDSlASUo"></a>Бавно  зареждане  на  модули</h2>
<p><a class="p_ident" id="p_isvKkfyGNv" href="./10_modules.html#p_isvKkfyGNv"></a>Въпреки, че е възможно използването на стила CommonJS при писане на JavaScript за браузъри, той е малко неясен. Причината за това е, че четенето на файл (модул) от Интернет е малко по-бавно, от колкото да се прочете от твърд диск. Докато скрипта се изпълнява в браузъра, нищо друго не може да се случи на Интернет страницата, на която работи, по причини които ще станат известни в <a href="./14_event.html#timeline">Глава 14</a>. Това означава, че при всяко извикване на <code>require</code> да отиде и извади нещо от някакъв далечен уеб сървър, страницата ще замръзне за болезнено дълго време при зареждането на скриптовете.</p>
<p><a class="p_ident" id="p_Ce7X8+/o7v" href="./10_modules.html#p_Ce7X8+/o7v"></a>Един начин да се справите с този проблем е да стартирате програма, като <a href="http://browserify.org/"><em>Browserify</em></a> в кода си, преди да сте го връчили на уеб страницата. Тя ще търси за извиквания на <code>require</code>, решавайки всички зависимости и събирайки необходимия код в един голям файл. В самия сайт може просто да заредите този файл за да получите всички модули от които се нуждаете.</p>
<p><a class="p_ident" id="p_L9zjrOe2Un" href="./10_modules.html#p_L9zjrOe2Un"></a>Друго решение е да увиете кода, който прави вашия модул във функция, така че зареждащия модул, първо да зареди фона и след това да извика функцията за инициализиране на модул, когато зависимостите са качени. Това е така нареченото а-синхронно зареждане на системата- Asynchronous Module Definition (AMD).</p>
<p><a class="p_ident" id="p_69ZNnLLNhP" href="./10_modules.html#p_69ZNnLLNhP"></a>Нашата тривиална програма със зависимости, ще изглежда така в AMD:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_+VGbHf95V3" href="./10_modules.html#c_+VGbHf95V3"></a><span class="cm-variable">define</span>([<span class="cm-string">"weekDay"</span>, <span class="cm-string">"today"</span>], <span class="cm-keyword">function</span>(<span class="cm-def">weekDay</span>, <span class="cm-def">today</span>) {
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable-2">weekDay</span>.<span class="cm-property">name</span>(<span class="cm-variable-2">today</span>.<span class="cm-property">dayNumber</span>()));
});</pre>
<p><a class="p_ident" id="p_/aD387r6Uv" href="./10_modules.html#p_/aD387r6Uv"></a>Функцията <code>define</code> е в центъра на този подход. Тя взема първия модул с масив от имена и след това функцията, която приема само един аргумент за всяка зависимост. Тя ще зареди зависимостите(ако още не са заредени) във фонов режим, което позволява на страницата да продължи да работи, докато файловете се зареждат. След като, всички зависимости са заредени, <code>define</code> ще извика функцията с интерфейсите на тези зависимости, като аргументи.</p>
<p><a class="p_ident" id="p_w7/Slpc0XV" href="./10_modules.html#p_w7/Slpc0XV"></a>Модулите, които се зареждат по този начин трябва да съдържат извикване към <code>define</code>. Стойността, която се използва за техния интерфейс е тази, която се връща от функцията подадена към <code>define</code>. Сега тука е модулът <code>weekDay</code> отново:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_cye5TZvdJH" href="./10_modules.html#c_cye5TZvdJH"></a><span class="cm-variable">define</span>([], <span class="cm-keyword">function</span>() {
  <span class="cm-keyword">var</span> <span class="cm-def">names</span> <span class="cm-operator">=</span> [<span class="cm-string">"Sunday"</span>, <span class="cm-string">"Monday"</span>, <span class="cm-string">"Tuesday"</span>, <span class="cm-string">"Wednesday"</span>,
               <span class="cm-string">"Thursday"</span>, <span class="cm-string">"Friday"</span>, <span class="cm-string">"Saturday"</span>];
  <span class="cm-keyword">return</span> {
    <span class="cm-property">name</span>: <span class="cm-keyword">function</span>(<span class="cm-def">number</span>) { <span class="cm-keyword">return</span> <span class="cm-variable-2">names</span>[<span class="cm-variable-2">number</span>]; },
    <span class="cm-property">number</span>: <span class="cm-keyword">function</span>(<span class="cm-def">name</span>) { <span class="cm-keyword">return</span> <span class="cm-variable-2">names</span>.<span class="cm-property">indexOf</span>(<span class="cm-variable-2">name</span>); }
  };
});</pre>
<p><a class="p_ident" id="p_GARnQl+u0i" href="./10_modules.html#p_GARnQl+u0i"></a>За да мога да покажа минимално изпълнение на <code>define</code>, ще се преструваме, че имаме <code>backgroundReadFile</code> функция, която се използва, като име на файл и функция, и извиква функцията със съдържанието на файла, веднага след, като приключи зареждането. (<a href="./17_http.html#getURL">Глава 17</a> ще ви обясни, как се пишат такива функции.)</p>
<p><a class="p_ident" id="p_xNPCNpRiIX" href="./10_modules.html#p_xNPCNpRiIX"></a>За целите за проследяване на модулите, докато са натоварени, изпълнението на <code>define</code> ще използва преки допълнения, които описват състоянието на модулите и ни казват дали те са на разположение и предоставящи техния интрефейс, когато са.</p>
<p><a class="p_ident" id="p_/Unllb03Bv" href="./10_modules.html#p_/Unllb03Bv"></a>Функцията <code>getModule</code>, когато дава име, ще върне такъв обект и ще гарантира, че модулът планирано е зареден. Тя използва кеш обект, за да се избегне натоварване на същия модул два пъти.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_hSHaK3C/lo" href="./10_modules.html#c_hSHaK3C/lo"></a><span class="cm-keyword">var</span> <span class="cm-variable">defineCache</span> <span class="cm-operator">=</span> <span class="cm-variable">Object</span>.<span class="cm-property">create</span>(<span class="cm-atom">null</span>);
<span class="cm-keyword">var</span> <span class="cm-variable">currentMod</span> <span class="cm-operator">=</span> <span class="cm-atom">null</span>;

<span class="cm-keyword">function</span> <span class="cm-variable">getModule</span>(<span class="cm-def">name</span>) {
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">name</span> <span class="cm-keyword">in</span> <span class="cm-variable">defineCache</span>)
    <span class="cm-keyword">return</span> <span class="cm-variable">defineCache</span>[<span class="cm-variable-2">name</span>];

  <span class="cm-keyword">var</span> <span class="cm-keyword">module</span> <span class="cm-operator">=</span> {<span class="cm-property">exports</span>: <span class="cm-atom">null</span>,
                <span class="cm-property">loaded</span>: <span class="cm-atom">false</span>,
                <span class="cm-property">onLoad</span>: []};
  <span class="cm-variable">defineCache</span>[<span class="cm-variable-2">name</span>] <span class="cm-operator">=</span> <span class="cm-keyword">module</span>;
  <span class="cm-variable">backgroundReadFile</span>(<span class="cm-variable-2">name</span>, <span class="cm-keyword">function</span>(<span class="cm-def">code</span>) {
    <span class="cm-variable">currentMod</span> <span class="cm-operator">=</span> <span class="cm-keyword">module</span>;
    <span class="cm-keyword">new</span> <span class="cm-variable">Function</span>(<span class="cm-string">""</span>, <span class="cm-variable-2">code</span>)();
  });
  <span class="cm-keyword">return</span> <span class="cm-keyword">module</span>;
}</pre>
<p><a class="p_ident" id="p_r9NqByjA7c" href="./10_modules.html#p_r9NqByjA7c"></a>Ние предполагаме, че заредения файл съдържа също(единично) извикване към <code>define</code>. Променливата <code>currentMod</code> се използва за да отрази настоящата покана към обекта модул, който в момента се зарежда, така че да може да актуализира този обект, когато той завърши качването. Ние ще се върнем на този механизъм в един момент.</p>
<p><a class="p_ident" id="p_lX37OjlA5W" href="./10_modules.html#p_lX37OjlA5W"></a>Самата функция <code>define</code> използва <code>getModule</code> да донесе или да създаде обекти на модула за зависимости с текущия модул. Нейната задача е да планира <code>moduleFunction</code> (функцията, която съдържа действителния код на модула) да бъде стартирана всеки път, когато се зареждат тези зависимости. За тази цел тя определя функцията <code>whenDepsLoaded</code>, която да добавя към масива <code>onLoad</code> всички зависимости, които все още не са заредени. Тази функция се връща незабавно, ако все още има ненатоварени зависимости, така че ще извърши действителна работа само веднъж, когато последната зависимост приключи със зареждането. Тя също така извиква веднага <code>define</code> на себе си, в случай, че няма зависимости, които трябва да бъдат заредени.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_1c60YXnLU3" href="./10_modules.html#c_1c60YXnLU3"></a><span class="cm-keyword">function</span> <span class="cm-variable">define</span>(<span class="cm-def">depNames</span>, <span class="cm-def">moduleFunction</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">myMod</span> <span class="cm-operator">=</span> <span class="cm-variable">currentMod</span>;
  <span class="cm-keyword">var</span> <span class="cm-def">deps</span> <span class="cm-operator">=</span> <span class="cm-variable-2">depNames</span>.<span class="cm-property">map</span>(<span class="cm-variable">getModule</span>);

  <span class="cm-variable-2">deps</span>.<span class="cm-property">forEach</span>(<span class="cm-keyword">function</span>(<span class="cm-def">mod</span>) {
    <span class="cm-keyword">if</span> (<span class="cm-operator">!</span><span class="cm-variable-2">mod</span>.<span class="cm-property">loaded</span>)
      <span class="cm-variable-2">mod</span>.<span class="cm-property">onLoad</span>.<span class="cm-property">push</span>(<span class="cm-variable">whenDepsLoaded</span>);
  });

  <span class="cm-keyword">function</span> <span class="cm-def">whenDepsLoaded</span>() {
    <span class="cm-keyword">if</span> (<span class="cm-operator">!</span><span class="cm-variable-2">deps</span>.<span class="cm-property">every</span>(<span class="cm-keyword">function</span>(<span class="cm-def">m</span>) { <span class="cm-keyword">return</span> <span class="cm-variable-2">m</span>.<span class="cm-property">loaded</span>; }))
      <span class="cm-keyword">return</span>;

    <span class="cm-keyword">var</span> <span class="cm-def">args</span> <span class="cm-operator">=</span> <span class="cm-variable-2">deps</span>.<span class="cm-property">map</span>(<span class="cm-keyword">function</span>(<span class="cm-def">m</span>) { <span class="cm-keyword">return</span> <span class="cm-variable-2">m</span>.<span class="cm-property">exports</span>; });
    <span class="cm-keyword">var</span> <span class="cm-def">exports</span> <span class="cm-operator">=</span> <span class="cm-variable-2">moduleFunction</span>.<span class="cm-property">apply</span>(<span class="cm-atom">null</span>, <span class="cm-variable-2">args</span>);
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">myMod</span>) {
      <span class="cm-variable-2">myMod</span>.<span class="cm-property">exports</span> <span class="cm-operator">=</span> <span class="cm-variable-2">exports</span>;
      <span class="cm-variable-2">myMod</span>.<span class="cm-property">loaded</span> <span class="cm-operator">=</span> <span class="cm-atom">true</span>;
      <span class="cm-variable-2">myMod</span>.<span class="cm-property">onLoad</span>.<span class="cm-property">forEach</span>(<span class="cm-keyword">function</span>(<span class="cm-def">f</span>) { <span class="cm-variable-2">f</span>(); });
    }
  }
  <span class="cm-variable-2">whenDepsLoaded</span>();
}</pre>
<p><a class="p_ident" id="p_T+RexzI7A0" href="./10_modules.html#p_T+RexzI7A0"></a>Когато всички зависимости са на разположение, <code>whenDepsLoaded</code> извиква функция, която държи модула, който ще даде интерфейсите - зависимости, като аргументи.</p>
<p><a class="p_ident" id="p_8Neb8ba81Q" href="./10_modules.html#p_8Neb8ba81Q"></a>Първото нещо, което <code>define</code> прави е да съхрани стойностите, които <code>currentMod</code> имa, когато е извикан с променливата <code>myMod</code>. Не забравяйте, че <code>getModule</code> точно преди оценяването на кода за модул, съхранява съответния модул обект в <code>currentMod</code>. Това позволява на <code>whenDepsLoaded</code> да съхранява стойностa върнатa от функцията на модула в този модул със свойството <code>exports</code>, определя свойството на модула <code>loaded</code> да е <em>true</em> и призовава всички функции, които са в очакване на модула да се зареди.</p>
<p><a class="p_ident" id="p_KBR+VgwyVz" href="./10_modules.html#p_KBR+VgwyVz"></a>Този код е много по-труден за следване от <code>require</code> функцията. Неговото изпълнение не следва, прост, начертан план. Вместо това, множество операции са създадени да се случат в някакъв неопределен момент в бъдещето, което замъглява пътя на кода, който се изпълнява.</p>
<p><a class="p_ident" id="p_uewjoUxlIw" href="./10_modules.html#p_uewjoUxlIw"></a>Истинското изпълнение на AMD, е много по-интелигентно при определяне на имената на модулите от реалните Интернет адреси и като цяло по-стабилно, от колкото това показано по-рано. <em>RequireJS</em> (<a href="http://requirejs.org/"><em>requirejs.org</em></a>) осигурява изпълнението на този популярен стил за модулно зареждане.</p>
<h2><a class="h_ident" id="h_4266RdeHYR" href="./10_modules.html#h_4266RdeHYR"></a>Интерфейс  дизайн</h2>
<p><a class="p_ident" id="p_IUZ7uTWwwd" href="./10_modules.html#p_IUZ7uTWwwd"></a>Проектиране на интерфейси за модули и типове обекти е един от най-фините аспекти на програмирането. Всяко не тривиално парче функционалност може да се моделира по различни начини. Намирането на начин, който работи добре изисква проницателност и далновидност.</p>
<p><a class="p_ident" id="p_KweUtWCb7f" href="./10_modules.html#p_KweUtWCb7f"></a>Най-добрият начин за научаване на добрия дизайн на интерфейса е да се използват много интерфейси, някои добри, някои лоши. Опитът ще ви научи, какво работи и какво не. Никога не допускайте, че трудният интерфейс е “такъв, какъвто е”. Фиксирайте го или го увийте в нов интерфейс, който работи по-добре.</p>
<h3><a class="h_ident" id="h_D19q+FXBVd" href="./10_modules.html#h_D19q+FXBVd"></a>Предвидимост</h3>
<p><a class="p_ident" id="p_2adqTW0fxP" href="./10_modules.html#p_2adqTW0fxP"></a>Ако програмистите могат да прогнозират пътя на работа на интерфейса, те няма да се отклоняват от целта толкова често при необходимостта да гледат, как се използва. Така се опитват да следват конвенциите. Когато има друг модул или част от стандартна JavaScript среда, която прави нещо подобно на това, което се опитвате да приложите, може би е добра идея да направите вашия интерфейс по подобие на съществуващ интерфейс. По този начин, ще се почувствате близки с хора, които знаят за съществуващия интерфейс.</p>
<p><a class="p_ident" id="p_6l6v5cakoT" href="./10_modules.html#p_6l6v5cakoT"></a>Друга област, в която предсказуемоста е важна, е реалното поведение на вашия код. Може да се изкушите да направите ненужно сложен интерфейс с основанието, че е по-удобен за използване. Например, може да приеме всички видове от различни видове комбинации от аргументи и да направи “правилното” нещо за всички тях. Или пък може да предостави десетки специализирани функции, които осигуряват удобство с малко по различен вкус на функционалност на модула. Това може да направи кода, на който се основава вашия интерфейс малко по-къс, но също така ще го направи много по-труден за хората да градят по-ясен смислен модел на поведение на модула.</p>
<h3><a class="h_ident" id="h_+NeFt8aXxf" href="./10_modules.html#h_+NeFt8aXxf"></a>Composability</h3>
<p><a class="p_ident" id="p_9Nt/796F0G" href="./10_modules.html#p_9Nt/796F0G"></a>Във вашите интерфейси се опитайте да използвате най-простите структури от данни и правете вашите функции, ако е възможно да правят едно, ясно нещо. Винаги, когато е практично използвайте чисти функции (виж <a href="./03_functions.html#pure">Глава 3</a>).</p>
<p><a class="p_ident" id="p_qicKwwcIoO" href="./10_modules.html#p_qicKwwcIoO"></a>Например, не е необичайно за модули да предоставят техния собствен масиво - подобен обект, със собствен интерфейс за отчитане и извличане на елементи. Такива обекти няма да имат <code>map</code> и <code>forEach</code> методи и всяка съществуваща функция, която очаква реален масив няма да бъде в състояние да работи с тях. Това е пример за лошо <em>composability</em> - модулът не може лесно да бъде съставен с друг код.</p>
<p><a class="p_ident" id="p_XJefBK7ici" href="./10_modules.html#p_XJefBK7ici"></a>Един пример ще бъде модул за проверка на правописа на текст, който може да ни трябва, когато искаме да напишем текстов редактор. Проверката на правописа може да бъде направена да оперира директно със сложни структури от данни на използвания редактор и директно да извиква вътрешните функции на този редактор, за да има потребителя избор между предложения за правописа. Ако вървим по този път, модулът не може да се използва с други програми. От друга страна, ако ние определяме интерфейса за проверка на правописа, можем да го подадем на прост <em>string</em> и той да върне позиция в този <em>string</em>, където е възможно да има правописна грешка, заедно с набор от предложения за корекции, тогава имаме интерфейс, който може да бъде в състава на други системи, защото <em>strings</em> и масиви са винаги на разположение в JavaScript.</p>
<h3><a class="h_ident" id="h_vguoN2JlWc" href="./10_modules.html#h_vguoN2JlWc"></a>Слоеве  от  интерфейси</h3>
<p><a class="p_ident" id="p_gVRzuTdJxo" href="./10_modules.html#p_gVRzuTdJxo"></a>При проектирането на интерфейс за комплекс от парчета функционалност - например, за изпращане на поща - често се сблъскваме с една дилема. От една страна не искате да претоварите потребителя на вашия интерфейс с подробности. Той не трябва да учи вашия интерфейс 20 минути, преди да изпрати съобщение. От друга старана, вие не искате да скриете всички детайли, когато хората трябва да правят сложни неща с вашия модул, той трябва да бъде в състояние за това.</p>
<p><a class="p_ident" id="p_UAqdlcM0M6" href="./10_modules.html#p_UAqdlcM0M6"></a>Често решението е да се осигурят  два интерфейса: подробен ниско ниво за комплексни ситуации и високо ниво за рутинно използване. Втория обикновено лесно може да бъде построен с помоща на инструментите предоставени от първия. В модула за поща, интерфейса на високо ниво би могъл да бъде само една функция, с която се съобщава адреса на подателя и адреса на получателя  и след това се изпраша емейла. Интерфейса на ниско ниво ще позволи пълен контрол над пощата: заглавие, прикачени файлове, HTML поща и т.н.</p>
<h2><a class="h_ident" id="h_ErccPg/l98" href="./10_modules.html#h_ErccPg/l98"></a>Резюме</h2>
<p><a class="p_ident" id="p_hGwRhRocwV" href="./10_modules.html#p_hGwRhRocwV"></a>Модулите предоставят структура за по-големи програми, чрез отделяне на кода в различни файлове и <em>namespaces</em>. Давайки на тези модули добре дефинирани интерфейси ги прави по-лесни за използване и преизползване, и дава възможност да се продължи използването им, когато модулът се развива.</p>
<p><a class="p_ident" id="p_G2usOklg33" href="./10_modules.html#p_G2usOklg33"></a>Въпреки, че езика на JavaScript е характерно безполезен, когато става въпрос за модули, гъвкавите функции и обекти, които той предоставя дават възможност да се определят по-скоро хубави системи от модули. Кодовете на функциите могат да се използват за вътрешни <em>namespaces</em> за модула, а обектите могат да се използват за съхранение на комплект от експортни стойности.</p>
<p><a class="p_ident" id="p_0LAk7BPgRr" href="./10_modules.html#p_0LAk7BPgRr"></a>Има два популярни добре определени подхода към тези модули. Единият се нарича <em>CommonJS Modules</em> и се върти около <code>require</code> функцията, която извлича модул по име и връща интерфейса му. Другата се нарича <em>AMD</em> и използва <code>define</code> функцията, която взема масив от имена на модули и функции, и след като зареди модулите стартира функция с нейните потребителски интерфейси, като аргументи.</p>
<h2><a class="h_ident" id="h_TcUD2vzyMe" href="./10_modules.html#h_TcUD2vzyMe"></a>Упражнения</h2>
<h3><a class="h_ident" id="h_Ft63zbY95i" href="./10_modules.html#h_Ft63zbY95i"></a>Имената на месеца</h3>
<p><a class="p_ident" id="p_dU0pnoSPR9" href="./10_modules.html#p_dU0pnoSPR9"></a>Напишете прост модул подобен на <code>weekDay</code>, който може да конвертира номера на месец(с нулева база, като в типа <code>Date</code>) в имена и имена обратно в номера. Дайте му свое собствено <em>namespace</em>,  тъй като ще се нуждае от вътрешен масив с имената на месеците и използвайте обикновен JavaScript, без каквато и да е система от зареждащи модули.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_YcMMskAlqo" href="./10_modules.html#c_YcMMskAlqo"></a><span class="cm-comment">// Your code here.</span>

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">month</span>.<span class="cm-property">name</span>(<span class="cm-number">2</span>));
<span class="cm-comment">// → March</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">month</span>.<span class="cm-property">number</span>(<span class="cm-string">"November"</span>));
<span class="cm-comment">// → 10</span></pre>
<div class="solution"><div class="solution-text">
<p><a class="p_ident" id="p_N564mECTK6" href="./10_modules.html#p_N564mECTK6"></a>Това е почти точно следване на модула <code>weekDay</code>. Функцията израз извикана веднага, опакова променливата, която държи масива с имената, както и две функции, които трябва да се експортират. Функциите се поставят в един обект и се връщат. Върнатия обект на интерфейса се съхранява в променливата <code>month</code>.</p>
</div></div>
<h3><a class="h_ident" id="h_3j/KaVGNV2" href="./10_modules.html#h_3j/KaVGNV2"></a>Връщане към електронния живот</h3>
<p><a class="p_ident" id="p_+royQ52RxC" href="./10_modules.html#p_+royQ52RxC"></a>Надявам се, че споменът за <a href="./07_elife.html#elife">Chapter 7</a> е още пресен в съзнанието ви, да се върнем обратно в системата на проектната глава и да излезем с начин да се раздели кода в модули. За да освежим паметта си, това са функциите и типовете, определени в тази глава по реда на появяването им:</p>
<pre>Vector
Grid
directions
directionNames
randomElement
BouncingCritter
elementFromChar
World
charFromElement
Wall
View
WallFollower
dirPlus
LifelikeWorld
Plant
PlantEater
SmartPlantEater
Tiger</pre>
<p><a class="p_ident" id="p_qH0Xj8v2nH" href="./10_modules.html#p_qH0Xj8v2nH"></a>Непреувеличавайте и не създавайте твърде много модули. Една книга, която започва нова глава на всяка страница, вероятно ще ви се качи на нервите, дори и само заради пространството, което губи от новите заглавия. По същия начин, да отваряте 10 файла за четене на един малък проект не е от полза. Целта ви е от 3 до 5 модула.</p>
<p><a class="p_ident" id="p_fDzWqQqyw8" href="./10_modules.html#p_fDzWqQqyw8"></a>Можете да определите, някои функции да станат вътрешни за техния модул и по този начин недостъпни за други модули.</p>
<p><a class="p_ident" id="p_XYYo0/YDOl" href="./10_modules.html#p_XYYo0/YDOl"></a>Няма правилен отговор тука. Модулната организация до голяма степен е въпрос на вкус.</p>
<div class="solution"><div class="solution-text">
<p><a class="p_ident" id="p_E3iJwXoILn" href="./10_modules.html#p_E3iJwXoILn"></a>Ето какво измислих. Сложил съм скоби около вътрешните функции.</p>
<pre>Module "grid"
  Vector
  Grid
  directions
  directionNames

Module "world"
  (randomElement)
  (elementFromChar)
  (charFromElement)
  View
  World
  LifelikeWorld
  directions [reexported]

Module "simple_ecosystem"
  (randomElement) [duplicated]
  (dirPlus)
  Wall
  BouncingCritter
  WallFollower

Module "ecosystem"
  Wall [duplicated]
  Plant
  PlantEater
  SmartPlantEater
  Tiger</pre>
<p><a class="p_ident" id="p_VwnqNlhTuk" href="./10_modules.html#p_VwnqNlhTuk"></a>Аз имам масив от реекспортирани <code>directions</code> от <code>grid</code> на модула на <code>world</code>, така че построените модули на (екосистемата) не трябва да знаят или притесняват за съществуването на 
<code>grid</code> модул.</p>
<p><a class="p_ident" id="p_2pzeyE24tw" href="./10_modules.html#p_2pzeyE24tw"></a>Също така, дублирам две общи и малки помощни стойности (<code>randomElement</code> and <code>Wall</code>), тъй като те се използват като вътрешна информация в различни контексти и не принадлежат на интерфейсите за тези модули.</p>
</div></div>
<h3><a class="h_ident" id="h_E/zWqBFdy8" href="./10_modules.html#h_E/zWqBFdy8"></a>Кръгови  зависимости</h3>
<p><a class="p_ident" id="p_/LVNV6+2SH" href="./10_modules.html#p_/LVNV6+2SH"></a>Трудна тема в управлението на зависимостите са кръговите зависимости, където модул А зависи от В и В също зависи от А. Много модулни системи просто забравят това. CommonJS позволява ограничена форма: той работи толкова дълго с модулите, докато не постави в тях по подразбиране <code>exports</code> обект с друга стойност и стартира достъп до интерфейса между тях само след завършване на зареждането.</p>
<p><a class="p_ident" id="p_BFm3QczrDZ" href="./10_modules.html#p_BFm3QczrDZ"></a>Сещате ли се за начин, който помага да се осъществи това? Погледнете на зад към определението на <code>require</code> и преценете какви функции ще трябва да направите, за да позволите това.</p>
<div class="solution"><div class="solution-text">
<p><a class="p_ident" id="p_By5oQNAE2m" href="./10_modules.html#p_By5oQNAE2m"></a>Номерът е да се добави <code>exports</code> обект, създаден за модула на <code>require</code> кеша, преди действителното пускане на модула. Това означава, че модула няма все още шанс да преодолее <code>module.exports</code>, така че ние не знаем дали той може да иска да изнася някаква друга стoйност. След <em>loading</em> (зареждане), кеша на обекта е изместен от <code>module.exports</code>, който може да бъде различна стойност.</p>
<p><a class="p_ident" id="p_xRLcTfyWjS" href="./10_modules.html#p_xRLcTfyWjS"></a>Но ако в процеса на зареждане на модула, е зареден втори модул, той пита първия модул за неговия по подразбиране <code>exports</code> обект, който най-вероятно е празен в този момент и ще бъде в кеша и втория модул ще получи препратка към него. Ако той не се опита да направи нещо с този обект до завършване на зареждането на първия модул, нещата ще работят.</p>
</div></div>
<nav>
  <a href="./09_regexp.html" title="previous chapter">◀</a>
  <a href="./index.html" title="cover">◆</a>
  <a href="./11_language.html" title="next chapter">▶</a>
</nav>
</article>
</body></html>