<!DOCTYPE html>
<!-- saved from url=(0044)./01_values.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <title>Values, Types, and Operators :: Eloquent JavaScript</title>
  <link rel="stylesheet" href="./media/codemirror.css">
  <script src="./media/acorn_codemirror.js"></script>
  <link rel="stylesheet" href="./media/ejs.css">
  <script src="./media/sandbox.js"></script>
  <script src="./media/ejs.js"></script>
  <script>var chapNum = 1;</script>
</head>

<body><article>
<nav>
  <a href="./00_intro.html" title="previous chapter">◀</a>
  <a href="./index.html" title="cover">◆</a>
  <a href="./02_program_structure.html" title="next chapter">▶</a>
</nav>

<h1><div class="chap_num">Глава 1</div>Стойности, типове и оператори.</h1>
<blockquote>
<p><a class="p_ident" id="p_93S4YBaGUf" href="./01_values.html#p_93S4YBaGUf"></a>Под повърхността на устройството, програмата се движи. Без усилие тя се разширява и свива. В голяма хармония, електрони се разпръскват и групират. Формите на монитора са, като вълни във водата. Същността остава невидима от долу.”</p>
 <footer>Master Yuan-Ma, <cite>Книга за програмиране</cite></footer>
</blockquote>
<p><a class="p_ident" id="p_WcNfmhhcRw" href="./01_values.html#p_WcNfmhhcRw"></a><em>Inside</em> е компютърен свят, в който има само данни. Можете да четете информация, да променяте и създавате данни, но всичко, което просто съществува е данни. Всички тези данни се съхраняват като дълги поредици от битове и всичко е основано на това.</p>
<p><a class="p_ident" id="p_W1gJpe5a7/" href="./01_values.html#p_W1gJpe5a7/"></a>Бит е двустойностно нещо обикновено се описва, като нули и единици. Във вътрешността на компютъра, те са под формата на по-висок или нисък електрически заряд, силен или слаб сигнал, лъскаво или матово място по повърхността на CD. Всяко парче от обособена информация може да се намали до последователност от нули и единици представени в бит.</p>
<p><a class="p_ident" id="p_4aF4f4tRCh" href="./01_values.html#p_4aF4f4tRCh"></a>На пример, как може да се представи числото 13 в бит. То работи по същия начин, като десетичните числа, но вместо 10 различни цифри имаме само 2, а степента на всяка се увеличава с коефициент 2 от дясно на ляво. Това са битовете, които съхраняват числото 13 със степента на цифрите показани по-долу от тях:</p>
<pre>   0   0   0   0   1   1   0   1
 128  64  32  16   8   4   2   1</pre>
<p><a class="p_ident" id="p_smhcwCTgI+" href="./01_values.html#p_smhcwCTgI+"></a>И така, това е двоичен номер 00001101 или 8+4+1, което се равнява на 13.</p>
<h2><a class="h_ident" id="h_sVZPaxUSy/" href="./01_values.html#h_sVZPaxUSy/"></a>Стойности</h2>
<p><a class="p_ident" id="p_ySnc2wG5kf" href="./01_values.html#p_ySnc2wG5kf"></a>Представете си море от битове. Океан от тях. Един типичен модерен компютър има повече от 30 милиарда бита в своите летливо съхранени данни. Nonvolatile storage (твърд диск или еквивалент) има тенденция да има няколко магнитута повече.</p>
<div class="image">
  <img src="./media/bit-sea.png" alt="The Ocean of Bits">
</div>
<p><a class="p_ident" id="p_e7djokdoxd" href="./01_values.html#p_e7djokdoxd"></a>За да може да се работи с такива количества битове без да се обърква, се разделят на парчета, които представляват части от информацията. В средата на JavaScript, тези парчета се наричат стойности. Въпреки, че всички стойности са направени от битове, те играят различни роли. Всяка стойност има тип, който определя неговата роля. Има шест основни типа стойности в JavaScript: numbers, strings, Booleans, objects, functions и undefined value.</p>
<p><a class="p_ident" id="p_+ayfFmFdze" href="./01_values.html#p_+ayfFmFdze"></a>За създаване на стойност трябва да се назове само името и. Това е удобно. На вас не ви се налага да изграждате вашите стойности. Просто извикайте една и я има. Те не са създадени от нищото, разбира се. Всяка стойност трябва да се съхранява някъде. И ако искате да използвате една гигантска сума от тях, може да изчерпите наличните битове. За щастие, това е проблем само ако имате нужда от всички тях едновременно. Веднага след, като вече не използвате стойност, тя ще се разсее, оставяйки след себе си битове, които се рециклират за следващото поколение стойности.</p>
<p><a class="p_ident" id="p_4qFZuA8nQ3" href="./01_values.html#p_4qFZuA8nQ3"></a>Тази глава ни запознава с атомните елементи на програмите в  JavaScript, това са видовете прости стойности и операторите, които действат върху тях.</p>
<h2><a class="h_ident" id="h_flOCH3CuFg" href="./01_values.html#h_flOCH3CuFg"></a>Числа</h2>
<p><a class="p_ident" id="p_lB/BspzEbz" href="./01_values.html#p_lB/BspzEbz"></a>Стойността на вида 
<em>number</em> са изненадващо, числови стойности. В програмите на JavaScript, се записват както числа:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_vTB6PsMp4Q" href="./01_values.html#c_vTB6PsMp4Q"></a><span class="cm-number">13</span></pre>
<p><a class="p_ident" id="p_5FswHziHvR" href="./01_values.html#p_5FswHziHvR"></a>Използвайки тази стойност в програмите, ще доведе до моделът на битовете за числото 13, вътре в компютърната памет.</p>
<p><a class="p_ident" id="p_34VeW0GvxJ" href="./01_values.html#p_34VeW0GvxJ"></a>JavaScript използва фиксиран брой битове, а именно 64 от тях за съхранение на една числова стойност. Това са толкова модели колкото могат да се направят с 64 бита, което означава, че количеството на различните номера, които могат да бъдат представени е ограничен. За <em>N</em> десетични числа, сумата от числата, които могат да бъдат представени е 10<sup><em>N</em></sup>. По същия начин имайки в предвид 64-те двоични цифри, можем да представим 2<sup>64</sup> различни номера, което е около 18 квинталиона (18 с 18 нули след него), а това е много.</p>
<p><a class="p_ident" id="p_WcfWpTcQB6" href="./01_values.html#p_WcfWpTcQB6"></a>Компютърната памет използва много по-малко и хората са склонни да използват групи от 8 и 16 бита, когато представят техните номера. Преди беше лесно да се представят случайни малки номера, които да не могат да се впишат в даден размер на бита. Днес, дори и персоналните компютри имат достатъчно памет, за да може свободно да се използват 64 битови парчета, което означава, че трябва да се притесняваме от препълване на паметта само, когато се занимаваме с наистина астрономически цифри.</p>
<p><a class="p_ident" id="p_qgS+bpqvEk" href="./01_values.html#p_qgS+bpqvEk"></a>Не всички цели числа под 18 квинталиона се вписват в номер на JavaScript, все пак. В битовите също се съхраняват и отрицателни числа, така че един бит се използва за да показва знака на числото. По-голям проблем обаче е, че и не-цели числа същото трябва да бъдат представени. За да се направи това някои от битовете се използват за съхранение на позицията на десетичната запетая. Действителното максимално цяло число, което може да се съхранява е от порядъка на 9 квадрилиона (15 нули), което все още е огромно.</p>
<p><a class="p_ident" id="p_+wzyK91zcb" href="./01_values.html#p_+wzyK91zcb"></a>Дробни числа се изписват с помощта на точка:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_pDtjSHBkOT" href="./01_values.html#c_pDtjSHBkOT"></a><span class="cm-number">9.81</span></pre>
<p><a class="p_ident" id="p_j34c/ZU9g4" href="./01_values.html#p_j34c/ZU9g4"></a>За много големи или много малки числа, може да използвате и научна нотация, чрез добавяне на “e” (наречено-експонента) следвана от експонентата на броя:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_BcwYGRXGfX" href="./01_values.html#c_BcwYGRXGfX"></a><span class="cm-number">2.998e8</span></pre>
<p><a class="p_ident" id="p_YbACmHw8Kd" href="./01_values.html#p_YbACmHw8Kd"></a>Това е  2.998 × 10<sup>8</sup> = 299,800,000.</p>
<p><a class="p_ident" id="p_8KgYC0F1fX" href="./01_values.html#p_8KgYC0F1fX"></a>Изчисления с цели числа (наричани <em>integers</em>) по-малки от посочените по-горе 9 квадрилиона са гарантирани да бъдат винаги точни. За съжаление изчисленията с дробни числа обикновено не са. Точно, както π (пи) не може да бъде точно изразено от краен брой десетични цифри, така и много номера губят част от своята прецизност, когато само 64 бита са на разположение да ги съхраняват. Това е жалко, но причинява практически проблеми само в определени случаи. Важно е да сме наясно с това и да мислим за дробните числа като цифрови приближения, а не като точни стойности.</p>
<h3><a class="h_ident" id="h_RfBT3HMnYs" href="./01_values.html#h_RfBT3HMnYs"></a>Аритметика</h3>
<p><a class="p_ident" id="p_PO8MaZIpG1" href="./01_values.html#p_PO8MaZIpG1"></a> Основното общо нещо с номерата е аритметиката. Аритметични операции, като събиране или умножение, вземат две цифрови стойности и произвеждат нов номер от тях. Ето как изглежда това в JavaScript:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_j8xQkvZ7Iq" href="./01_values.html#c_j8xQkvZ7Iq"></a><span class="cm-number">100</span> <span class="cm-operator">+</span> <span class="cm-number">4</span> <span class="cm-operator">*</span> <span class="cm-number">11</span></pre>
<p><a class="p_ident" id="p_OLlk8/LnDv" href="./01_values.html#p_OLlk8/LnDv"></a>Символите <code>+</code> и <code>*</code> се наричат оператори. Първият е за събиране, а вторият е за умножение. Поставянето на оператор между две стойности се прилага с цел тези стойности да произведат нова стойност.</p>
<p><a class="p_ident" id="p_5vxWadZU3g" href="./01_values.html#p_5vxWadZU3g"></a>Означава ли този пример - събери 4 и 100 и резултатът умножи по 11 или се извършва първо умножението преди събирането? Както може би се досещате умножението се извършва първо. Но в областта на математиката, можете да промените това, като заградите операцията, която искате да се извърши първа в скоби.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_pMHkELf8+H" href="./01_values.html#c_pMHkELf8+H"></a>(<span class="cm-number">100</span> <span class="cm-operator">+</span> <span class="cm-number">4</span>) <span class="cm-operator">*</span> <span class="cm-number">11</span></pre>
<p><a class="p_ident" id="p_qti+2j7Cn8" href="./01_values.html#p_qti+2j7Cn8"></a>За изваждане е оператора <code>-</code> ,а за делене е <code>/</code> .</p>
<p><a class="p_ident" id="p_VY/pZpQE/a" href="./01_values.html#p_VY/pZpQE/a"></a>Когато операторите се появяват заедно без скоби, редът на тяхното прилагане се определя от предимството на операторите. Примерът показва, че умножението се извършва преди събирането. Операторът за делене / има същото предимство, както за умножение *. По същия начин се определят и  +  и  - . Когато няколко оператора с едно и също предимство се появят един до друг, като 1 - 2 + 1, те се прилагат от ляво на дясно: (1 - 2) + 1.</p>
<p><a class="p_ident" id="p_epF5qxonWY" href="./01_values.html#p_epF5qxonWY"></a>Тези правила за предимство не са нещо, за което трябва да се притеснявате. Когато се съмнявате, просто добавете скоби.</p>
<p><a class="p_ident" id="p_qMmcH3brf3" href="./01_values.html#p_qMmcH3brf3"></a>Има още един оператор, който може да се призове незабавно- %  символът се използва за определяне на остатъка от операцията. Х % Y е остатъка от деленето на Х от Y. Например, остатъка от 314 % 100 е 14 и остатъка от 144 % 12 е 0. Често ще виждате този оператор посочен като модул, макар че технически погледнато остатък е по-точно наименование.</p>
<h3><a class="h_ident" id="h_R4eFf8w7Yz" href="./01_values.html#h_R4eFf8w7Yz"></a>Специални  номера</h3>
<p><a class="p_ident" id="p_JBBwZano0e" href="./01_values.html#p_JBBwZano0e"></a>Има три специални стойности в JavaScript, които се смятат за числа, но не се държат като нормални такива.</p>
<p><a class="p_ident" id="p_2+t3nK7Yp2" href="./01_values.html#p_2+t3nK7Yp2"></a>Първите две са <code>Infinity</code> и <code>-Infinity</code>, които представляват положителна и отрицателна безкрайност. <code>Infinity - 1</code> все още е <code>Infinity</code> и т.н. Не влагайте прекалено голямо доверие в изчисления базирани на безкрайност. Те не са математически солидни и бързо ще доведат до следващия специален номер: <code>NaN</code>.</p>
<p><a class="p_ident" id="p_E2lMHg1a0p" href="./01_values.html#p_E2lMHg1a0p"></a><code>NaN</code> означава “не число” (“not a number”) макар и да е стойност от типа номер. <em>NaN</em> се получава, например, когато се опитаме да разделим <code>0 / 0</code> (нула делено на нула), <code>Infinity - Infinity</code> или произволен брой числови операции, които не дават точен, смислен резултат.</p>
<h2><a class="h_ident" id="h_OBbEvqxHHH" href="./01_values.html#h_OBbEvqxHHH"></a>Strings</h2>
<p><a class="p_ident" id="p_JUYnmsnZEA" href="./01_values.html#p_JUYnmsnZEA"></a>Следващият основен тип данни е <em>string</em>. Той се използва за представяне на текст, който е написан в кавички.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_pB8USspQsW" href="./01_values.html#c_pB8USspQsW"></a><span class="cm-string">"Patch my boat with chewing gum"</span>
<span class="cm-string">'Monkeys wave goodbye'</span></pre>
<p><a class="p_ident" id="p_Y57GE4NUct" href="./01_values.html#p_Y57GE4NUct"></a>И двете единични и двойни кавички могат да се използват за отбелязване на <em>strings</em> , но не и двата вида едновременно.Текстовете могат да бъдат толкова дълги, колкото са отбелязани с кавички от началото до края на <em>string</em>.</p>
<p><a class="p_ident" id="p_ah2sKgvNub" href="./01_values.html#p_ah2sKgvNub"></a>Почти всичко може да се постави между кавичките и JavaScript ще направи <em>string</em> стойност от него. Но няколко знака са по-трудни. Може да си представите поставянето на кавички между кавичките,  колко може да бъде трудно. Знакът за нов ред (знаците, които се получават, когато натиснете <em>Enter</em>) също не могат да се поставят между кавички. <em>String</em> трябва да остане на един ред.</p>
<p><a class="p_ident" id="p_Fhyuks46v3" href="./01_values.html#p_Fhyuks46v3"></a>За да може да се включат такива знаци в <em>string</em>, се използва следната нотация: когато наклонена черта (<code>\</code>) се намира вътре в цитирания текст, това показва, че характерът след нея има специално значение. Това се нарича <code>бягство</code>
от характер. Цитат, който се предхожда от наклонена черта <code>\</code> няма да сложи край на <em>string</em>, а e част от него. Когато се постави <code>n</code> след наклонената черта <code>\</code>, това се тълкува като знак за нов ред <code>\n</code>. По същия начин, <code>t</code> след наклонена черта <code>\</code> означава табулация <code>\t</code>.</p>
<p>Погледнете следния <em>string</em>:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_+tEhLdJIcu" href="./01_values.html#c_+tEhLdJIcu"></a><span class="cm-string">"This is the first line\nAnd this is the second"</span></pre>
<p><a class="p_ident" id="p_rtFNX67M4o" href="./01_values.html#p_rtFNX67M4o"></a>В действителност текста изглежда така:</p>
<pre>This is the first line
And this is the second</pre>
<p><a class="p_ident" id="p_RcQxEVsohZ" href="./01_values.html#p_RcQxEVsohZ"></a>Има разбира се ситуации в които искате наклонената черта в <em>string</em> да бъде само една наклонена черта, а не специален код. Ако две наклонени черти се следват една друга, <em>strings</em> ще се разпадне и само една ще бъде оставена в получения <em>string</em> без стойност. Например текста: “<code>A newline
character is written like "\n".</code>” може да се изрази в <em>string</em> по следния начин:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_nou8u5sxl3" href="./01_values.html#c_nou8u5sxl3"></a><span class="cm-string">"A newline character is written like \"\\n\"."</span></pre>
<p><a class="p_ident" id="p_FBU7ANmjDA" href="./01_values.html#p_FBU7ANmjDA"></a><em>String</em> не могат да бъдат разделяни, умножавани или изваждани, но <code>+</code> оператора може да се използва върху тях. Той не събира, но конкатенира - слепва два <em>strings</em> заедно. Следващия ред ще произведе <em>string</em> - <code>"concatenate"</code>:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_oV+FsD85id" href="./01_values.html#c_oV+FsD85id"></a><span class="cm-string">"con"</span> <span class="cm-operator">+</span> <span class="cm-string">"cat"</span> <span class="cm-operator">+</span> <span class="cm-string">"e"</span> <span class="cm-operator">+</span> <span class="cm-string">"nate"</span></pre>
<p><a class="p_ident" id="p_+o5PJ5ubRj" href="./01_values.html#p_+o5PJ5ubRj"></a>Има още начини за манипулиране на <em>strings</em>, които ще обсъдим, когато стигнем методи в <a href="./04_data.html#methods">глава 4</a>.</p>
<h2><a class="h_ident" id="h_ygn12/ieo+" href="./01_values.html#h_ygn12/ieo+"></a>Унарни оператори</h2>
<p><a class="p_ident" id="p_GyQlmgK5IK" href="./01_values.html#p_GyQlmgK5IK"></a>Не всички оператори са символи. Някои от тях са написани като думи. Един такъв пример е оператора <code>typeof</code>, който произвежда <em>string</em> стойност: името на типа на стойността, която си подал.</p>
<pre data-language="javascript" class="snippet cm-s-default"><div class="sandboxhint">edit &amp; run code by clicking it</div><a class="c_ident" id="c_cbV8yHeFlx" href="./01_values.html#c_cbV8yHeFlx"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-keyword">typeof</span> <span class="cm-number">4.5</span>)
<span class="cm-comment">// → number</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-keyword">typeof</span> <span class="cm-string">"x"</span>)
<span class="cm-comment">// → string</span></pre>
<p id="console.log"><a class="p_ident" id="p_X4IS2nLCLI" href="./01_values.html#p_X4IS2nLCLI"></a>Ще използваме <code>console.log</code> в примерния код, за да можем да видим резултата от оценката на нещо. Когато стартирате такъв код, произведената стойност трябва да се покаже на екрана, макар и да изглежда, че зависи от средата на JavaScript го използвайте за да стартирате кода.</p>
<p><a class="p_ident" id="p_j8F6SrKjF/" href="./01_values.html#p_j8F6SrKjF/"></a>Другите оператори, които разгледахме, всички оперират с две стойности, но <code>typeof</code> ползва само една. Операторите които използват две стойности се наричат бинарни оператори, а тези които използват една стойност се наричат унарни оператори. Операторът  минус, може да се използва, както за бинарен така и за унарен оператор.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_I6DXnYgW4r" href="./01_values.html#c_I6DXnYgW4r"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-operator">-</span> (<span class="cm-number">10</span> <span class="cm-operator">-</span> <span class="cm-number">2</span>))
<span class="cm-comment">// → -8</span></pre>
<h2><a class="h_ident" id="h_cTPxJxlmFR" href="./01_values.html#h_cTPxJxlmFR"></a>Булеви стойности - Boolean values</h2>
<p><a class="p_ident" id="p_6L5kUCK2Lz" href="./01_values.html#p_6L5kUCK2Lz"></a>Често, ще ви е необходима стойност, която да прави разграничение между две възможности, като “yes” и “no” или “on” и “off”. За това в JavaScript има Булев тип, който има само две стойности: вярно и невярно (които са написани просто като думи <em>true</em> и <em>false</em>).</p>
<h3><a class="h_ident" id="h_5G7gD95A6V" href="./01_values.html#h_5G7gD95A6V"></a>Сравнения.</h3>
<p><a class="p_ident" id="p_T4yLn4fXDH" href="./01_values.html#p_T4yLn4fXDH"></a>Това е един от начините за произвеждане на булеви стойности:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_xiXHb34xBv" href="./01_values.html#c_xiXHb34xBv"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-number">3</span> <span class="cm-operator">&gt;</span> <span class="cm-number">2</span>)
<span class="cm-comment">// → true</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-number">3</span> <span class="cm-operator">&lt;</span> <span class="cm-number">2</span>)
<span class="cm-comment">// → false</span></pre>
<p><a class="p_ident" id="p_j0tOwzfb6M" href="./01_values.html#p_j0tOwzfb6M"></a>The <code>&gt;</code> и <code>&lt;</code> са символите за “по-голямо от ” и ”по-малко от”. Те са двукомпонентни оператори. Прилагането им води до булева стойност, която показва дали е верен този случай.</p>
<p><a class="p_ident" id="p_NxTGvCsM4s" href="./01_values.html#p_NxTGvCsM4s"></a><em>Strings</em> могат да бъдат сравнени по същия начин.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_VDjRyWchqq" href="./01_values.html#c_VDjRyWchqq"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"Aardvark"</span> <span class="cm-operator">&lt;</span> <span class="cm-string">"Zoroaster"</span>)
<span class="cm-comment">// → true</span></pre>
<p><a class="p_ident" id="p_No3uOP/bY2" href="./01_values.html#p_No3uOP/bY2"></a>Начинът на подредба на <em>strings</em> е повече или по-малко азбучен: главните букви са винаги “по-малки”от малките такива, така че <code>"Z" &lt; "a"</code> е вярно и други знаци (!, -, и т.н.) също са включени в подредбата. Действието на сравнението се основава на стандарта <em>Unicode</em>. Този стандарт определя номер за почти всеки характер, от който ще имате някога нужда, включително и от Гръцки, Арабски, Японски и т.н. Tакива номера са полезни за съхраняване на <em>strings</em> вътре в компютъра, защото така ще бъде възможно да се представят като последоватленост от числа. При сравняване на <em>strings</em>, JavaScript ги проверява от ляво на дясно, като се сравняват цифровите кодове на символите един по един.</p>
<p><a class="p_ident" id="p_fGKTuK5BBc" href="./01_values.html#p_fGKTuK5BBc"></a>Други подобни: 
 <code>&gt;=</code> (по-голямо или равно), <code>&lt;=</code> (по-малко или равно), <code>==</code> (равно), и
<code>!=</code> (различно).</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_2rW/lxam/h" href="./01_values.html#c_2rW/lxam/h"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"Itchy"</span> <span class="cm-operator">!=</span> <span class="cm-string">"Scratchy"</span>)
<span class="cm-comment">// → true</span></pre>
<p><a class="p_ident" id="p_tLooHn2QPj" href="./01_values.html#p_tLooHn2QPj"></a>Има само една стойност в JavaScript, която не е равна на себе си, това е <code>NaN</code>, което означава “не номер”.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_ipVz0wMIWL" href="./01_values.html#c_ipVz0wMIWL"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-atom">NaN</span> <span class="cm-operator">==</span> <span class="cm-atom">NaN</span>)
<span class="cm-comment">// → false</span></pre>
<p><a class="p_ident" id="p_/oU7fPa5Kl" href="./01_values.html#p_/oU7fPa5Kl"></a>С <code>NaN</code> се означава резултата от безсмислено изчисление и като такова не е равно на резултата от други безсмислени изчисления.</p>
<h3><a class="h_ident" id="h_pdqDW7Pebo" href="./01_values.html#h_pdqDW7Pebo"></a>Логически оператори</h3>
<p><a class="p_ident" id="p_nRCLrGwcCn" href="./01_values.html#p_nRCLrGwcCn"></a>Има също някои операции, на които могат да се прилагат булеви стойности. JavaScript поддържа три логически оператора: <em>и</em>, <em>или</em>, и <em>не</em>. Те могат да се използват, като причина за Булев тип.</p>
<p><a class="p_ident" id="p_h6pEyNS4IJ" href="./01_values.html#p_h6pEyNS4IJ"></a>Оператора <code>&amp;&amp;</code> представлява логическо <em>и</em>. Той е бинарен оператор и неговия резултат е вярно само ако и двете подадени стойности са верни. </p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_t4ZiXDWhwB" href="./01_values.html#c_t4ZiXDWhwB"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-atom">true</span> <span class="cm-operator">&amp;&amp;</span> <span class="cm-atom">false</span>)
<span class="cm-comment">// → false</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-atom">true</span> <span class="cm-operator">&amp;&amp;</span> <span class="cm-atom">true</span>)
<span class="cm-comment">// → true</span></pre>
<p><a class="p_ident" id="p_T/V30CHY82" href="./01_values.html#p_T/V30CHY82"></a>Операторът <code>||</code> означава логическо <em>или</em>. Неговия резултат е вярно, ако поне една от подадените му стойности е вярна.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_MyM/xeosFi" href="./01_values.html#c_MyM/xeosFi"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-atom">false</span> <span class="cm-operator">||</span> <span class="cm-atom">true</span>)
<span class="cm-comment">// → true</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-atom">false</span> <span class="cm-operator">||</span> <span class="cm-atom">false</span>)
<span class="cm-comment">// → false</span></pre>
<p><a class="p_ident" id="p_JakZ+mTPwL" href="./01_values.html#p_JakZ+mTPwL"></a>Операторът <em>не</em> означава логическо не и се изписва, като удивителен знак (<code>!</code>). Той е унарен оператор, който променя подадената му стойност:</p>
 <p> —<code>!true</code> произвежда <code>false</code> и <code>!false</code> произвежда <code>true</code>.</p>
<p><a class="p_ident" id="p_qSXjNNI5/y" href="./01_values.html#p_qSXjNNI5/y"></a>При смесване на тези булеви оператори с аритметика и други оператори не винаги е очевидно, кога са необходими скоби. На практика може да научите това знаейки от операторите, които сме виждали до сега. <code>||</code> има най-ниско предимство, след това идва <code>&amp;&amp;</code>, след него операторите за сравнение <code>&gt;</code>, <code>==</code> и т.н., а след това останалите. Те са избрани така с цел, когато при типични изрази, като следващия няколко скоби са необходими.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_D90BLmBiLw" href="./01_values.html#c_D90BLmBiLw"></a><span class="cm-number">1</span> <span class="cm-operator">+</span> <span class="cm-number">1</span> <span class="cm-operator">==</span> <span class="cm-number">2</span> <span class="cm-operator">&amp;&amp;</span> <span class="cm-number">10</span> <span class="cm-operator">*</span> <span class="cm-number">10</span> <span class="cm-operator">&gt;</span> <span class="cm-number">50</span></pre>
<p><a class="p_ident" id="p_EWJu4coIAh" href="./01_values.html#p_EWJu4coIAh"></a>Последният логически оператор не е унарен, не е бинарен, а тринарен, работещ с три стойности. Той се изписва с въпросителен знак и две точки ( ? :)</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_S1KcGPZ6au" href="./01_values.html#c_S1KcGPZ6au"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-atom">true</span> <span class="cm-operator">?</span> <span class="cm-number">1</span> : <span class="cm-number">2</span>);
<span class="cm-comment">// → 1</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-atom">false</span> <span class="cm-operator">?</span> <span class="cm-number">1</span> : <span class="cm-number">2</span>);
<span class="cm-comment">// → 2</span></pre>
<p><a class="p_ident" id="p_MQqkekcjA2" href="./01_values.html#p_MQqkekcjA2"></a>Той се нарича условен оператор ( или понякога трикомпонентен оператор, тъй  като той е единствения такъв оператор в езика). Стойността в ляво от въпросителния знак е “избор” коя от другите две стойности да изкара. Когато е <em>true</em> се избира първата стойност след въпросителния знак, когато е <em>false</em> се избира стойността от дясно на двете точки.</p>
<h2><a class="h_ident" id="h_WAVjYN+DYj" href="./01_values.html#h_WAVjYN+DYj"></a>Undefined  стойности</h2>
<p><a class="p_ident" id="p_Q/OIPtr8xY" href="./01_values.html#p_Q/OIPtr8xY"></a>Има две специални стойности, <code>null</code> и <code>undefined</code>, които се използват за означаване на липсата на смислена стойност. Те самите са стойности, но не носят информация.</p>
<p><a class="p_ident" id="p_HKYk2Oxaf6" href="./01_values.html#p_HKYk2Oxaf6"></a>Много операции в езика, които не произвеждат смислена стойност (ще видите някои по-късно) дават <code>undefined</code> просто защото те трябва да получат някаква стойност.</p>
<p><a class="p_ident" id="p_vNLaRBSip6" href="./01_values.html#p_vNLaRBSip6"></a>Разликата в значението между <code>undefined</code> и <code>null</code> е инцидент в дизайна на JavaScript, но това няма значение в по-голямата част от времето. В случаите, когато трябва да се занимавате с тези стойности, аз препоръчвам да ги третирате, като взаимозаменяеми (повече за това след малко).</p>
<h2><a class="h_ident" id="h_AY+YGu6qyM" href="./01_values.html#h_AY+YGu6qyM"></a>Автоматично  преобразуване  на  типа</h2>
<p><a class="p_ident" id="p_ZUS5EPFCx3" href="./01_values.html#p_ZUS5EPFCx3"></a>В увода споменах, че JavaScript излиза от пътя си, за да приеме почти всяка програма, дори и програми, които правят странни неща. Това е добре демонстрирано в следните изрази:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_le/xDT5s3y" href="./01_values.html#c_le/xDT5s3y"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-number">8</span> <span class="cm-operator">*</span> <span class="cm-atom">null</span>)
<span class="cm-comment">// → 0</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"5"</span> <span class="cm-operator">-</span> <span class="cm-number">1</span>)
<span class="cm-comment">// → 4</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"5"</span> <span class="cm-operator">+</span> <span class="cm-number">1</span>)
<span class="cm-comment">// → 51</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"five"</span> <span class="cm-operator">*</span> <span class="cm-number">2</span>)
<span class="cm-comment">// → NaN</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-atom">false</span> <span class="cm-operator">==</span> <span class="cm-number">0</span>)
<span class="cm-comment">// → true</span></pre>
<p><a class="p_ident" id="p_kjH0rNN5jK" href="./01_values.html#p_kjH0rNN5jK"></a>Когато се прилага оператор за “неправилен” вид стойност, JavaScript тихо ще конвертира тази стойност до типа, който иска с помощта на набор от правила, които често не са това, което искаме или очаква ме. Това се нарича корекция на тип. Така че <code>null</code> в първия израз  става <code>0</code>, а <code>"5"</code> във втория става <code>5</code> от <em>string</em> в число. И все пак в третия израз, <code>+</code> опитва да конкатенира числото към <em>string</em>, така че <code>1</code> се превръща в <code>"1"</code> (от число в <em>string</em>).</p>
<p><a class="p_ident" id="p_mw5To5JJ6Q" href="./01_values.html#p_mw5To5JJ6Q"></a>Когато нещо не се вписва в картата на номерата по очевиден начин (като <code>"five"</code> или <code>undefined</code>) се преобразува в номер и се произвежда <code>NaN</code>. Други аритметични операции върху <code>NaN</code> пазят резултата <code>NaN</code>, така че ако откриете един от тези изрази на неочаквано място, погледнете за случайно конвертиране на типа.</p>
<p><a class="p_ident" id="p_2V6JygcBXy" href="./01_values.html#p_2V6JygcBXy"></a>При сравняване на стойности от един и същи тип с използване на <code>==</code>, резултатът е лесно предвидим: трябва да получите вярно, когато и двете стойности са едни и същи, с изключение на случаите с <code>NaN</code>. Но когато типовете се различават, JavaScript използва сложни и объркващи набори от правила, за да реши, какво да прави. В повечето случаи просто се опитва да конвертира една от стойностите в типа на другата стойност. Въпреки това, когато <code>null</code> или <code>undefined</code> са от двете страни на оператора, той произвежда вярно само ако и двете стани са от един и същи тип <code>null</code> или <code>undefined</code>.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_OhN7QQZzYz" href="./01_values.html#c_OhN7QQZzYz"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-atom">null</span> <span class="cm-operator">==</span> <span class="cm-atom">undefined</span>);
<span class="cm-comment">// → true</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-atom">null</span> <span class="cm-operator">==</span> <span class="cm-number">0</span>);
<span class="cm-comment">// → false</span></pre>
<p><a class="p_ident" id="p_MzUL8LaoQ2" href="./01_values.html#p_MzUL8LaoQ2"></a>Поведението в последния код често е полезно. Когато искате да проверите дали дадена стойност е реална, вместо <code>null</code> или <code>undefined</code>, може просто да се сравни <code>null</code> с <code>==</code> (или <code>!=</code> оператора.</p>
<p><a class="p_ident" id="p_N4OuWeYOwF" href="./01_values.html#p_N4OuWeYOwF"></a>Но какво ще стане ако искате да тествате нещо, което се отнася до точната стойност <code>false</code>? Правилата за преобразуване на <em>string</em> и числа до Булеви стойности посочват, че <code>0</code>, <code>NaN</code>, и празен <em>string</em> (<code>""</code>) се отчитат като <code>false</code>, всички останали стойности като <code>true</code>. Поради това, изрази като <code>0 == false</code> и <code>"" == false</code> са <em>true</em>. За случаи, като този, когато не искате автоматично конвертиране на типа, има два допълнителни оператора: <code>===</code> и <code>!==</code>. Първият тества дали дадена стойност е точно равна на другата стойност, а другия дали е точно различна. Така <code>"" === false</code>, както се очаква.</p>
<p><a class="p_ident" id="p_S/opLpHJcU" href="./01_values.html#p_S/opLpHJcU"></a>Аз препоръчвам използването на три знаковите оператори за сравнение, като защита от предотвратяване на нежелано конвертиране на типа. Но ако сте сигурни, че типовете от двете страни ще бъдат еднакви, няма проблем да използвате по-късите оператори.</p>
<h3><a class="h_ident" id="h_3jN0iK4yKW" href="./01_values.html#h_3jN0iK4yKW"></a>Късо  съединение  на  логическите  оператори</h3>
<p><a class="p_ident" id="p_CFbagJsQYK" href="./01_values.html#p_CFbagJsQYK"></a>Логическите оператори <code>&amp;&amp;</code> и <code>||</code> поддържат стойностите на различните типове по един особен начин. Те ще конвертират стойността от лявата им страна в Булев тип, докато реши какво да прави, но в зависимост от оператора и резултата от това конвертиране, връщатат първоначалната стойност на лявата или дясната страна.</p>
<p><a class="p_ident" id="p_BFq+/JeBH9" href="./01_values.html#p_BFq+/JeBH9"></a>Оператора <code>||</code>, например ще върне, като резултат стойността на лявата страна, когато може да я конвертира до <em>true</em>, и ако не може ще върне като резултат дясната страна, ако тя е вярна. Това конвертиране работи, както се очаква за Булеви стойности и трябва да се направи нещо за стойности от другите типове..</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_ME/mwf+CCF" href="./01_values.html#c_ME/mwf+CCF"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-atom">null</span> <span class="cm-operator">||</span> <span class="cm-string">"user"</span>)
<span class="cm-comment">// → user</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"Karl"</span> <span class="cm-operator">||</span> <span class="cm-string">"user"</span>)
<span class="cm-comment">// → Karl</span></pre>
<p><a class="p_ident" id="p_GtKVVao8+3" href="./01_values.html#p_GtKVVao8+3"></a>Тази функционалност на <code>||</code> позволява на оператора да се използва, като начин да върне обратно стойността по подразбиране. Ако дадем израз, който произвежда празна стойност от ляво, стойността от дясно ще се използва, като заместител в този случай.</p>
<p><a class="p_ident" id="p_LlkwKHpB6u" href="./01_values.html#p_LlkwKHpB6u"></a>Оператора <code>&amp;&amp;</code> работи по подобен начин, но малко по-различно. Когато стойността от ляво е нещо, което се конвертира до <em>false</em>, той връща, като резултат тази стойност в противен случай връща стойността от дясно.</p>
<p><a class="p_ident" id="p_IW4V8ztNjs" href="./01_values.html#p_IW4V8ztNjs"></a>Друго важно свойство на тези два оператора е, че проверяват дясната страна, само ако е необходимо. В случай на <code>true || X</code> без значение какво е <code>X</code> дори да е израз, който прави нещо ужасно, резултата ще бъде верен и <code>X</code> никога не се проверява. Същото важи и за <code>false &amp;&amp; X</code>, който е неверен и ще игнорира <code>X</code>. Това се нарича проверка на късо съединение.</em>.</p>
<p><a class="p_ident" id="p_S9XylKoY/U" href="./01_values.html#p_S9XylKoY/U"></a>Условния оператор работи по подобен начин. Първият израз винаги се проверява, но втората или третата стойност не..</p>
<h2><a class="h_ident" id="h_ErccPg/l98" href="./01_values.html#h_ErccPg/l98"></a>Резюме</h2>
<p><a class="p_ident" id="p_K8XmHEfEpW" href="./01_values.html#p_K8XmHEfEpW"></a>Разгледахме четири вида стойности на JavaScript в настоящата глава: <em> numbers, strings, Booleans,</em> и <em>undefined values</em>.</p>
<p><a class="p_ident" id="p_3rwX3Mq/e/" href="./01_values.html#p_3rwX3Mq/e/"></a>Тези стойности се създават, чрез въвеждане на тяхното име <code>true</code>, <code>null</code> <code>13</code>, или <code>"abc"</code>. Можете да комбинирате и трансформирате стойностите с операторите. Видяхме бинарните оператори за аритметика (<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> и <code>%</code>), за конкатинация на <em>string</em> (<code>+</code>), за сравнение (<code>==</code>, <code>!=</code>, <code>===</code>, <code>!==</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>), за логика (<code>&amp;&amp;</code>, <code>||</code>), както и няколко унарни оператора (<code>-</code>) за изваждане, (<code>!</code>) за логическо отрицание и (<code>typeof</code>) за определяне на типа на стойността. И трикомпонентния оператор (<code>?:</code>) за избиране на една от две стойности въз основа на трета стойност.</p>
<p><a class="p_ident" id="p_WHkzsJyNsJ" href="./01_values.html#p_WHkzsJyNsJ"></a>Това ви дава достатъчно информация да използвате JavaScript, като джобен калкулатор, но не повече. В 
<a href="./02_program_structure.html#program_structure">следващата глава</a> ще започнете да обвързвате тези изрази в основи на програми.</p>
<nav>
  <a href="./00_intro.html" title="previous chapter">◀</a>
  <a href="./index.html" title="cover">◆</a>
  <a href="./02_program_structure.html" title="next chapter">▶</a>
</nav>
</article>
</body></html>