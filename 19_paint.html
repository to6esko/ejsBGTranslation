<!DOCTYPE html>
<!-- saved from url=(0043)./19_paint.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <title>Project: A Paint Program :: Eloquent JavaScript</title>
  <link rel="stylesheet" href="./media/codemirror.css">
  <script src="./media/acorn_codemirror.js"></script>
  <link rel="stylesheet" href="./media/ejs.css">
  <script src="./media/sandbox.js"></script>
  <script src="./media/ejs.js"></script>
  <script>var chapNum = 19;var sandboxLoadFiles = ["code/chapter/19_paint.js"];</script>
</head>

<body><article>
<nav>
  <a href="./18_forms.html" title="previous chapter">◀</a>
  <a href="./index.html" title="cover">◆</a>
  <a href="./20_node.html" title="next chapter">▶</a>
</nav>

<h1><div class="chap_num">Глава 19</div>Проект: програма за рисуване</h1>
<blockquote>
<p><a class="p_ident" id="p_YcWG8HTlFz" href="./19_paint.html#p_YcWG8HTlFz"></a>Виждам много цветове пред мен. Гледам своето бяло платно. След това се опитвам да прилагам цветовете, също както думите оформят поеми, също както нотите оформят музика.”</p>
 <footer>Joan Miro</footer>
</blockquote>
<p><a class="p_ident" id="p_4VGZtxD2xS" href="./19_paint.html#p_4VGZtxD2xS"></a>Материалът от предишната глава дава всички елементи, които ни трябват за да се изгради просто уеб приложение. В тази глава ние ще направим точно това.</p>
<p><a class="p_ident" id="p_1emWaHj7VO" href="./19_paint.html#p_1emWaHj7VO"></a>Нашето приложение ще бъде уеб-базирана програма за рисуване, по подобие на Microsoft Paint. Можете да го използвате за да отворите файлове с изображения и освен това да рисувате върху тях с мишката. Ето как ще изглежда: </p>
<div class="image">
  <img src="./media/paint.png" alt="A simple paint program">
</div>
<p><a class="p_ident" id="p_oDwL9FxPW8" href="./19_paint.html#p_oDwL9FxPW8"></a>Рисуването върху компютър е велико. Не е нужно да се притесняваме за материали, умения или талант. Можем да направим цапаница.</p>
<h2><a class="h_ident" id="h_h4HWFf13vp" href="./19_paint.html#h_h4HWFf13vp"></a>Изпълнение</h2>
<p><a class="p_ident" id="p_JoMqYLSjLp" href="./19_paint.html#p_JoMqYLSjLp"></a>Интерфейса за програмата за рисуване, показва голям <code>&lt;canvas&gt;</code> елемент с голям брой полета на форми под него. Потребителя рисува върху картината, като избира един инструмент от <code>&lt;select&gt;</code> полето и след това щракне или плъзне върху платното. Има инструменти за рисуване на лини, за изтриване на части от картината, добавяне на текст и т. н.</p>
<p><a class="p_ident" id="p_f2FunmZ+W/" href="./19_paint.html#p_f2FunmZ+W/"></a>Кликването върху платното ще оставим в ръцете на <code>"mousedown"</code> събитието за текущо избрания инструмент, който може да се обработва в зависимост от това, кой начин ще изберем. Рисуващият линия инструмент, например, ще се ослушва за <code>"mousemove"</code> събитие, докато бутона на мишката е свободен и ще чертае линии по пътя на мишката използвайки текущия цвят и размер на четка.</p>
<p><a class="p_ident" id="p_SidGjlM9I+" href="./19_paint.html#p_SidGjlM9I+"></a>Цвета и размера на четката се избират с допълнителни полета на формуляра. Те са закачени в контекста на <code>fillStyle</code>, <code>strokeStyle</code> и <code>lineWidth</code>, които актуализират платното за рисуване, винаги, когато те се променят.</p>
<p><a class="p_ident" id="p_ARTBoP4NDe" href="./19_paint.html#p_ARTBoP4NDe"></a>Можете да заредите изображение в програмата по два начина. Първият използва поле на файл, където потребителя може да избере файл от своята файлова система. Вторият пита за URL и ще донесе изображение от уеб.</p>
<p><a class="p_ident" id="p_7b82pMSl8A" href="./19_paint.html#p_7b82pMSl8A"></a>Изображенията се запазват по-малко по-нетипичен начин, с линк Save долу в дясно на текущото изображение. Те може да се следват, споделят и запазват. Ще обясня, как става това по-късно.</p>
<h2><a class="h_ident" id="h_9CGBdyKskt" href="./19_paint.html#h_9CGBdyKskt"></a>Изграждане  на  DOM</h2>
<p><a class="p_ident" id="p_sqg53vjc6x" href="./19_paint.html#p_sqg53vjc6x"></a>Интерфейса на нашата програма е изграден с повече от 30 DOM елемента. Това трябва да се изгради по някакъв начин.</p>
<p><a class="p_ident" id="p_BwXcOEgv2v" href="./19_paint.html#p_BwXcOEgv2v"></a>HTML е най-очевидният формат за дефиниране на сложни структури на DOM. Но разделянето на програмата на парчета от HTML и скрипт е затруднено от факта, че много от DOM елементите се нуждаят обработка на събитие или да бъдат манипулирани от скрипта по някакъв друг начин. По този начин, на нашия скрипт ще се налижи да прави много <code>querySelector</code> (или подобни) за да намира и призовава DOM елементите, от които има нужда за да работи.</p>
<p><a class="p_ident" id="p_hwJVTRpgY3" href="./19_paint.html#p_hwJVTRpgY3"></a>Би било хубаво, ако структурата на DOM за всяка част от нашия интерфейс е дефиниран в близост до кода на JavaScript, който да го управлява. Поради тази причина, аз избрах да направя всичко по създаването на DOM разклонения вътре в JavaScript. Както видяхме в <a href="./13_dom.html#standard">Глава 13</a>, вградения интерфейс за изграждане на структура на DOM е ужасно многословен. Ако ще правим много голяма структура на DOM се нуждаем от помощна функция.</p>
<p><a class="p_ident" id="p_7sINQE+0xU" href="./19_paint.html#p_7sINQE+0xU"></a>Тази помощна функция е разширена версия на <code>elt</code> function from <a href="./13_dom.html#elt">Chapter 13</a>. Тя създава един елемент давайки му име и атрибути  и му добавя всички допълнителни аргументи, които той получава, като разклонения на деца, автоматично конвертиране на <em>strings</em> в текст разклонения. </p>
<pre data-language="javascript" class="snippet cm-s-default" data-sandbox="paint"><a class="c_ident" id="c_adN9+1mjk9" href="./19_paint.html#c_adN9+1mjk9"></a><span class="cm-keyword">function</span> <span class="cm-variable">elt</span>(<span class="cm-def">name</span>, <span class="cm-def">attributes</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">node</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">createElement</span>(<span class="cm-variable-2">name</span>);
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">attributes</span>) {
    <span class="cm-keyword">for</span> (<span class="cm-keyword">var</span> <span class="cm-def">attr</span> <span class="cm-keyword">in</span> <span class="cm-variable-2">attributes</span>)
      <span class="cm-keyword">if</span> (<span class="cm-variable-2">attributes</span>.<span class="cm-property">hasOwnProperty</span>(<span class="cm-variable-2">attr</span>))
        <span class="cm-variable-2">node</span>.<span class="cm-property">setAttribute</span>(<span class="cm-variable-2">attr</span>, <span class="cm-variable-2">attributes</span>[<span class="cm-variable-2">attr</span>]);
  }
  <span class="cm-keyword">for</span> (<span class="cm-keyword">var</span> <span class="cm-def">i</span> <span class="cm-operator">=</span> <span class="cm-number">2</span>; <span class="cm-variable-2">i</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">arguments</span>.<span class="cm-property">length</span>; <span class="cm-variable-2">i</span><span class="cm-operator">++</span>) {
    <span class="cm-keyword">var</span> <span class="cm-def">child</span> <span class="cm-operator">=</span> <span class="cm-variable-2">arguments</span>[<span class="cm-variable-2">i</span>];
    <span class="cm-keyword">if</span> (<span class="cm-keyword">typeof</span> <span class="cm-variable-2">child</span> <span class="cm-operator">==</span> <span class="cm-string">"string"</span>)
      <span class="cm-variable-2">child</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">createTextNode</span>(<span class="cm-variable-2">child</span>);
    <span class="cm-variable-2">node</span>.<span class="cm-property">appendChild</span>(<span class="cm-variable-2">child</span>);
  }
  <span class="cm-keyword">return</span> <span class="cm-variable-2">node</span>;
}</pre>
<p><a class="p_ident" id="p_ulZXM8Og9d" href="./19_paint.html#p_ulZXM8Og9d"></a>Това ни позволява да създаваме елементи лесно, без да прави нашия изходен код дълъг и скучен, като договор на корпорация с краен потребител.</p>
<h2><a class="h_ident" id="h_feJq2F1dmk" href="./19_paint.html#h_feJq2F1dmk"></a>Фондацията</h2>
<p><a class="p_ident" id="p_fc9fUQEVHE" href="./19_paint.html#p_fc9fUQEVHE"></a>В основата на нашата програма е <code>createPaint</code> функцията, която добавя интерфейс за рисуване на DOM елементите дадена, като аргумент. Понеже искаме да изградим нашата програма  парче по парче, ние определяме един обект, наречен <code>controls</code>, който ще съдържа функции за инициализиране на различните видове управления под изображението.</p>
<pre data-language="javascript" class="snippet cm-s-default" data-sandbox="paint"><a class="c_ident" id="c_8HViSwekFi" href="./19_paint.html#c_8HViSwekFi"></a><span class="cm-keyword">var</span> <span class="cm-variable">controls</span> <span class="cm-operator">=</span> <span class="cm-variable">Object</span>.<span class="cm-property">create</span>(<span class="cm-atom">null</span>);

<span class="cm-keyword">function</span> <span class="cm-variable">createPaint</span>(<span class="cm-def">parent</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">canvas</span> <span class="cm-operator">=</span> <span class="cm-variable">elt</span>(<span class="cm-string">"canvas"</span>, {<span class="cm-property">width</span>: <span class="cm-number">500</span>, <span class="cm-property">height</span>: <span class="cm-number">300</span>});
  <span class="cm-keyword">var</span> <span class="cm-def">cx</span> <span class="cm-operator">=</span> <span class="cm-variable-2">canvas</span>.<span class="cm-property">getContext</span>(<span class="cm-string">"2d"</span>);
  <span class="cm-keyword">var</span> <span class="cm-def">toolbar</span> <span class="cm-operator">=</span> <span class="cm-variable">elt</span>(<span class="cm-string">"div"</span>, {<span class="cm-property">class</span>: <span class="cm-string">"toolbar"</span>});
  <span class="cm-keyword">for</span> (<span class="cm-keyword">var</span> <span class="cm-def">name</span> <span class="cm-keyword">in</span> <span class="cm-variable">controls</span>)
    <span class="cm-variable-2">toolbar</span>.<span class="cm-property">appendChild</span>(<span class="cm-variable">controls</span>[<span class="cm-variable-2">name</span>](<span class="cm-variable-2">cx</span>));

  <span class="cm-keyword">var</span> <span class="cm-def">panel</span> <span class="cm-operator">=</span> <span class="cm-variable">elt</span>(<span class="cm-string">"div"</span>, {<span class="cm-property">class</span>: <span class="cm-string">"picturepanel"</span>}, <span class="cm-variable-2">canvas</span>);
  <span class="cm-variable-2">parent</span>.<span class="cm-property">appendChild</span>(<span class="cm-variable">elt</span>(<span class="cm-string">"div"</span>, <span class="cm-atom">null</span>, <span class="cm-variable-2">panel</span>, <span class="cm-variable-2">toolbar</span>));
}</pre>
<p><a class="p_ident" id="p_vEXvH0x+Tb" href="./19_paint.html#p_vEXvH0x+Tb"></a>Всяко управление има достъп до контекста на платното за рисуване и чрез този контекст - <code>canvas</code> свойство, до самия <code>&lt;canvas&gt;</code> елемент. По-голямата част от програмата живее в този <em>canvas</em> - той съдържа текущата картина, както избрания цвят (в <code>fillStyle</code> свойство) и размера на четката (в <code>lineWidth</code> свойство).</p>
<p><a class="p_ident" id="p_p0cg1HO335" href="./19_paint.html#p_p0cg1HO335"></a>Ние ще увием платното и управлението в <code>&lt;div&gt;</code> елементи с класове, така че да можем да добавим малко стил, като сива рамка около картината.</p>
<h2><a class="h_ident" id="h_dgOsN5kwO8" href="./19_paint.html#h_dgOsN5kwO8"></a>Избор  на  инструменти</h2>
<p><a class="p_ident" id="p_g0nRLu/Vl9" href="./19_paint.html#p_g0nRLu/Vl9"></a>На първото управление добавяме <code>&lt;select&gt;</code> елемент, който позволява на потребителя да вземе инструмент за рисуване. Както с <code>controls</code> ние ще използваме  обект за събиране на различни инструменти, така че няма да ги кодираме на едно място, а ще добавим повечето инструменти по-късно. Този обект свързва имената на инструментите с функция, която трябва да се извика, когато те се избират и платното е кликнато.</p>
<pre data-language="javascript" class="snippet cm-s-default" data-sandbox="paint"><a class="c_ident" id="c_6ReIFCisw3" href="./19_paint.html#c_6ReIFCisw3"></a><span class="cm-keyword">var</span> <span class="cm-variable">tools</span> <span class="cm-operator">=</span> <span class="cm-variable">Object</span>.<span class="cm-property">create</span>(<span class="cm-atom">null</span>);

<span class="cm-variable">controls</span>.<span class="cm-property">tool</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">cx</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">select</span> <span class="cm-operator">=</span> <span class="cm-variable">elt</span>(<span class="cm-string">"select"</span>);
  <span class="cm-keyword">for</span> (<span class="cm-keyword">var</span> <span class="cm-def">name</span> <span class="cm-keyword">in</span> <span class="cm-variable">tools</span>)
    <span class="cm-variable-2">select</span>.<span class="cm-property">appendChild</span>(<span class="cm-variable">elt</span>(<span class="cm-string">"option"</span>, <span class="cm-atom">null</span>, <span class="cm-variable-2">name</span>));

  <span class="cm-variable-2">cx</span>.<span class="cm-property">canvas</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">"mousedown"</span>, <span class="cm-keyword">function</span>(<span class="cm-def">event</span>) {
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">event</span>.<span class="cm-property">which</span> <span class="cm-operator">==</span> <span class="cm-number">1</span>) {
      <span class="cm-variable">tools</span>[<span class="cm-variable-2">select</span>.<span class="cm-property">value</span>](<span class="cm-variable-2">event</span>, <span class="cm-variable-2">cx</span>);
      <span class="cm-variable-2">event</span>.<span class="cm-property">preventDefault</span>();
    }
  });

  <span class="cm-keyword">return</span> <span class="cm-variable">elt</span>(<span class="cm-string">"span"</span>, <span class="cm-atom">null</span>, <span class="cm-string">"Tool: "</span>, <span class="cm-variable-2">select</span>);
};</pre>
<p><a class="p_ident" id="p_8di1zX3Jlb" href="./19_paint.html#p_8di1zX3Jlb"></a>Полето с инструментите е населено с <code>&lt;option&gt;</code> елементи за всички инструменти, които са определени и манипулатора <code>"mousedown"</code> на елемента на платното се грижи за извикване на функцията за текущия инструмент, подавайки и обекта на събитието и контекста на рисуването, като аргументи. Тя също извиква 
<code>preventDefault</code>, така че задържането на бутона на мишката и влаченето не кара браузъра да избира части от страницата.</p>
<p><a class="p_ident" id="p_C/kPVzLbL1" href="./19_paint.html#p_C/kPVzLbL1"></a>Най-основния инструмент е за линия, който позволява на потребителя да чертае линии с мишката. За да накараме линията да свършва на правилното място, ние трябва да сме в състояние да намерим относителните координати на платното, където дадено събитие съответства на мишката. Метода <code>getBoundingClientRect</code> на кратко споменат в <a href="./13_dom.html#boundingRect">Глава 13</a>, може да ни помогне тука. Той ни казва къде е показан елемент спрямо горния ляв ъгъл на екрана. Свойствата <code>clientX</code> и <code>clientY</code> на мишката също са свързани с този ъгъл, така че можем да извадим горния ляв ъгъл на платното от тях за да получим позиция по отношение на този ъгъл.</p>
<pre data-language="javascript" class="snippet cm-s-default" data-sandbox="paint"><a class="c_ident" id="c_y+L1e9IlNG" href="./19_paint.html#c_y+L1e9IlNG"></a><span class="cm-keyword">function</span> <span class="cm-variable">relativePos</span>(<span class="cm-def">event</span>, <span class="cm-def">element</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">rect</span> <span class="cm-operator">=</span> <span class="cm-variable-2">element</span>.<span class="cm-property">getBoundingClientRect</span>();
  <span class="cm-keyword">return</span> {<span class="cm-property">x</span>: <span class="cm-variable">Math</span>.<span class="cm-property">floor</span>(<span class="cm-variable-2">event</span>.<span class="cm-property">clientX</span> <span class="cm-operator">-</span> <span class="cm-variable-2">rect</span>.<span class="cm-property">left</span>),
          <span class="cm-property">y</span>: <span class="cm-variable">Math</span>.<span class="cm-property">floor</span>(<span class="cm-variable-2">event</span>.<span class="cm-property">clientY</span> <span class="cm-operator">-</span> <span class="cm-variable-2">rect</span>.<span class="cm-property">top</span>)};
}</pre>
<p><a class="p_ident" id="p_GsfGlWhhEu" href="./19_paint.html#p_GsfGlWhhEu"></a>Няколко от инструментите за рисуване трябва да се ослушват за <code>"mousemove"</code> събития, докато бутона на мишката е задържан натиснат. Функцията <code>trackDrag</code> се грижи за регистрирането и отрегистрирането на такива ситуации.</p>
<pre data-language="javascript" class="snippet cm-s-default" data-sandbox="paint"><a class="c_ident" id="c_bAQGH1X5W9" href="./19_paint.html#c_bAQGH1X5W9"></a><span class="cm-keyword">function</span> <span class="cm-variable">trackDrag</span>(<span class="cm-def">onMove</span>, <span class="cm-def">onEnd</span>) {
  <span class="cm-keyword">function</span> <span class="cm-def">end</span>(<span class="cm-def">event</span>) {
    <span class="cm-variable">removeEventListener</span>(<span class="cm-string">"mousemove"</span>, <span class="cm-variable-2">onMove</span>);
    <span class="cm-variable">removeEventListener</span>(<span class="cm-string">"mouseup"</span>, <span class="cm-variable-2">end</span>);
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">onEnd</span>)
      <span class="cm-variable-2">onEnd</span>(<span class="cm-variable-2">event</span>);
  }
  <span class="cm-variable">addEventListener</span>(<span class="cm-string">"mousemove"</span>, <span class="cm-variable-2">onMove</span>);
  <span class="cm-variable">addEventListener</span>(<span class="cm-string">"mouseup"</span>, <span class="cm-variable-2">end</span>);
}</pre>
<p><a class="p_ident" id="p_wDVSXmBYxk" href="./19_paint.html#p_wDVSXmBYxk"></a>Тази функция взема два аргумента. Единия е функция, която се извиква за всяко <code>"mousemove"</code> събитие, а другия е функция, която се извиква, когато бутона на мишката е свободен. Всеки от тези  аргументи  може да се пропусне ако е необходимо.</p>
<p><a class="p_ident" id="p_QF1cI/MERi" href="./19_paint.html#p_QF1cI/MERi"></a>Инструментът за линията използва тези два помощника да правят действителния чертеж.</p>
<pre data-language="javascript" class="snippet cm-s-default" data-sandbox="paint"><a class="c_ident" id="c_zQjCDnLrcv" href="./19_paint.html#c_zQjCDnLrcv"></a><span class="cm-variable">tools</span>.<span class="cm-property">Line</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">event</span>, <span class="cm-def">cx</span>, <span class="cm-def">onEnd</span>) {
  <span class="cm-variable-2">cx</span>.<span class="cm-property">lineCap</span> <span class="cm-operator">=</span> <span class="cm-string">"round"</span>;

  <span class="cm-keyword">var</span> <span class="cm-def">pos</span> <span class="cm-operator">=</span> <span class="cm-variable">relativePos</span>(<span class="cm-variable-2">event</span>, <span class="cm-variable-2">cx</span>.<span class="cm-property">canvas</span>);
  <span class="cm-variable">trackDrag</span>(<span class="cm-keyword">function</span>(<span class="cm-def">event</span>) {
    <span class="cm-variable-2">cx</span>.<span class="cm-property">beginPath</span>();
    <span class="cm-variable-2">cx</span>.<span class="cm-property">moveTo</span>(<span class="cm-variable-2">pos</span>.<span class="cm-property">x</span>, <span class="cm-variable-2">pos</span>.<span class="cm-property">y</span>);
    <span class="cm-variable-2">pos</span> <span class="cm-operator">=</span> <span class="cm-variable">relativePos</span>(<span class="cm-variable-2">event</span>, <span class="cm-variable-2">cx</span>.<span class="cm-property">canvas</span>);
    <span class="cm-variable-2">cx</span>.<span class="cm-property">lineTo</span>(<span class="cm-variable-2">pos</span>.<span class="cm-property">x</span>, <span class="cm-variable-2">pos</span>.<span class="cm-property">y</span>);
    <span class="cm-variable-2">cx</span>.<span class="cm-property">stroke</span>();
  }, <span class="cm-variable-2">onEnd</span>);
};</pre>
<p><a class="p_ident" id="p_WgxKzx/dih" href="./19_paint.html#p_WgxKzx/dih"></a>Функцията започва с определяне на контекста на чертежа със свойството <code>lineCap</code> на <code>"round"</code>, което причинява двата края на очертанията на пътя да са заоблени, а не с квадратна форма по подразбиране. Това е трик за да се уверим, че множеството отделни линии изготвени в отговор на отделни събития, изглеждат, като една съгласувана линия. При по-големи широки линии, вие ще видите пропуски в ъглите, ако използвате обикновени линии по подразбиране.</p>
<p><a class="p_ident" id="p_AQy4O9XOrj" href="./19_paint.html#p_AQy4O9XOrj"></a>После за всяко <code>"mousemove"</code> събитие, което се случва докато бутона на мишката е натиснат, се чертае отсечка прекарана между старата и новата позиция на мишката, като се използва някой от определените в момента случаи, като <code>strokeStyle</code> или <code>lineWidth</code>.</p>
<p><a class="p_ident" id="p_LdZL7msldK" href="./19_paint.html#p_LdZL7msldK"></a><code>onEnd</code> аргумента на <code>tools.Line</code> просто минава през <code>trackDrag</code>. Нормалният начин за пускане на инструмент не изисква подаване на трети аргумент, за това при използването на инструмента за линия, този аргумент ще доведе до 
<code>undefined</code> и нищо няма да се случи в края на драгването на мишката. Аргумента е там за да ни позволи  прилагането на функцията за изтриване на върха на инструмента за линия с много малко допълнителен код.</p>
<pre data-language="javascript" class="snippet cm-s-default" data-sandbox="paint"><a class="c_ident" id="c_A8FTE3sfhc" href="./19_paint.html#c_A8FTE3sfhc"></a><span class="cm-variable">tools</span>.<span class="cm-property">Erase</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">event</span>, <span class="cm-def">cx</span>) {
  <span class="cm-variable-2">cx</span>.<span class="cm-property">globalCompositeOperation</span> <span class="cm-operator">=</span> <span class="cm-string">"destination-out"</span>;
  <span class="cm-variable">tools</span>.<span class="cm-property">Line</span>(<span class="cm-variable-2">event</span>, <span class="cm-variable-2">cx</span>, <span class="cm-keyword">function</span>() {
    <span class="cm-variable-2">cx</span>.<span class="cm-property">globalCompositeOperation</span> <span class="cm-operator">=</span> <span class="cm-string">"source-over"</span>;
  });
};</pre>
<p><a class="p_ident" id="p_0Apcf0lbn3" href="./19_paint.html#p_0Apcf0lbn3"></a>Свойството <code>globalCompositeOperation</code> влияе на начина на операциите за рисуване върху платното, като променя цвета на пикселите, които се допират. По подразбиране стойността на свойството е <code>"source-over"</code>, което означава, че рисуваният цвят е насложен върху съществуващия цвят на това място. Ако цвета е непрозрачен, той просто ще замени стария цвят, но ако е полупрозрачен, двата цвята ще бъдат смесени.</p>
<p><a class="p_ident" id="p_+Ckjs7EFIj" href="./19_paint.html#p_+Ckjs7EFIj"></a>Инструмента за изтриване определя <code>globalCompositeOperation</code> да е <code>"destination-out"</code>, което има ефекта за изтриване на пикселите, които се допират, като ги прави прозрачни отново.</p>
<p><a class="p_ident" id="p_RRoUPpuAjO" href="./19_paint.html#p_RRoUPpuAjO"></a>Това ни дава два инструмента в нашата програма за рисуване. Можем да чертаем черни линии един пиксел широки (по подразбиране за <code>strokeStyle</code> и <code>lineWidth</code> върху платното) и да ги изтрием после. Това работи, макар и доста ограничено в програмата за рисуване.</p>
<h2><a class="h_ident" id="h_lIikGuI/QG" href="./19_paint.html#h_lIikGuI/QG"></a>Цвят  и  размер  на  четката</h2>
<p><a class="p_ident" id="p_STY3nzP377" href="./19_paint.html#p_STY3nzP377"></a>Ако потребителите искат да направят други цветове освен черно и да използват различни размери на четката, трябва да добавим управления за тези две настройки.</p>
<p><a class="p_ident" id="p_Iq68Mq2ClK" href="./19_paint.html#p_Iq68Mq2ClK"></a>В <a href="./18_forms.html#forms">Глава 18</a> обсъдихме различни полета на формуляри. Но оцветяване на полетата не бяха сред тях. Традиционно браузъра не разполага с вградена поддръжка за цветови колектори, но в последните няколко години редица типове полета на форми са стандартизирани. Един от тях е <code>&lt;input type="color"&gt;</code>, други са <code>"date"</code>, <code>"email"</code>, <code>"url"</code> и <code>"number"</code>. Не всички браузъри ги подкрепят все още - по време на писане, никаква версия на Internet Explorer не поддържа цветни полета. Типа по подразбиране на <code>&lt;input&gt;</code> тага е <code>"text"</code> и когато се използва неподдържан тип, браузъра ще го третира, като текстово поле. Това означава, че потребителите, които работят на Internet Explorer с нашата програма за рисуване, ще трябва да въвеждат името на цвета, който искат, а не да го избират от удобна джаджа.</p>
<pre data-language="javascript" class="snippet cm-s-default" data-sandbox="paint"><a class="c_ident" id="c_876pZkfMUC" href="./19_paint.html#c_876pZkfMUC"></a><span class="cm-variable">controls</span>.<span class="cm-property">color</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">cx</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">input</span> <span class="cm-operator">=</span> <span class="cm-variable">elt</span>(<span class="cm-string">"input"</span>, {<span class="cm-property">type</span>: <span class="cm-string">"color"</span>});
  <span class="cm-variable-2">input</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">"change"</span>, <span class="cm-keyword">function</span>() {
    <span class="cm-variable-2">cx</span>.<span class="cm-property">fillStyle</span> <span class="cm-operator">=</span> <span class="cm-variable-2">input</span>.<span class="cm-property">value</span>;
    <span class="cm-variable-2">cx</span>.<span class="cm-property">strokeStyle</span> <span class="cm-operator">=</span> <span class="cm-variable-2">input</span>.<span class="cm-property">value</span>;
  });
  <span class="cm-keyword">return</span> <span class="cm-variable">elt</span>(<span class="cm-string">"span"</span>, <span class="cm-atom">null</span>, <span class="cm-string">"Color: "</span>, <span class="cm-variable-2">input</span>);
};</pre>
<p><a class="p_ident" id="p_nNIuUTzgwz" href="./19_paint.html#p_nNIuUTzgwz"></a>Когато стойността на цвета на полето се промени, контекста на рисуване с <code>fillStyle</code> и <code>strokeStyle</code> се актуализира, за да подкрепи новата стойност.</p>
<p><a class="p_ident" id="p_C0Hqixv9pV" href="./19_paint.html#p_C0Hqixv9pV"></a>Полето за конфигуриране размера на четката работи по същия начин.</p>
<pre data-language="javascript" class="snippet cm-s-default" data-sandbox="paint"><a class="c_ident" id="c_cTEY1f58II" href="./19_paint.html#c_cTEY1f58II"></a><span class="cm-variable">controls</span>.<span class="cm-property">brushSize</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">cx</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">select</span> <span class="cm-operator">=</span> <span class="cm-variable">elt</span>(<span class="cm-string">"select"</span>);
  <span class="cm-keyword">var</span> <span class="cm-def">sizes</span> <span class="cm-operator">=</span> [<span class="cm-number">1</span>, <span class="cm-number">2</span>, <span class="cm-number">3</span>, <span class="cm-number">5</span>, <span class="cm-number">8</span>, <span class="cm-number">12</span>, <span class="cm-number">25</span>, <span class="cm-number">35</span>, <span class="cm-number">50</span>, <span class="cm-number">75</span>, <span class="cm-number">100</span>];
  <span class="cm-variable-2">sizes</span>.<span class="cm-property">forEach</span>(<span class="cm-keyword">function</span>(<span class="cm-def">size</span>) {
    <span class="cm-variable-2">select</span>.<span class="cm-property">appendChild</span>(<span class="cm-variable">elt</span>(<span class="cm-string">"option"</span>, {<span class="cm-property">value</span>: <span class="cm-variable-2">size</span>},
                           <span class="cm-variable-2">size</span> <span class="cm-operator">+</span> <span class="cm-string">" pixels"</span>));
  });
  <span class="cm-variable-2">select</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">"change"</span>, <span class="cm-keyword">function</span>() {
    <span class="cm-variable-2">cx</span>.<span class="cm-property">lineWidth</span> <span class="cm-operator">=</span> <span class="cm-variable-2">select</span>.<span class="cm-property">value</span>;
  });
  <span class="cm-keyword">return</span> <span class="cm-variable">elt</span>(<span class="cm-string">"span"</span>, <span class="cm-atom">null</span>, <span class="cm-string">"Brush size: "</span>, <span class="cm-variable-2">select</span>);
};</pre>
<p><a class="p_ident" id="p_qOGqGx5+Pr" href="./19_paint.html#p_qOGqGx5+Pr"></a>Кодът генерира възможности от масив с размери на четката и отново гарантира, че <code>lineWidth</code> на платното се актуализира, когато е избран размер на четката.</p>
<h2><a class="h_ident" id="h_NpxTTfNE7h" href="./19_paint.html#h_NpxTTfNE7h"></a>Запазването</h2>
<p><a class="p_ident" id="p_7TUivCYbPO" href="./19_paint.html#p_7TUivCYbPO"></a>За да се обясни изпълнението на линка Save, първо трябва да ви разкажа за URL адреса на данните. URL данните са  URL с информация, както протокол. За разлика от обикновените <em>http:</em> и <em>https:</em> URL адреси, URL адресите на данни не сочат ресурс, а по-скоро съдържат целия ресурс в тях. Това са URL данни, съдържащи един прост HTML документ:</p>
<pre>data:text/html,&lt;h1 style="color:red"&gt;Hello!&lt;/h1&gt;</pre>
<p><a class="p_ident" id="p_eWZrRGYvaj" href="./19_paint.html#p_eWZrRGYvaj"></a>URL адресите на данни са полезни за различни задачи, като включително малки изображения директно във файл стил. Те също така ни позволяват да се свържем към файловете, които създадохме от страна на клиента в браузъра, без да се налага първо да ги местим на някой сървър.</p>
<p><a class="p_ident" id="p_Wcu43CMIZj" href="./19_paint.html#p_Wcu43CMIZj"></a>Елементите на платното имат удобен метод, наречен <code>toDataURL</code> който ще върне URL данните, които съдържат снимка на платното, като графичен файл. Ние не искаме да актуализираме нашия линк Save всеки път, когато картината се променя, обаче. За големи картини, които включват преместване на доста данни в линка, ще бъде забележимо бавно. Вместо това ще настроим линка да актуализира своя <code>href</code> атрибут, когато е фокусиран с клавиатурата или мишката преместена върху него.</p>
<pre data-language="javascript" class="snippet cm-s-default" data-sandbox="paint"><a class="c_ident" id="c_azFCqdr7Bk" href="./19_paint.html#c_azFCqdr7Bk"></a><span class="cm-variable">controls</span>.<span class="cm-property">save</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">cx</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">link</span> <span class="cm-operator">=</span> <span class="cm-variable">elt</span>(<span class="cm-string">"a"</span>, {<span class="cm-property">href</span>: <span class="cm-string">"/"</span>}, <span class="cm-string">"Save"</span>);
  <span class="cm-keyword">function</span> <span class="cm-def">update</span>() {
    <span class="cm-keyword">try</span> {
      <span class="cm-variable-2">link</span>.<span class="cm-property">href</span> <span class="cm-operator">=</span> <span class="cm-variable-2">cx</span>.<span class="cm-property">canvas</span>.<span class="cm-property">toDataURL</span>();
    } <span class="cm-keyword">catch</span> (<span class="cm-def">e</span>) {
      <span class="cm-keyword">if</span> (<span class="cm-variable-2">e</span> <span class="cm-keyword">instanceof</span> <span class="cm-variable">SecurityError</span>)
        <span class="cm-variable-2">link</span>.<span class="cm-property">href</span> <span class="cm-operator">=</span> <span class="cm-string">"javascript:alert("</span> <span class="cm-operator">+</span>
          <span class="cm-variable">JSON</span>.<span class="cm-property">stringify</span>(<span class="cm-string">"Can't save: "</span> <span class="cm-operator">+</span> <span class="cm-variable-2">e</span>.<span class="cm-property">toString</span>()) <span class="cm-operator">+</span> <span class="cm-string">")"</span>;
      <span class="cm-keyword">else</span>
        <span class="cm-keyword">throw</span> <span class="cm-variable-2">e</span>;
    }
  }
  <span class="cm-variable-2">link</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">"mouseover"</span>, <span class="cm-variable-2">update</span>);
  <span class="cm-variable-2">link</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">"focus"</span>, <span class="cm-variable-2">update</span>);
  <span class="cm-keyword">return</span> <span class="cm-variable-2">link</span>;
};</pre>
<p><a class="p_ident" id="p_FK9LTdpkC3" href="./19_paint.html#p_FK9LTdpkC3"></a>По този начин връзката просто си седи тихо там, сочейки нешо погрешно, но когато потребителя я наближава се обновява до точка в настоящата картина.</p>
<p><a class="p_ident" id="p_fvaHWlCaUS" href="./19_paint.html#p_fvaHWlCaUS"></a>Ако заредим голям образ, някои браузъри ще се задавят с гигантския URL адрес на данни, който линка произвежда. За малки картини, този подход работи без проблем.</p>
<p><a class="p_ident" id="p_yj2JNpVbGr" href="./19_paint.html#p_yj2JNpVbGr"></a>Но тука отново се впускаме в тънкостите на тестовата среда на браузъра. Когато изображението е заредено от URL на друг домейн, ако отговора на сървъра не включва кауза, която да казва на браузъра, че ресурса може да се използва от друг домейн (виж <a href="./17_http.html#http_sandbox">Глава 17</a>), тогава платното ще може да съдържа информация, която потребителя може да вижда, но скрипта да не може.</p>
<p><a class="p_ident" id="p_P2fyJXYkeA" href="./19_paint.html#p_P2fyJXYkeA"></a>Ние може да поискаме изображение, което съдържа лични данни (на пример, графика на салдото от потребителска сметка) използвайки потребителската сесия. Ако скриптовете могат да получат информация от това изображение, те биха могли да се ровят в данните на потребителя по нежелателен начин.</p>
<p><a class="p_ident" id="p_OHFwilBG6F" href="./19_paint.html#p_OHFwilBG6F"></a>За да предотвратим този вид изтичане на информация, браузъра ще отбележи платното, като заразено, когато изображението, което скрипта не може да види се рисува върху него. Пиксел данни, включително URL адреси на данни не могат да бъдат извлечени от заразено платно. Можем да пишем върху него, но не можем да го прочетем.</p>
<p><a class="p_ident" id="p_40OvqfoZJr" href="./19_paint.html#p_40OvqfoZJr"></a>Ето защо се нуждаем от <code>try/catch</code> твърдение в <code>update</code> функцията за линка Save. Когато платното се превърне в заразено, извиквайки <code>toDataURL</code> ще повдигне изключение, като инстанция на <code>SecurityError</code>. Когато това се случи, ние ще създадем връзка към точката на още един вид URL, използвайки <em>javascript:</em> протокол. Тази връзка изпълнява просто скрипта даден след двуточието, която следвайки този линк ще се покаже <code>alert</code> прозорец информирайки потребителя за проблема, когато се натисне.</p>
<h2><a class="h_ident" id="h_iQAMmIQaWl" href="./19_paint.html#h_iQAMmIQaWl"></a>Зареждане  на  файлове  с  изображения</h2>
<p><a class="p_ident" id="p_3vrUSpPAL9" href="./19_paint.html#p_3vrUSpPAL9"></a>Последните две контроли се използват за прехвърляне на изображения от локални файлове и URL адреси. Ще имаме нужда от следната помощна функция, която се опитва да зареди файл с изображение от URL и да замени съдържанието на платното с него.</p>
<pre data-language="javascript" class="snippet cm-s-default" data-sandbox="paint"><a class="c_ident" id="c_pOA1CgtG03" href="./19_paint.html#c_pOA1CgtG03"></a><span class="cm-keyword">function</span> <span class="cm-variable">loadImageURL</span>(<span class="cm-def">cx</span>, <span class="cm-def">url</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">image</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">createElement</span>(<span class="cm-string">"img"</span>);
  <span class="cm-variable-2">image</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">"load"</span>, <span class="cm-keyword">function</span>() {
    <span class="cm-keyword">var</span> <span class="cm-def">color</span> <span class="cm-operator">=</span> <span class="cm-variable-2">cx</span>.<span class="cm-property">fillStyle</span>, <span class="cm-def">size</span> <span class="cm-operator">=</span> <span class="cm-variable-2">cx</span>.<span class="cm-property">lineWidth</span>;
    <span class="cm-variable-2">cx</span>.<span class="cm-property">canvas</span>.<span class="cm-property">width</span> <span class="cm-operator">=</span> <span class="cm-variable-2">image</span>.<span class="cm-property">width</span>;
    <span class="cm-variable-2">cx</span>.<span class="cm-property">canvas</span>.<span class="cm-property">height</span> <span class="cm-operator">=</span> <span class="cm-variable-2">image</span>.<span class="cm-property">height</span>;
    <span class="cm-variable-2">cx</span>.<span class="cm-property">drawImage</span>(<span class="cm-variable-2">image</span>, <span class="cm-number">0</span>, <span class="cm-number">0</span>);
    <span class="cm-variable-2">cx</span>.<span class="cm-property">fillStyle</span> <span class="cm-operator">=</span> <span class="cm-variable-2">color</span>;
    <span class="cm-variable-2">cx</span>.<span class="cm-property">strokeStyle</span> <span class="cm-operator">=</span> <span class="cm-variable-2">color</span>;
    <span class="cm-variable-2">cx</span>.<span class="cm-property">lineWidth</span> <span class="cm-operator">=</span> <span class="cm-variable-2">size</span>;
  });
  <span class="cm-variable-2">image</span>.<span class="cm-property">src</span> <span class="cm-operator">=</span> <span class="cm-variable-2">url</span>;
}</pre>
<p><a class="p_ident" id="p_fxJmZUi/g3" href="./19_paint.html#p_fxJmZUi/g3"></a>Ние искаме да променим размера на платното за да се побере точно изображението. По някаква причина, променяната размера на платното ще предизвика неговия контекст за рисуване да забрави конфигурационните свойства, като <code>fillStyle</code> и <code>lineWidth</code>, така че функцията ще ги запази и възстанови, след като актуализира размера на платното.</p>
<p><a class="p_ident" id="p_BRkDNREP7P" href="./19_paint.html#p_BRkDNREP7P"></a>Управлението за зареждане на локален файл използва <code>FileReader</code> техниката от <a href="./18_forms.html#filereader">Глава 18</a>. Отделно от <code>readAsText</code> метода, който използвахме там, такива четящи обекти също имат метод наречен <code>readAsDataURL</code>, което е точно това, което ни трябва тук. Ние зареждаме файла, който потребителя е избрал като URL данни и го предаваме на <code>loadImageURL</code> да го пусне в платното.</p>
<pre data-language="javascript" class="snippet cm-s-default" data-sandbox="paint"><a class="c_ident" id="c_lXjE/XfP0W" href="./19_paint.html#c_lXjE/XfP0W"></a><span class="cm-variable">controls</span>.<span class="cm-property">openFile</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">cx</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">input</span> <span class="cm-operator">=</span> <span class="cm-variable">elt</span>(<span class="cm-string">"input"</span>, {<span class="cm-property">type</span>: <span class="cm-string">"file"</span>});
  <span class="cm-variable-2">input</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">"change"</span>, <span class="cm-keyword">function</span>() {
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">input</span>.<span class="cm-property">files</span>.<span class="cm-property">length</span> <span class="cm-operator">==</span> <span class="cm-number">0</span>) <span class="cm-keyword">return</span>;
    <span class="cm-keyword">var</span> <span class="cm-def">reader</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">FileReader</span>();
    <span class="cm-variable-2">reader</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">"load"</span>, <span class="cm-keyword">function</span>() {
      <span class="cm-variable">loadImageURL</span>(<span class="cm-variable-2">cx</span>, <span class="cm-variable-2">reader</span>.<span class="cm-property">result</span>);
    });
    <span class="cm-variable-2">reader</span>.<span class="cm-property">readAsDataURL</span>(<span class="cm-variable-2">input</span>.<span class="cm-property">files</span>[<span class="cm-number">0</span>]);
  });
  <span class="cm-keyword">return</span> <span class="cm-variable">elt</span>(<span class="cm-string">"div"</span>, <span class="cm-atom">null</span>, <span class="cm-string">"Open file: "</span>, <span class="cm-variable-2">input</span>);
};</pre>
<p><a class="p_ident" id="p_3cQw/osn6v" href="./19_paint.html#p_3cQw/osn6v"></a>Зареждането на файл от URL е още по-лесно. Но с текстово поле то е още по-ясно, когато потребителя свърши с писането на URL, така че не можем просто да се ослушваме за <code>"change"</code> събития. Вместо това, ще увием полето във форма и да реагира при подаване на формуляра, когато потребителя натисне Enter или е кликнал върху бутона за зареждане.</p>
<pre data-language="javascript" class="snippet cm-s-default" data-sandbox="paint"><a class="c_ident" id="c_XY31yVKH8e" href="./19_paint.html#c_XY31yVKH8e"></a><span class="cm-variable">controls</span>.<span class="cm-property">openURL</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">cx</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">input</span> <span class="cm-operator">=</span> <span class="cm-variable">elt</span>(<span class="cm-string">"input"</span>, {<span class="cm-property">type</span>: <span class="cm-string">"text"</span>});
  <span class="cm-keyword">var</span> <span class="cm-def">form</span> <span class="cm-operator">=</span> <span class="cm-variable">elt</span>(<span class="cm-string">"form"</span>, <span class="cm-atom">null</span>,
                 <span class="cm-string">"Open URL: "</span>, <span class="cm-variable-2">input</span>,
                 <span class="cm-variable">elt</span>(<span class="cm-string">"button"</span>, {<span class="cm-property">type</span>: <span class="cm-string">"submit"</span>}, <span class="cm-string">"load"</span>));
  <span class="cm-variable-2">form</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">"submit"</span>, <span class="cm-keyword">function</span>(<span class="cm-def">event</span>) {
    <span class="cm-variable-2">event</span>.<span class="cm-property">preventDefault</span>();
    <span class="cm-variable">loadImageURL</span>(<span class="cm-variable-2">cx</span>, <span class="cm-variable-2">input</span>.<span class="cm-property">value</span>);
  });
  <span class="cm-keyword">return</span> <span class="cm-variable-2">form</span>;
};</pre>
<p><a class="p_ident" id="p_kU0DSJWhbC" href="./19_paint.html#p_kU0DSJWhbC"></a>Сега сме определили всички управления, от които нашата проста програма за рисуване се нуждае, но тя може да използва още няколко инструмента.</p>
<h2><a class="h_ident" id="h_COOrE3GQwB" href="./19_paint.html#h_COOrE3GQwB"></a>Довършване  на  горе</h2>
<p><a class="p_ident" id="p_eRxkqfyNnx" href="./19_paint.html#p_eRxkqfyNnx"></a>Можем лесно да добавим инструмент за текст, който използва <code>prompt</code>, за да пита потребителя, кой <em>string</em> трябва да направи.</p>
<pre data-language="javascript" class="snippet cm-s-default" data-sandbox="paint"><a class="c_ident" id="c_8/T9PP3cBg" href="./19_paint.html#c_8/T9PP3cBg"></a><span class="cm-variable">tools</span>.<span class="cm-property">Text</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">event</span>, <span class="cm-def">cx</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">text</span> <span class="cm-operator">=</span> <span class="cm-variable">prompt</span>(<span class="cm-string">"Text:"</span>, <span class="cm-string">""</span>);
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">text</span>) {
    <span class="cm-keyword">var</span> <span class="cm-def">pos</span> <span class="cm-operator">=</span> <span class="cm-variable">relativePos</span>(<span class="cm-variable-2">event</span>, <span class="cm-variable-2">cx</span>.<span class="cm-property">canvas</span>);
    <span class="cm-variable-2">cx</span>.<span class="cm-property">font</span> <span class="cm-operator">=</span> <span class="cm-variable">Math</span>.<span class="cm-property">max</span>(<span class="cm-number">7</span>, <span class="cm-variable-2">cx</span>.<span class="cm-property">lineWidth</span>) <span class="cm-operator">+</span> <span class="cm-string">"px sans-serif"</span>;
    <span class="cm-variable-2">cx</span>.<span class="cm-property">fillText</span>(<span class="cm-variable-2">text</span>, <span class="cm-variable-2">pos</span>.<span class="cm-property">x</span>, <span class="cm-variable-2">pos</span>.<span class="cm-property">y</span>);
  }
};</pre>
<p><a class="p_ident" id="p_L3dnKFwhJy" href="./19_paint.html#p_L3dnKFwhJy"></a>Можем да добавим допълнителни полета за размера и стила на шрифта, но за улеснение ще използваме винаги <em>sans-serif</em>  шрифт и за основа на размера на шрифта, текущия размер на четката. Минималния размер е 7 пиксела, защото текст по-малък от този е нечетлив.</p>
<p><a class="p_ident" id="p_rTc/MzJCFC" href="./19_paint.html#p_rTc/MzJCFC"></a>Друг незаменим инструмент за рисуване на аматьорска компютърна графика е спрея за боя. Той рисува точки в рамките на случайни места под четката, стига мишката да е задържана натисната, създавайки плътно или по-малко плътно пръскане въз основа на това колко бързо или бавно се движи мишката.</p>
<pre data-language="javascript" class="snippet cm-s-default" data-sandbox="paint"><a class="c_ident" id="c_MPtJObrL+v" href="./19_paint.html#c_MPtJObrL+v"></a><span class="cm-variable">tools</span>.<span class="cm-property">Spray</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">event</span>, <span class="cm-def">cx</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">radius</span> <span class="cm-operator">=</span> <span class="cm-variable-2">cx</span>.<span class="cm-property">lineWidth</span> <span class="cm-operator">/</span> <span class="cm-number">2</span>;
  <span class="cm-keyword">var</span> <span class="cm-def">area</span> <span class="cm-operator">=</span> <span class="cm-variable-2">radius</span> <span class="cm-operator">*</span> <span class="cm-variable-2">radius</span> <span class="cm-operator">*</span> <span class="cm-variable">Math</span>.<span class="cm-property">PI</span>;
  <span class="cm-keyword">var</span> <span class="cm-def">dotsPerTick</span> <span class="cm-operator">=</span> <span class="cm-variable">Math</span>.<span class="cm-property">ceil</span>(<span class="cm-variable-2">area</span> <span class="cm-operator">/</span> <span class="cm-number">30</span>);

  <span class="cm-keyword">var</span> <span class="cm-def">currentPos</span> <span class="cm-operator">=</span> <span class="cm-variable">relativePos</span>(<span class="cm-variable-2">event</span>, <span class="cm-variable-2">cx</span>.<span class="cm-property">canvas</span>);
  <span class="cm-keyword">var</span> <span class="cm-def">spray</span> <span class="cm-operator">=</span> <span class="cm-variable">setInterval</span>(<span class="cm-keyword">function</span>() {
    <span class="cm-keyword">for</span> (<span class="cm-keyword">var</span> <span class="cm-def">i</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>; <span class="cm-variable-2">i</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">dotsPerTick</span>; <span class="cm-variable-2">i</span><span class="cm-operator">++</span>) {
      <span class="cm-keyword">var</span> <span class="cm-def">offset</span> <span class="cm-operator">=</span> <span class="cm-variable">randomPointInRadius</span>(<span class="cm-variable-2">radius</span>);
      <span class="cm-variable-2">cx</span>.<span class="cm-property">fillRect</span>(<span class="cm-variable-2">currentPos</span>.<span class="cm-property">x</span> <span class="cm-operator">+</span> <span class="cm-variable-2">offset</span>.<span class="cm-property">x</span>,
                  <span class="cm-variable-2">currentPos</span>.<span class="cm-property">y</span> <span class="cm-operator">+</span> <span class="cm-variable-2">offset</span>.<span class="cm-property">y</span>, <span class="cm-number">1</span>, <span class="cm-number">1</span>);
    }
  }, <span class="cm-number">25</span>);
  <span class="cm-variable">trackDrag</span>(<span class="cm-keyword">function</span>(<span class="cm-def">event</span>) {
    <span class="cm-variable-2">currentPos</span> <span class="cm-operator">=</span> <span class="cm-variable">relativePos</span>(<span class="cm-variable-2">event</span>, <span class="cm-variable-2">cx</span>.<span class="cm-property">canvas</span>);
  }, <span class="cm-keyword">function</span>() {
    <span class="cm-variable">clearInterval</span>(<span class="cm-variable-2">spray</span>);
  });
};</pre>
<p><a class="p_ident" id="p_PC1+gUob8b" href="./19_paint.html#p_PC1+gUob8b"></a>Инструмента за спрей използва <code>setInterval</code> за да изплюе цветни точици на всеки 25 милисекунди, докато бутона на мишката е задържан натиснат. Функцията <code>trackDrag</code> се използва за да запази <code>currentPos</code>, която показва текущата позиция на мишката и да изключи интервала, когато бутона на мишката е освободен.</p>
<p><a class="p_ident" id="p_CRD18th69E" href="./19_paint.html#p_CRD18th69E"></a>За да се определи, колко точки се правят всеки път при ефекта на интервала, функцията изчислява площта на текущата четка и я разделя на 30. За да намерим случайна позиция под четката използваме  функцията <code>randomPointInRadius</code>.</p>
<pre data-language="javascript" class="snippet cm-s-default" data-sandbox="paint"><a class="c_ident" id="c_yPBoJqnTXO" href="./19_paint.html#c_yPBoJqnTXO"></a><span class="cm-keyword">function</span> <span class="cm-variable">randomPointInRadius</span>(<span class="cm-def">radius</span>) {
  <span class="cm-keyword">for</span> (;;) {
    <span class="cm-keyword">var</span> <span class="cm-def">x</span> <span class="cm-operator">=</span> <span class="cm-variable">Math</span>.<span class="cm-property">random</span>() <span class="cm-operator">*</span> <span class="cm-number">2</span> <span class="cm-operator">-</span> <span class="cm-number">1</span>;
    <span class="cm-keyword">var</span> <span class="cm-def">y</span> <span class="cm-operator">=</span> <span class="cm-variable">Math</span>.<span class="cm-property">random</span>() <span class="cm-operator">*</span> <span class="cm-number">2</span> <span class="cm-operator">-</span> <span class="cm-number">1</span>;
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">x</span> <span class="cm-operator">*</span> <span class="cm-variable-2">x</span> <span class="cm-operator">+</span> <span class="cm-variable-2">y</span> <span class="cm-operator">*</span> <span class="cm-variable-2">y</span> <span class="cm-operator">&lt;=</span> <span class="cm-number">1</span>)
      <span class="cm-keyword">return</span> {<span class="cm-property">x</span>: <span class="cm-variable-2">x</span> <span class="cm-operator">*</span> <span class="cm-variable-2">radius</span>, <span class="cm-property">y</span>: <span class="cm-variable-2">y</span> <span class="cm-operator">*</span> <span class="cm-variable-2">radius</span>};
  }
}</pre>
<p><a class="p_ident" id="p_bpIPMJAN/Q" href="./19_paint.html#p_bpIPMJAN/Q"></a>Тази функция генерира точки в квадрата между (-1, -1) и (1, 1). С помощта на Питагоровата теорема, тя проверява дали образуваните точки лежат в кръг с радиус от 1. Веднага след, като функцията установи такава точка, тя връща точката умножена по <code>radius</code> аргумента.</p>
<p><a class="p_ident" id="p_8ATK7SQccV" href="./19_paint.html#p_8ATK7SQccV"></a>Цикъла е необходим за по-равномерно разпределение на точките. Друг разбираем начин за генериране на случайна точка във вътрешноста на кръг е да се използва случаен ъгъл и разстояние и извикване на <code>Math.sin</code> и <code>Math.cos</code> да създадат съответната точка. Но с този метод, точките са по-склонни да се появяват в близост до центъра на кръга. Има и други начини за това, но те са по-сложни.</p>
<p><a class="p_ident" id="p_Tj66LpaWji" href="./19_paint.html#p_Tj66LpaWji"></a>Сега имаме една функционираща програма за рисуване. Стартирайте кода по долу, за да я изпробвате.</p>
<pre data-language="text/html" class="snippet cm-s-default" data-sandbox="paint"><a class="c_ident" id="c_pD0giwc4AL" href="./19_paint.html#c_pD0giwc4AL"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">link</span> <span class="cm-attribute">rel</span>=<span class="cm-string">"stylesheet"</span> <span class="cm-attribute">href</span>=<span class="cm-string">"css/paint.css"</span><span class="cm-tag cm-bracket">&gt;</span>

<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">body</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span><span class="cm-variable">createPaint</span>(<span class="cm-variable">document</span>.<span class="cm-property">body</span>);<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">body</span><span class="cm-tag cm-bracket">&gt;</span></pre>
<h2><a class="h_ident" id="h_TcUD2vzyMe" href="./19_paint.html#h_TcUD2vzyMe"></a>Упражнения </h2>
<p><a class="p_ident" id="p_We+KsAI00v" href="./19_paint.html#p_We+KsAI00v"></a>Все още има много място за подобрения в тази програма. Нека добавим още няколко функции, като упражнения.</p>
<h3><a class="h_ident" id="h_AXnJJyTV3X" href="./19_paint.html#h_AXnJJyTV3X"></a>Правоъгълници</h3>
<p><a class="p_ident" id="p_4pYKvTwVL6" href="./19_paint.html#p_4pYKvTwVL6"></a>Дефинирайте инструмент наречен <code>Rectangle</code> който запълва правоъгълник (виж <code>fillRect</code> метода в <a href="./16_canvas.html#fill_stroke">Глава 16</a>) с текущия цвят. Правоъгълника трябва да се разделя от точката, където потребителя натисне бутона на мишката до точката, където го освобождава. Имайте в предвид, че последното може да бъде над или в ляво от първото.</p>
<p><a class="p_ident" id="p_FZYD7EtH2K" href="./19_paint.html#p_FZYD7EtH2K"></a>След като той работи, вие ще забележите, че до известна степен дразни, като не се вижда правоъгълника, когато влачите мишката за да определите своя размер. Можете ли да измислите начин за показване на модела на правоъгълника по време на драгването без да го рисувате всъщност на платното, докато бутона на мишката не е освободен?</p>
<p><a class="p_ident" id="p_XS+oeSzbgP" href="./19_paint.html#p_XS+oeSzbgP"></a>Ако нищо не ви идва на ум се върнете на <code>position: absolute</code> стила обсъден в <a href="./13_dom.html#animation">Chapter 13</a>, който може да се използва  за наслагване на разклонения върху останалата част от документа. Свойствата <code>pageX</code> и <code>pageY</code> на събитието на мишката могат да бъдат използвани, за позициониране на елемент точно под мишката, чрез определяне на <code>left</code>, <code>top</code>, <code>width</code> и <code>height</code> стилове към правилните пикселни стойности.</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class="c_ident" id="c_dL4pxdAiRT" href="./19_paint.html#c_dL4pxdAiRT"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-variable">tools</span>.<span class="cm-property">Rectangle</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">event</span>, <span class="cm-def">cx</span>) {
    <span class="cm-comment">// Your code here.</span>
  };
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>

<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">link</span> <span class="cm-attribute">rel</span>=<span class="cm-string">"stylesheet"</span> <span class="cm-attribute">href</span>=<span class="cm-string">"css/paint.css"</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">body</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span><span class="cm-variable">createPaint</span>(<span class="cm-variable">document</span>.<span class="cm-property">body</span>);<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">body</span><span class="cm-tag cm-bracket">&gt;</span></pre>
<div class="solution"><div class="solution-text">
<p><a class="p_ident" id="p_+2Q554eAdQ" href="./19_paint.html#p_+2Q554eAdQ"></a>Можете да използвате <code>relativePos</code> за да намерите ъгъл, съответстващ на началото на плъзгане на мишката. Измислянето на, къде свършва влаченето, може да бъде направено с <code>trackDrag</code> или като регистрирате свой собствен манипулатор на събитие.</p>
<p><a class="p_ident" id="p_UvlqG2Ephm" href="./19_paint.html#p_UvlqG2Ephm"></a>Когато имаш два ъгъла на правоъгълник, трябва по някакъв начин да подадеш това в аргументите, които <code>fillRect</code> очаква:  горния ляв ъгъл, ширината и височината на правоъгълника. <code>Math.min</code> може да се използва за да намерите най-левия х-координата и най-гориния у-координата. За да получите ширината и височината, можете да ползвате <code>Math.abs</code> (абсолютната стойност) върху разликата между двете страни.</p>
<p><a class="p_ident" id="p_qnwnWqJZmQ" href="./19_paint.html#p_qnwnWqJZmQ"></a>Показването на правоъгълника по време на плъзгане на мишката изисква подобен набор от числа, но в контекста на цялата страница, а не по отношение на платното. Помислете за написване на функция <code>findRect</code>, която превръща две точки в обект с <code>top</code>, <code>left</code>, <code>width</code> и <code>height</code> свойства, така че да не е нужно да се пише една и съща логика два пъти.</p>
<p><a class="p_ident" id="p_BtWgOio6fw" href="./19_paint.html#p_BtWgOio6fw"></a>След това можете да създадете <code>&lt;div&gt;</code> разклонение и настроите <code>style.position</code>: <code>absolute</code>. При определяне на стилове за позициониране, не забравяйте да добавите <code>"px"</code> към номерата. Разклонението трябва да се добавя към документа (може да го добавите с <code>document.body</code>) и също така се отстранява отново, когато плъзгането завърши и се получава действителния правоъгълник върху платното.</p>
</div></div>
<h3><a class="h_ident" id="h_kd7pYrPaOx" href="./19_paint.html#h_kd7pYrPaOx"></a>Избор на цвят</h3>
<p><a class="p_ident" id="p_Jg9zx2ZHXs" href="./19_paint.html#p_Jg9zx2ZHXs"></a>Друг инструмент, който се среща често в графичните програми е колектор за цвят, който позволява  на потребителя, като кликне върху изображението да опредли цвета под показалеца на мишката. Изградете това.</p>
<p><a class="p_ident" id="p_2/ActRBD9m" href="./19_paint.html#p_2/ActRBD9m"></a>За тази услуга се нуждаем от начин за достъп до съдържанието на платното. Метода <code>toDataURL</code> повече или по-малко е направил това, но вземането на пиксел информация от такъв URL с данни е трудно. Вместо това, използвайте метода <code>getImageData</code> върху контекста на рисуването, който връща правоъгълно парче изображение, като обект с <code>width</code>, <code>height</code>,
и <code>data</code> свойства. Свойството <code>data</code> притежава масив с числа от 0 до 255, като се използват четири числа  за представяне на червено, зелено, синьо и алфа компонента (прозрачност) за всеки пиксел.</p>
<p><a class="p_ident" id="p_D6jTExt5KG" href="./19_paint.html#p_D6jTExt5KG"></a>Този пример извлича цифрите за един пиксел от платното веднъж, когато платното е празно (всички пиксели са прозрачно черни) и веднъж, когато пикселът е оцветен в червено. </p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_kkpvQb4tko" href="./19_paint.html#c_kkpvQb4tko"></a><span class="cm-keyword">function</span> <span class="cm-variable">pixelAt</span>(<span class="cm-def">cx</span>, <span class="cm-def">x</span>, <span class="cm-def">y</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">data</span> <span class="cm-operator">=</span> <span class="cm-variable-2">cx</span>.<span class="cm-property">getImageData</span>(<span class="cm-variable-2">x</span>, <span class="cm-variable-2">y</span>, <span class="cm-number">1</span>, <span class="cm-number">1</span>);
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable-2">data</span>.<span class="cm-property">data</span>);
}

<span class="cm-keyword">var</span> <span class="cm-variable">canvas</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">createElement</span>(<span class="cm-string">"canvas"</span>);
<span class="cm-keyword">var</span> <span class="cm-variable">cx</span> <span class="cm-operator">=</span> <span class="cm-variable">canvas</span>.<span class="cm-property">getContext</span>(<span class="cm-string">"2d"</span>);
<span class="cm-variable">pixelAt</span>(<span class="cm-variable">cx</span>, <span class="cm-number">10</span>, <span class="cm-number">10</span>);
<span class="cm-comment">// → [0, 0, 0, 0]</span>

<span class="cm-variable">cx</span>.<span class="cm-property">fillStyle</span> <span class="cm-operator">=</span> <span class="cm-string">"red"</span>;
<span class="cm-variable">cx</span>.<span class="cm-property">fillRect</span>(<span class="cm-number">10</span>, <span class="cm-number">10</span>, <span class="cm-number">1</span>, <span class="cm-number">1</span>);
<span class="cm-variable">pixelAt</span>(<span class="cm-variable">cx</span>, <span class="cm-number">10</span>, <span class="cm-number">10</span>);
<span class="cm-comment">// → [255, 0, 0, 255]</span></pre>
<p><a class="p_ident" id="p_LAAk4BgbLG" href="./19_paint.html#p_LAAk4BgbLG"></a>Аргументите на <code>getImageData</code> показват старта на х и у - координатите на правоъгълника, който искаме да обработим, последвани от неговата ширина и височина..</p>
<p><a class="p_ident" id="p_C46YeilKO0" href="./19_paint.html#p_C46YeilKO0"></a>Игнорирайте прозрачността по време на това упражнение и вижте само първите три стойности за даден пиксел. Също така не се притеснявайте за актуализирането на цветовете на полето, когато потребителя избира цвят. Просто се уверете, че контекста за рисуване на <code>fillStyle</code> и <code>strokeStyle</code> е настроен на цвета под курсора на мишката.</p>
<p><a class="p_ident" id="p_AvBU/YxtZc" href="./19_paint.html#p_AvBU/YxtZc"></a>Не забравяйте, че тези свойства не приемат всеки цвят, който CSS разбира, което включва <code>rgb(R, G, B)</code> стила, който видяхме в <a href="./15_game.html#game_css">Глава 15</a>.</p>
<p><a class="p_ident" id="p_TrX1yewkGx" href="./19_paint.html#p_TrX1yewkGx"></a>Метода <code>getImageData</code> е субект на същите ограничения, както <code>toDataURL</code> - той повдига грешка, когато платното съдържа пиксели, които произхождат от друг домейн. Използвайте <code>try/catch</code> твърдение за да докладвате такива грешки с диалоговия прозорец <code>alert</code>.</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class="c_ident" id="c_tIbJS0qHIa" href="./19_paint.html#c_tIbJS0qHIa"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-variable">tools</span>[<span class="cm-string">"Pick color"</span>] <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">event</span>, <span class="cm-def">cx</span>) {
    <span class="cm-comment">// Your code here.</span>
  };
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>

<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">link</span> <span class="cm-attribute">rel</span>=<span class="cm-string">"stylesheet"</span> <span class="cm-attribute">href</span>=<span class="cm-string">"css/paint.css"</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">body</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span><span class="cm-variable">createPaint</span>(<span class="cm-variable">document</span>.<span class="cm-property">body</span>);<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">body</span><span class="cm-tag cm-bracket">&gt;</span></pre>
<div class="solution"><div class="solution-text">
<p><a class="p_ident" id="p_VIyP7gKCWe" href="./19_paint.html#p_VIyP7gKCWe"></a>Отново ще трябва да ползвате <code>relativePos</code> за да разберете кой пиксел е  кликнат. Функцията <code>pixelAt</code> в примера показва, как да получите стойностите на един пиксел. Поставянето им в един <code>rgb</code> <em>string</em> просто изисква конкатинация на <em>strings</em>.</p>
<p><a class="p_ident" id="p_F8sDaqW/ce" href="./19_paint.html#p_F8sDaqW/ce"></a>Уверете се, че проверката за изключение е инстанция на <code>SecurityError</code>, така че да не е случайно да се справят с грешен вид изключение.</p>
</div></div>
<h3><a class="h_ident" id="h_0M49T26QUl" href="./19_paint.html#h_0M49T26QUl"></a>Наводнение</h3>
<p><a class="p_ident" id="p_9+5Lhu8/5P" href="./19_paint.html#p_9+5Lhu8/5P"></a>Това упражнение е за по-напреднали, от колкото предните две и ще изисква да се изработи <em>nontrivial</em> решение на сложен проблем. Уверете се, че имате достатъчно търпение и време, преди да започнете да работите върху него и не се обезсърчавайте от първите неуспехи.</p>
<p><a class="p_ident" id="p_OkFYhhueP3" href="./19_paint.html#p_OkFYhhueP3"></a>Наводнението е инструмент за запълване на цветовете на пикселите под мишката и околните пиксели с един и същи цвят. За целите на това упражнение, обмислете такава група за включване на всички пиксели, които могат да бъдат достигнати от нашия начален пиксел чрез преместване със стъпка един пиксел хоризонтално и вертикално (без диагонал) без да докосваме пиксела, който има различен цвят от началния пиксел.</p>
<p><a class="p_ident" id="p_6uRENk52k1" href="./19_paint.html#p_6uRENk52k1"></a>Следното изображение показва снимка на площадката с набора от оцветени пиксели, когато инструмента за наводнение се използва с маркирания пиксел.</p>
<div class="image">
  <img src="./media/flood-grid.svg" alt="Flood fill example">
</div>
<p><a class="p_ident" id="p_wwglcJ4sDv" href="./19_paint.html#p_wwglcJ4sDv"></a>Наводнението не изтича през диагоналните пропуски и не докосва пикселите, които не са достъпни, дори да имат същия цвят, като целевия пиксел.</p>
<p><a class="p_ident" id="p_76DZCicyt0" href="./19_paint.html#p_76DZCicyt0"></a>Вие отново ще трябва да разберете цвета на всеки пиксел с <code>getImageData</code>. Това може би е добра идея да се донесе цялото изображение на един път и след това да изберем пиксел данните от получения масив. Пикселите са организирани в този масив по начин подобен на елементите на мрежата в <a href="./07_elife.html#grid">Глава 7</a>, един ред в даден момент, освен че всеки пиксел е представен от четири стойности. Първата стойност на пиксела е (<em>x</em>,<em>y</em>) в позиция (<em>x</em> + <em>y</em> × width) × 4.</p>
<p><a class="p_ident" id="p_jVploHhiTC" href="./19_paint.html#p_jVploHhiTC"></a>С включването на четвърта (алфа) стойност, ние искаме да кажем разликата между празни и черни пиксели.</p>
<p><a class="p_ident" id="p_pGlySQoufy" href="./19_paint.html#p_pGlySQoufy"></a>Намирането на всички съседни пиксели с един и същи цвят изисква от вас “разходка” над повърхността на пикселите, един нагоре, надолу, наляво и надясно докато новите същия цвят пиксели бъдат намерени. Но вие няма да намерите всички пиксели от една група с първата разходка. По-скоро трябва да се направи нещо подобно на връщане назад направено с регулярен израз за съвпадение, описано в <a href="./09_regexp.html#backtracking">Глава 9</a>. Всеки път, когато има повече от една възможна посока за продължаване, ние трябва да запишем всички посоки, които не се вземат веднага и да ги прегледаме по-късно, когато приключим текущата разходка.</p>
<p><a class="p_ident" id="p_QgadJ7T7nC" href="./19_paint.html#p_QgadJ7T7nC"></a>В едно нормално по-големина изображение има много пиксели. За това, ние трябва да се погрижим да се прави минималното количество работа, от което се нуждаем или програмата ще отнеме много дълго време да се изпълнява. Например всяка разходка трябва да игнорира пиксела видян от предишните разходки, така че да не се повтаря вече свършената работа.</p>
<p><a class="p_ident" id="p_tPAU+iaccT" href="./19_paint.html#p_tPAU+iaccT"></a>Аз препоръчвам да извикате <code>fillRect</code> за отделните пиксели, и когато един пиксел, който трябва да бъде оцветен е намерен, се запазва в някаква структура от данни, която ни казва за всички пиксели, които вече са били разгледани.</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class="c_ident" id="c_Cj2ssFLWyJ" href="./19_paint.html#c_Cj2ssFLWyJ"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-variable">tools</span>[<span class="cm-string">"Flood fill"</span>] <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">event</span>, <span class="cm-def">cx</span>) {
    <span class="cm-comment">// Your code here.</span>
  };
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>

<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">link</span> <span class="cm-attribute">rel</span>=<span class="cm-string">"stylesheet"</span> <span class="cm-attribute">href</span>=<span class="cm-string">"css/paint.css"</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">body</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span><span class="cm-variable">createPaint</span>(<span class="cm-variable">document</span>.<span class="cm-property">body</span>);<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">body</span><span class="cm-tag cm-bracket">&gt;</span></pre>
<div class="solution"><div class="solution-text">
<p><a class="p_ident" id="p_roLPCOzlbR" href="./19_paint.html#p_roLPCOzlbR"></a>При дадена двойка начални координати и данни за изображението върху цялото платно, този подход трябва да работи:</p>
<div class="olist arabic"><ol class="arabic">
<li>
<p><a class="p_ident" id="p_DJfuZAPd2V" href="./19_paint.html#p_DJfuZAPd2V"></a>
Създаване на масив разполагащ с информация за вече оцветени координати.
</p>
</li>
<li>
<p><a class="p_ident" id="p_8q76RzMUPC" href="./19_paint.html#p_8q76RzMUPC"></a>
Създаване на масив - работен списък, който да държи вече разгледаните координати. Поставяне на начална позиция в него.
</p>
</li>
<li>
<p><a class="p_ident" id="p_jf/y0a21iq" href="./19_paint.html#p_jf/y0a21iq"></a>
Извадете една двойка координати от работния списък.
</p>
</li>
<li>
<p><a class="p_ident" id="p_wDYrBpc4sn" href="./19_paint.html#p_wDYrBpc4sn"></a>
Remove one pair of coordinates from the work list.
</p>
</li>
<li>
<p><a class="p_ident" id="p_JXeW3M6LBu" href="./19_paint.html#p_JXeW3M6LBu"></a>
Ако тези координати са вече с нашата гама цветни пиксели, се върнете към стъпка 3.
</p>
</li>
<li>
<p><a class="p_ident" id="p_ybLJYGmnPS" href="./19_paint.html#p_ybLJYGmnPS"></a>
Цвят на пиксела в текущите координати и добавяне на координатите към масива от цветни пиксели.
</p>
</li>
<li>
<p><a class="p_ident" id="p_6sixhBP7gV" href="./19_paint.html#p_6sixhBP7gV"></a>
Добавяне на координатите на всеки пиксел към работния списък, чийто цвят е същия, като оригиналния цвят на началния пиксел.
</p>
</li>
<li>
<p><a class="p_ident" id="p_37aWwfOEWf" href="./19_paint.html#p_37aWwfOEWf"></a>
Върнете се към стъпка 3.
</p>
</li>
</ol></div>
<p><a class="p_ident" id="p_K10R222PDR" href="./19_paint.html#p_K10R222PDR"></a>Работния списък може да бъде просто набор от векторни обекти. Структурата от данни, която проследява цветните пиксели ще бъде консултирана много често. Търсенето през цялото това нещо всеки път, когато нов пиксел се инспектира ще отнеме много време. Вместо това можете да създадете нов масив, който съдържа стойност за всеки пиксел, отново с помощта на <em>x + y * width</em> на схемата, за асоцииране на позицията с пиксела. При проверката дали един пиксел е вече оцветен, вие директно може да получите достъп до позицията съответстваща на текущия пиксел.</p>
<p><a class="p_ident" id="p_238ysWaiXF" href="./19_paint.html#p_238ysWaiXF"></a>Можете да сравните цветовете от преминаването през съответната част от масива с данни, сравнявайки едно поле в даден момент. Или може да "кондензирате" цвят към единично число или <em>string</em> и да го сравните с тези. Когато се прави това, се гарантира, че всеки цвят произвежда уникална стойност. Например, просто добавяне на цветни компоненти не е безопасно, тъй като множество цветове ще имат същия размер.</p>
<p><a class="p_ident" id="p_JPRZIpzUnJ" href="./19_paint.html#p_JPRZIpzUnJ"></a>Когато изброявате съседите на дадена точка, трябва да се погрижите за изключването на съседи, които не са от вътрешната страна на платното или вашата програма може да избяга в дадена посока завинаги.</p>
</div></div>
<nav>
  <a href="./18_forms.html" title="previous chapter">◀</a>
  <a href="./index.html" title="cover">◆</a>
  <a href="./20_node.html" title="next chapter">▶</a>
</nav>
</article>
</body></html>