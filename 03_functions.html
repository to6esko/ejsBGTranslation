<!DOCTYPE html>
<!-- saved from url=(0047)./03_functions.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <title>Functions :: Eloquent JavaScript</title>
  <link rel="stylesheet" href="./media/codemirror.css">
  <script src="./media/acorn_codemirror.js"></script>
  <link rel="stylesheet" href="./media/ejs.css">
  <script src="./media/sandbox.js"></script>
  <script src="./media/ejs.js"></script>
  <script>var chapNum = 3;</script>
</head>

<body><article>
<nav>
  <a href="./02_program_structure.html" title="previous chapter">◀</a>
  <a href="./index.html" title="cover">◆</a>
  <a href="./04_data.html" title="next chapter">▶</a>
</nav>

<h1><div class="chap_num">Глава 3</div>Функции</h1>
<blockquote>
<p><a class="p_ident" id="p_hkFlscMSbe" href="./03_functions.html#p_hkFlscMSbe"></a>Хората  си мислят, че компютърните науки са изкуство за гении, но реалната действителност е точно обратна, само много хора, които правят неща, които се натрупват едно върху друго, като стена от малки камъни”</p>
 <footer>Donald Knuth</footer>
</blockquote>
<p><a class="p_ident" id="p_tovalktUcj" href="./03_functions.html#p_tovalktUcj"></a>Вие сте виждали функции, като <code>alert</code> и как се извикват. Функциите са хлябът и маслото на JavaScript програмирането. Концепцията за опаковане на парче програма в стойност има много приложения. Това е инструмент да се структурират по-големи програми, да се намали повторението, да се свързват имена с програми и да се изолират тези програми една от друга.</p>
<p><a class="p_ident" id="p_R3iRdVuyh5" href="./03_functions.html#p_R3iRdVuyh5"></a>Най-очевидното прилагане на функции определя новата лексика. В обикновената проза на човешкия език, създаването на нови думи е лош стил. Но в програмирането е належащо.</p>
<p><a class="p_ident" id="p_pZXHY2QZfp" href="./03_functions.html#p_pZXHY2QZfp"></a>Типично възрастни англо-говорящи имат около 20 000 думи в речника си. Малко програмни езици идват с 20 000 команди в тях. И речника, който им е на разположение има тенденцията да бъде точно определен, по този начин са по-малко гъвкави, от колкото човешкия език. Ето защо трябва да добавим някои неща от собствения си речник.</p>
<h2><a class="h_ident" id="h_tqLFw/oazr" href="./03_functions.html#h_tqLFw/oazr"></a>Дефиниране на функция</h2>
<p><a class="p_ident" id="p_pBsAbh0THD" href="./03_functions.html#p_pBsAbh0THD"></a>Дефинирането на функция е просто, както дефиниране на обикновена променлива, когато стойността на тази променлива се случи да е функция. Например, следния код дефинира променливата <code>square</code>, за да се отнесе към функция, която произвежда квадрата на дадено число:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_tThK6S/S5v" href="./03_functions.html#c_tThK6S/S5v"></a><span class="cm-keyword">var</span> <span class="cm-variable">square</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">x</span>) {
  <span class="cm-keyword">return</span> <span class="cm-variable-2">x</span> <span class="cm-operator">*</span> <span class="cm-variable-2">x</span>;
};

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">square</span>(<span class="cm-number">12</span>));
<span class="cm-comment">// → 144</span></pre>
<p><a class="p_ident" id="p_dEjhFVa89N" href="./03_functions.html#p_dEjhFVa89N"></a>Функцията се създава от израз, който започва с ключовата дума <code>function</code>. Функцията има набор от параметри (в този случай <code>x</code>) и тяло, което съдържа <em>statements</em> (твърдение), което трябва да се изпълни, когато функцията се извика. Тялото на функцията трябва винаги да е заградено от скоби, дори ако то се състои само от едно твърдение (както в предишния пример).</p>
<p><a class="p_ident" id="p_qK7IQPBIRf" href="./03_functions.html#p_qK7IQPBIRf"></a>Функцията може да няма или има множество параметри. В следващия пример, <code>makeNoise</code> няма списък с имена на параметри, докато <code>power</code> има два:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_MhQVBHC9xI" href="./03_functions.html#c_MhQVBHC9xI"></a><span class="cm-keyword">var</span> <span class="cm-variable">makeNoise</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>() {
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"Pling!"</span>);
};

<span class="cm-variable">makeNoise</span>();
<span class="cm-comment">// → Pling!</span>

<span class="cm-keyword">var</span> <span class="cm-variable">power</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">base</span>, <span class="cm-def">exponent</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">result</span> <span class="cm-operator">=</span> <span class="cm-number">1</span>;
  <span class="cm-keyword">for</span> (<span class="cm-keyword">var</span> <span class="cm-def">count</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>; <span class="cm-variable-2">count</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">exponent</span>; <span class="cm-variable-2">count</span><span class="cm-operator">++</span>)
    <span class="cm-variable-2">result</span> <span class="cm-operator">*=</span> <span class="cm-variable-2">base</span>;
  <span class="cm-keyword">return</span> <span class="cm-variable-2">result</span>;
};

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">power</span>(<span class="cm-number">2</span>, <span class="cm-number">10</span>));
<span class="cm-comment">// → 1024</span></pre>
<p><a class="p_ident" id="p_PmG96omvw7" href="./03_functions.html#p_PmG96omvw7"></a>Някои функции произвеждат стойност, като например <code>power</code> и <code>square</code>, а други не, като <code>makeNoise</code>, която произвежда само страничен ефект. Твърдението <code>return</code> определя стойността, която функцията връща. Когато контрол се натъкне на подобно твърдение, той веднага изкача от текущата функция и дава върната стойност от кода на извиканата функция. Ключовата дума <code>return</code> без израз след нея, ще накара функцията да върне <code>undefined</code>.</p>
<h2><a class="h_ident" id="h_u4j2OhpYkg" href="./03_functions.html#h_u4j2OhpYkg"></a>Параметри  и  обхват</h2>
<p><a class="p_ident" id="p_N7xZ5k5OET" href="./03_functions.html#p_N7xZ5k5OET"></a>Параметрите на функцията се държат, като обикновени променливи, но техните първоначални стойности са зададени от извикващия функцията, а не от код в самата функция.</p>
<p><a class="p_ident" id="p_qWjz7fACpa" href="./03_functions.html#p_qWjz7fACpa"></a>Важно свойство на функцията, е че променливите създадени вътре в нея, включително и техните параметри, са само за тази функция. Това означава, например, че променливата <code>result</code> в <code>power</code> ще бъде на ново създадена всеки път, когато се извика функцията, и тези отделни инкарнации не си пречат една на друга.</p>
<p><a class="p_ident" id="p_l4ijyBIzn5" href="./03_functions.html#p_l4ijyBIzn5"></a>Тези локални променливи се отнасят само за параметри и променливи декларирани с ключовата дума <code>var</code> вътре в тялото на функцията. Променливи декларирани извън функцията се наричат глобални, защото те са видими в рамките на програмата. Възможно е да се получи достъп до тези променливи вътре във функцията до тогава, докато не се обявят локални променливи със същото име.</p>
<p><a class="p_ident" id="p_laUfBZCIN+" href="./03_functions.html#p_laUfBZCIN+"></a>Следният код демонстрира това. Той определя и извиква две функции, като и двете присвояват стойността на променливата <code>x</code>. Първата декларира променливата <code>x</code> локално и по-този начин променя само локалната променлива. Втората не декларира <code>x</code> локално и така препратката вътре в нея се отнася до глобалната променлива <code>x</code>, която е определена в горната част от примера.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_knj2FnR5PT" href="./03_functions.html#c_knj2FnR5PT"></a><span class="cm-keyword">var</span> <span class="cm-variable">x</span> <span class="cm-operator">=</span> <span class="cm-string">"outside"</span>;

<span class="cm-keyword">var</span> <span class="cm-variable">f1</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>() {
  <span class="cm-keyword">var</span> <span class="cm-def">x</span> <span class="cm-operator">=</span> <span class="cm-string">"inside f1"</span>;
};
<span class="cm-variable">f1</span>();
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">x</span>);
<span class="cm-comment">// → outside</span>

<span class="cm-keyword">var</span> <span class="cm-variable">f2</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>() {
  <span class="cm-variable">x</span> <span class="cm-operator">=</span> <span class="cm-string">"inside f2"</span>;
};
<span class="cm-variable">f2</span>();
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">x</span>);
<span class="cm-comment">// → inside f2</span></pre>
<p><a class="p_ident" id="p_xIVEBXHt8p" href="./03_functions.html#p_xIVEBXHt8p"></a>Това поведение помага за предотвратяване на случайно вмешателство между функции. Ако всички променливи бяха споделени от цялата програма, щеше да отнеме много време, за да се уверите, че няма име, което да се ползва за две различни цели. И ако се използва повторно името на променливата, може да видите странни ефекти от несвързан код със стойността на променливата. Чрез обработка на функционалните локални променливи, които съществуват само в рамките на функцията, езикът дава възможност да се четат и разбират функциите, като малки вселени, без да се налага да се притесняваме за целия код.</p>
<h2 id="scoping"><a class="h_ident" id="h_c/Ms2Ed/N0" href="./03_functions.html#h_c/Ms2Ed/N0"></a>Вложен  обхват</h2>
<p><a class="p_ident" id="p_tVHjFnvTdQ" href="./03_functions.html#p_tVHjFnvTdQ"></a>JavaScript различава не само глобални и локални променливи. Функциите могат да бъдат създадени в рамките на други функции, продукт на няколко степени на местоположението.</p>
<p><a class="p_ident" id="p_vMGu+OB1/f" href="./03_functions.html#p_vMGu+OB1/f"></a>Например, това е по-скоро безсмислен израз, да има функция и още две функции вътре в нея:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_/jAHBv01PE" href="./03_functions.html#c_/jAHBv01PE"></a><span class="cm-keyword">var</span> <span class="cm-variable">landscape</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>() {
  <span class="cm-keyword">var</span> <span class="cm-def">result</span> <span class="cm-operator">=</span> <span class="cm-string">""</span>;
  <span class="cm-keyword">var</span> <span class="cm-def">flat</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">size</span>) {
    <span class="cm-keyword">for</span> (<span class="cm-keyword">var</span> <span class="cm-def">count</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>; <span class="cm-variable-2">count</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">size</span>; <span class="cm-variable-2">count</span><span class="cm-operator">++</span>)
      <span class="cm-variable-2">result</span> <span class="cm-operator">+=</span> <span class="cm-string">"_"</span>;
  };
  <span class="cm-keyword">var</span> <span class="cm-def">mountain</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">size</span>) {
    <span class="cm-variable-2">result</span> <span class="cm-operator">+=</span> <span class="cm-string">"/"</span>;
    <span class="cm-keyword">for</span> (<span class="cm-keyword">var</span> <span class="cm-def">count</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>; <span class="cm-variable-2">count</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">size</span>; <span class="cm-variable-2">count</span><span class="cm-operator">++</span>)
      <span class="cm-variable-2">result</span> <span class="cm-operator">+=</span> <span class="cm-string">"'"</span>;
    <span class="cm-variable-2">result</span> <span class="cm-operator">+=</span> <span class="cm-string">"\\"</span>;
  };

  <span class="cm-variable-2">flat</span>(<span class="cm-number">3</span>);
  <span class="cm-variable-2">mountain</span>(<span class="cm-number">4</span>);
  <span class="cm-variable-2">flat</span>(<span class="cm-number">6</span>);
  <span class="cm-variable-2">mountain</span>(<span class="cm-number">1</span>);
  <span class="cm-variable-2">flat</span>(<span class="cm-number">1</span>);
  <span class="cm-keyword">return</span> <span class="cm-variable-2">result</span>;
};

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">landscape</span>());
<span class="cm-comment">// → ___/''''\______/'\_</span></pre>
<p><a class="p_ident" id="p_ZpZn9KZ+0W" href="./03_functions.html#p_ZpZn9KZ+0W"></a>Функциите <code>flat</code> и <code>mountain</code> могат да виждат променливата наречена result <code>result</code>, тъй като тя е в рамките на обвиващата функцията, където е определена. Но те не могат да видят другата променлива <code>count</code>,тъй като тя е извън техния обхват. Средата извън функцията <code>landscape</code> не вижда нито една от променливите, дефинирани вътре в <code>landscape</code>.</p>
<p><a class="p_ident" id="p_EGgZKAIsV1" href="./03_functions.html#p_EGgZKAIsV1"></a>Накратко, всеки локален обхват може да вижда всички локални възможности, които се съдържат в него. Наборът от променливи  видими вътре във функцията се определя от мястото на тази функция в текста на програмата. Всички променливи от блоковете около дефиницията на функцията са видими - в смисъл, както тези на функционалните органи в човешкото тяло, от най- високото ниво на програмата. Този подход към променливата видимост се нарича - лексикално определяне на обхвата.</p>
<p><a class="p_ident" id="p_obDE6s63wd" href="./03_functions.html#p_obDE6s63wd"></a>Хората, които имат опит с други езици за програмиране, може да очакват, че всеки блок код между скоби произвежда нова локална среда. Но в JavaScript, функциите са единственото нещо, което създава нов обхват. Вие имате право да ползвате свободно стоящите блокове по долу.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_Dbc5SebDan" href="./03_functions.html#c_Dbc5SebDan"></a><span class="cm-keyword">var</span> <span class="cm-variable">something</span> <span class="cm-operator">=</span> <span class="cm-number">1</span>;
{
  <span class="cm-keyword">var</span> <span class="cm-variable">something</span> <span class="cm-operator">=</span> <span class="cm-number">2</span>;
  <span class="cm-comment">// Do stuff with variable something...</span>
}
<span class="cm-comment">// Outside of the block again...</span></pre>
<p><a class="p_ident" id="p_hrFxt2jf+L" href="./03_functions.html#p_hrFxt2jf+L"></a>Но <code>something</code> вътре в блока се отнася до една и съща променлива, като тази извън блока. В действителност, въпреки, че са позволени такива блокове, те са полезни само за групата от тялото на <code>if</code> изрази или цикли.</p>
<p><a class="p_ident" id="p_uliI/PmHtG" href="./03_functions.html#p_uliI/PmHtG"></a>Ако това ви се струва странно, знайте, че не сте сами. Следващата версия на JavaScript ще въведе думата <code>let</code>, която работи, като <code>var</code>, но създава променлива, която е локална за блока, в който е оградена, а не за обвивката на функцията.</p>
<h2><a class="h_ident" id="h_y6WGSsYfER" href="./03_functions.html#h_y6WGSsYfER"></a>Функциите  като  стойности</h2>
<p><a class="p_ident" id="p_JDiT9B71/f" href="./03_functions.html#p_JDiT9B71/f"></a>Имената на променливите на функциите обикновено действат, като имена за конкретна част от програмата. Такива променливи се определят веднъж и никога не се променят. Това ги прави лесни за стартиране и трудни за объркване.</p>
<p><a class="p_ident" id="p_GmVFAjNN+C" href="./03_functions.html#p_GmVFAjNN+C"></a>Но те са различни. Със стойността на функцията може да се направи всичко, което може да се направи с другите стойности - можете да я използвате в произволни изрази, а не само да я извиквате. Възможно е да съхранявате стойността на функцията на ново място, да я давате като аргумент към функция и т.н. По същия начин, променлива, която притежава функцията, все още е обикновена променлива и може да присвои нова стойност, като това:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_WtNe7czRaM" href="./03_functions.html#c_WtNe7czRaM"></a><span class="cm-keyword">var</span> <span class="cm-variable">launchMissiles</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">value</span>) {
  <span class="cm-variable">missileSystem</span>.<span class="cm-property">launch</span>(<span class="cm-string">"now"</span>);
};
<span class="cm-keyword">if</span> (<span class="cm-variable">safeMode</span>)
  <span class="cm-variable">launchMissiles</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">value</span>) {<span class="cm-comment">/* do nothing */</span>};</pre>
<p><a class="p_ident" id="p_OGu288jvIV" href="./03_functions.html#p_OGu288jvIV"></a>В
<a href="./05_higher_order.html#higher_order">глава 5</a> ще обсъдим чудесните неща, които могат да се направят чрез предаване на стойности на функция от други функции.</p>
<h2><a class="h_ident" id="h_H2WKvqbgVY" href="./03_functions.html#h_H2WKvqbgVY"></a>Декларация  нотация</h2>
<p><a class="p_ident" id="p_nGYfaCN3iB" href="./03_functions.html#p_nGYfaCN3iB"></a>Налице е малко по-къс начин да се каже “<code>var square = function…</code>”. Думата <code>function</code> може да се използва в началото на протокола, като следното:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_cUsz8S76hF" href="./03_functions.html#c_cUsz8S76hF"></a><span class="cm-keyword">function</span> <span class="cm-variable">square</span>(<span class="cm-def">x</span>) {
  <span class="cm-keyword">return</span> <span class="cm-variable-2">x</span> <span class="cm-operator">*</span> <span class="cm-variable-2">x</span>;
}</pre>
<p><a class="p_ident" id="p_5wyYyAcHww" href="./03_functions.html#p_5wyYyAcHww"></a>Това е функция декларация.Твърдението (<em>statement</em>) дефинира променливата <code>square</code> да сочи към тази функция. До тук добре. Има една тънкост с тази форма на декларация на функция, обаче.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_ILJrRT16qt" href="./03_functions.html#c_ILJrRT16qt"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"The future says:"</span>, <span class="cm-variable">future</span>());

<span class="cm-keyword">function</span> <span class="cm-variable">future</span>() {
  <span class="cm-keyword">return</span> <span class="cm-string">"We STILL have no flying cars."</span>;
}</pre>
<p><a class="p_ident" id="p_MS2LV776VO" href="./03_functions.html#p_MS2LV776VO"></a>Този код работи, въпреки че функцията е определена по-долу от кода , който я използва. Това е така, защото декларациите на функции не са част от регулиращия поток на контрола, който се изпълнява от горе на долу. Те концептуално се преместват в най-горната част на обхвата (<em>scope</em>) и може да се използват от целия код в този обхват. Това понякога е полезно, защото ни дава свободата да пишем код по начин, който изглежда смислен, без да се притесняваме, че се налага да определяме всички функции горе при първото им използване.</p>
<p><a class="p_ident" id="p_RsXfJfQflM" href="./03_functions.html#p_RsXfJfQflM"></a>Какво се случва, когато поставим такава дефиниция на функция вътре в блока на (<code>if</code>) условие или цикъл? Е не правете това. Различните платформи на JavaScript в различните браузъри традиционно правят различни неща в такива ситуации и най- новите стандарти в действителност не го позволяват. Ако искате вашите програми да се държат последователно, използвайте само тези форми на дефиниране на функции в най-външния блок на функция или програма.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_wm1DV2942b" href="./03_functions.html#c_wm1DV2942b"></a><span class="cm-keyword">function</span> <span class="cm-variable">example</span>() {
  <span class="cm-keyword">function</span> <span class="cm-def">a</span>() {} <span class="cm-comment">// Okay</span>
  <span class="cm-keyword">if</span> (<span class="cm-variable">something</span>) {
    <span class="cm-keyword">function</span> <span class="cm-def">b</span>() {} <span class="cm-comment">// Danger!</span>
  }
}</pre>
<h2 id="stack"><a class="h_ident" id="h_D2Yui+mx6D" href="./03_functions.html#h_D2Yui+mx6D"></a>Стек  на  извикване</h2>
<p><a class="p_ident" id="p_6VtLMfnNTJ" href="./03_functions.html#p_6VtLMfnNTJ"></a>Ще бъде от полза  да разгледаме по-отблизо начина на контрола на потока посредством функция. Ето една проста програма, която прави няколко извиквания на функции:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_rZkAGv0+td" href="./03_functions.html#c_rZkAGv0+td"></a><span class="cm-keyword">function</span> <span class="cm-variable">greet</span>(<span class="cm-def">who</span>) {
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"Hello "</span> <span class="cm-operator">+</span> <span class="cm-variable-2">who</span>);
}
<span class="cm-variable">greet</span>(<span class="cm-string">"Harry"</span>);
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"Bye"</span>);</pre>
<p><a class="p_ident" id="p_vj7N9c3dLf" href="./03_functions.html#p_vj7N9c3dLf"></a>Изпълнението на тази програма  изглежда приблизително така: извиква <code>greet</code> контрола за да отиде в началото на тази функция (линия 2). Той призовава <code>console.log</code> (вградена функция във браузъра), който поема контрола и си върши работата, след това връща контрола на линия 2. После той достига края на функция <code>greet</code> и се връща на мястото откъдето се извиква на линия 4, след което призовава <code>console.log</code> отново.</p>
<p><a class="p_ident" id="p_l2J0qZcbr2" href="./03_functions.html#p_l2J0qZcbr2"></a>Можем да покажем потока на контрола схематично по следния начин:</p>
<pre>top
   greet
        console.log
   greet
top
   console.log
top</pre>
<p><a class="p_ident" id="p_0AzS0ZGujS" href="./03_functions.html#p_0AzS0ZGujS"></a>Тъй като функцията трябва да скочи обратно до мястото на повикването, когато тя се връща, компютъра трябва да помни контекста, с който е извикана функцията. В един от случаите <code>console.log</code> трябва да скочи обратно към <code>greet</code> функцията. В другия случай той се връща обратно в края на програмата.</p>
<p><a class="p_ident" id="p_PCO8aj4Plj" href="./03_functions.html#p_PCO8aj4Plj"></a>Мястото, където се намира в компютърната памет този контекст е стека на извикване. Всеки път, когато дадена функция се извиква, настоящия контекст се поставя на върха на стека. Когато функцията се връща, тя премахва горния контекст от стека и го използва за да продължи изпълнението.</p>
<p><a class="p_ident" id="p_HxxwtLgAhP" href="./03_functions.html#p_HxxwtLgAhP"></a>Съхраняването на този стек изисква пространство в паметта на компютъра. Когато стека порасне твърде голям, компютъра ще даде грешка от рода на “<em>out of stack space</em>” или “<em>too much recursion</em>”. Следният код илюстрира това чрез задаване на компютъра един наистина труден въпрос, който причинява безкрайно движение напред и на зад между две функции. Това щеше да е безкрайно, ако компютъра имаше един безкраен стек. Както и да е, ние ще изчерпим пространството или “взривим стека” (както се казва).</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_d9pZXzK1kY" href="./03_functions.html#c_d9pZXzK1kY"></a><span class="cm-keyword">function</span> <span class="cm-variable">chicken</span>() {
  <span class="cm-keyword">return</span> <span class="cm-variable">egg</span>();
}
<span class="cm-keyword">function</span> <span class="cm-variable">egg</span>() {
  <span class="cm-keyword">return</span> <span class="cm-variable">chicken</span>();
}
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">chicken</span>() <span class="cm-operator">+</span> <span class="cm-string">" came first."</span>);
<span class="cm-comment">// → ??</span></pre>
<h2><a class="h_ident" id="h_1pGtRjrCUp" href="./03_functions.html#h_1pGtRjrCUp"></a>Допълнителни  аргументи</h2>
<p><a class="p_ident" id="p_npZ63wzfMQ" href="./03_functions.html#p_npZ63wzfMQ"></a>Следният код е разрешен и се изпълнява без всякакъв проблем:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_N7xNoevYVv" href="./03_functions.html#c_N7xNoevYVv"></a><span class="cm-variable">alert</span>(<span class="cm-string">"Hello"</span>, <span class="cm-string">"Good Evening"</span>, <span class="cm-string">"How do you do?"</span>);</pre>
<p><a class="p_ident" id="p_IpeGOJUHty" href="./03_functions.html#p_IpeGOJUHty"></a>Функцията <code>alert</code> официално приема само един аргумент. И все пак извикана по този начин, тя не се оплаква. Тя просто игнорира останалите аргументи и показва само “Hello”.</p>
<p><a class="p_ident" id="p_MSukyYxa3X" href="./03_functions.html#p_MSukyYxa3X"></a>JavaScript е изключително широко скроен за броя на аргументите, които може да приеме една функция. Ако приеме твърде много останалите се игнорират. Ако приеме твърде малко вместо липсващите просто дава стойност <code>undefined</code>.</p>
<p><a class="p_ident" id="p_U01Tix9/O1" href="./03_functions.html#p_U01Tix9/O1"></a>Недостатъкът на това е, че е възможно да приеме случайно грешен брой аргументи и никой няма да ви каже за това.</p>
<p id="power"><a class="p_ident" id="p_1HVJeCtkjS" href="./03_functions.html#p_1HVJeCtkjS"></a>Обърнато, това поведение може да се използва за да се направи функция, която да взема по избор аргументи. Например следната версия на <code>power</code> може да се извика с един или два аргумента, като в този случай се приема експонентата да бъде две, функцията се държи, като <code>square</code>.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_Qk4NJmNgHK" href="./03_functions.html#c_Qk4NJmNgHK"></a><span class="cm-keyword">function</span> <span class="cm-variable">power</span>(<span class="cm-def">base</span>, <span class="cm-def">exponent</span>) {
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">exponent</span> <span class="cm-operator">==</span> <span class="cm-atom">undefined</span>)
    <span class="cm-variable-2">exponent</span> <span class="cm-operator">=</span> <span class="cm-number">2</span>;
  <span class="cm-keyword">var</span> <span class="cm-def">result</span> <span class="cm-operator">=</span> <span class="cm-number">1</span>;
  <span class="cm-keyword">for</span> (<span class="cm-keyword">var</span> <span class="cm-def">count</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>; <span class="cm-variable-2">count</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">exponent</span>; <span class="cm-variable-2">count</span><span class="cm-operator">++</span>)
    <span class="cm-variable-2">result</span> <span class="cm-operator">*=</span> <span class="cm-variable-2">base</span>;
  <span class="cm-keyword">return</span> <span class="cm-variable-2">result</span>;
}

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">power</span>(<span class="cm-number">4</span>));
<span class="cm-comment">// → 16</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">power</span>(<span class="cm-number">4</span>, <span class="cm-number">3</span>));
<span class="cm-comment">// → 64</span></pre>
<p><a class="p_ident" id="p_HXV4vPfIcZ" href="./03_functions.html#p_HXV4vPfIcZ"></a>В <a href="./04_data.html#arguments_object">следващата глава</a> ще видим начин, по който тялото на функцията може да получи най-точния списък с аргументи, които може да приеме. Това е полезно, тъй като дава възможност функцията да приема редица аргументи. Например, <code>console.log</code> се възползва от това да извежда всички стойности, които и се подадат.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_rwDFIqBrDl" href="./03_functions.html#c_rwDFIqBrDl"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"R"</span>, <span class="cm-number">2</span>, <span class="cm-string">"D"</span>, <span class="cm-number">2</span>);
<span class="cm-comment">// → R 2 D 2</span></pre>
<h2><a class="h_ident" id="h_hOd+yVxaku" href="./03_functions.html#h_hOd+yVxaku"></a>Закриване</h2>
<p><a class="p_ident" id="p_Y88pfbKskW" href="./03_functions.html#p_Y88pfbKskW"></a>Възможността да се третират функциите, като стойности, съчетано с факта, че локалните променливи се пресъздават всеки път, когато се извиква дадена функция, води до интересен въпрос. Какво се случва с локалните променливи, когато функцията се извиква и ги създава, но не е активна?</p>
<p><a class="p_ident" id="p_GDGcocAd5v" href="./03_functions.html#p_GDGcocAd5v"></a>Следният код показва пример на това. Той определя функцията <code>wrapValue</code>, която създава локална променлива. След това връща функция, която има достъп и връща тази локална променлива:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_VI86FLVzPw" href="./03_functions.html#c_VI86FLVzPw"></a><span class="cm-keyword">function</span> <span class="cm-variable">wrapValue</span>(<span class="cm-def">n</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">localVariable</span> <span class="cm-operator">=</span> <span class="cm-variable-2">n</span>;
  <span class="cm-keyword">return</span> <span class="cm-keyword">function</span>() { <span class="cm-keyword">return</span> <span class="cm-variable-2">localVariable</span>; };
}

<span class="cm-keyword">var</span> <span class="cm-variable">wrap1</span> <span class="cm-operator">=</span> <span class="cm-variable">wrapValue</span>(<span class="cm-number">1</span>);
<span class="cm-keyword">var</span> <span class="cm-variable">wrap2</span> <span class="cm-operator">=</span> <span class="cm-variable">wrapValue</span>(<span class="cm-number">2</span>);
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">wrap1</span>());
<span class="cm-comment">// → 1</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">wrap2</span>());
<span class="cm-comment">// → 2</span></pre>
<p><a class="p_ident" id="p_Sa1QP5wNdF" href="./03_functions.html#p_Sa1QP5wNdF"></a>Това е разрешено и работи, както бихте се надявали - променливата все още може да е достъпна. В действителност, няколко екземпляра на променливата може да са живи и сега, което е още една добра илюстрация на концепцията, че локалните променливи наистина се пресъздават за всяко различно извикване и не се тъпчат една върху друга.</p>
<p><a class="p_ident" id="p_psCFtoqbmB" href="./03_functions.html#p_psCFtoqbmB"></a>Това свойство за обръщане към конкретен случай на локални променливи в обхвата на функцията се нарича закриване. Функцията, която затваря няколко локални променливи се нарича закриваща. Това поведение не само ви освобождава от необходимостта да се притеснявате за живота на променливите, но също така дава възможност за някое творческо използване на стойности на функция.</p>
<p><a class="p_ident" id="p_YtnB1+ZhQb" href="./03_functions.html#p_YtnB1+ZhQb"></a>С лека промяна, можем да превърнем предишния пример в начин за създаване на функции, които се размножават от произволен номер.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_eAJWW0NEFo" href="./03_functions.html#c_eAJWW0NEFo"></a><span class="cm-keyword">function</span> <span class="cm-variable">multiplier</span>(<span class="cm-def">factor</span>) {
  <span class="cm-keyword">return</span> <span class="cm-keyword">function</span>(<span class="cm-def">number</span>) {
    <span class="cm-keyword">return</span> <span class="cm-variable-2">number</span> <span class="cm-operator">*</span> <span class="cm-variable-2">factor</span>;
  };
}

<span class="cm-keyword">var</span> <span class="cm-variable">twice</span> <span class="cm-operator">=</span> <span class="cm-variable">multiplier</span>(<span class="cm-number">2</span>);
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">twice</span>(<span class="cm-number">5</span>));
<span class="cm-comment">// → 10</span></pre>
<p><a class="p_ident" id="p_S9BiBCwEsz" href="./03_functions.html#p_S9BiBCwEsz"></a>Изричното <code>localVariable</code> от <code>wrapValue</code> - примера, не е необходимо, тъй като параметър е самата локална променлива.</p>
<p><a class="p_ident" id="p_jRZH0MnxB1" href="./03_functions.html#p_jRZH0MnxB1"></a>Мисля, че програми като тази изискват известна практика. Един добър мисловен модел е да се мисли за ключовата дума <code>function</code>, като “замразяване” на код в тялото и, и опаковане в пакет(стойност на функция). Така че, когато четете <code>return function(...) {...}</code>,мислете за това връщане, като манипулатор за парче от изчисленията, замразени за по-нататъшна употреба.</p>
<p><a class="p_ident" id="p_SZYpNI2fMu" href="./03_functions.html#p_SZYpNI2fMu"></a>В примера, <code>multiplier</code> връща замразено парче код, който получава съхраняваната в <code>twice</code> variable. Последният ред код извиква стойността на тази променлива, вкарвайки я на замразения код (<code>return number * factor;</code>) за да се активира. Функцията все още има достъп до променливата <code>factor</code> от извикването на <code>multiplier</code>, която го създава, и в допълнение, тя получава достъп до аргумента, когато става размразяването - 5 , чрез своя <code>number</code> параметър.</p>
<h2><a class="h_ident" id="h_jxl1p970Fy" href="./03_functions.html#h_jxl1p970Fy"></a>Рекурсия</h2>
<p><a class="p_ident" id="p_nvfJ5Y3yW4" href="./03_functions.html#p_nvfJ5Y3yW4"></a>Много е добре за една функция да се извиква, толкова дълго, докато се грижи да не препълни стека. Функцията, която извиква себе си се нарича рекурсивна. Рекурсията позволява някои функции да бъдат написани в различен стил. Вземете, например, това алтернативно изпълнение на <code>power</code>:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_5l4GeQmC7i" href="./03_functions.html#c_5l4GeQmC7i"></a><span class="cm-keyword">function</span> <span class="cm-variable">power</span>(<span class="cm-def">base</span>, <span class="cm-def">exponent</span>) {
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">exponent</span> <span class="cm-operator">==</span> <span class="cm-number">0</span>)
    <span class="cm-keyword">return</span> <span class="cm-number">1</span>;
  <span class="cm-keyword">else</span>
    <span class="cm-keyword">return</span> <span class="cm-variable-2">base</span> <span class="cm-operator">*</span> <span class="cm-variable">power</span>(<span class="cm-variable-2">base</span>, <span class="cm-variable-2">exponent</span> <span class="cm-operator">-</span> <span class="cm-number">1</span>);
}

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">power</span>(<span class="cm-number">2</span>, <span class="cm-number">3</span>));
<span class="cm-comment">// → 8</span></pre>
<p><a class="p_ident" id="p_/7VYZ2mLWF" href="./03_functions.html#p_/7VYZ2mLWF"></a>Това е по-скоро близо до математическото степенуване и може би описва концепцията по по-елегантен начин, от колкото един цикъл може да го направи. Функцията извиква себе си няколко пъти с различни аргументи, за да се постигне повтаряемост на размножаването.</p>
<p><a class="p_ident" id="p_gL3pzy469i" href="./03_functions.html#p_gL3pzy469i"></a>Но това изпълнение има един важен проблем: в типични JavaScript приложения, това е около 10 пъти по-бавно от цикъл версия. Работата чрез цикъл е много по-бърза, от колкото извикването на функцията няколко пъти.</p>
<p><a class="p_ident" id="p_uMHI/JnzZZ" href="./03_functions.html#p_uMHI/JnzZZ"></a>Дилемата на скоростта спрямо елегантността е интересна. Можете да я погледнете, като едно продължение между човека и машината, за лекотата на употребата. Почти всяка програма може да се направи по-бърза, което я прави по-голяма и по-сложна. Програмиста трябва да вземе решение за подходящо равновесие.</p>
<p><a class="p_ident" id="p_3VspvG7sBY" href="./03_functions.html#p_3VspvG7sBY"></a>В случая <a href="./03_functions.html#power">по-рано</a> на функцията <code>power</code>, грубоватата (цикъл) версия все още е сравнително проста и лесна за четене. Тогава няма много смисъл да се заменя с рекурсивна версия. Често обаче, една програма се занимава с такива сложни понятия, че се налага да се отказва някоя ефективност за да се направи програмата по-ясна, това е атрактивен избор.</p>
<p><a class="p_ident" id="p_WkiJSoduhy" href="./03_functions.html#p_WkiJSoduhy"></a>Основно правило на много програмисти и с което съм съгласен с цялото си сърце, е да не се тревожим за ефективността, докато не знаем със сигурност, че програмата е твърде бавна. Ако е така, разберете кои части отнемат най-много време и започнете да обменяте елегантност за ефективност в тези части.</p>
<p><a class="p_ident" id="p_KHwfQ0yZv2" href="./03_functions.html#p_KHwfQ0yZv2"></a>Разбира се, това не означава, че човек трябва да игнорира производителноста напълно. В много случаи, като например функцията <code>power</code>, не е много просто да се направи елегантният подход. И понякога опитен програмист може да види веднага, че един прост подход никога няма да бъде достатъчно бърз.</p>
<p><a class="p_ident" id="p_l9EEqdrDJ+" href="./03_functions.html#p_l9EEqdrDJ+"></a>Причината, както съм подчертавал е, че изненадващо много програмисти фанатично започват да се съсредоточават върху ефективността, дори в най-малките подробности. Резултатът е по-големи, по-сложни, а често и по-малко правилни програми, които обикновено работят незначително по-бързо и отнемат повече време да се пишат, от колкото техните по-ясни еквиваленти.</p>
<p><a class="p_ident" id="p_IWOXsklZbt" href="./03_functions.html#p_IWOXsklZbt"></a>Но рекурсията не винаги е просто по-ефективна алтернатива от цикъла. Някои от проблемите са много по-лесни за решаване с рекурсия, от колкото с цикъл. Най-често това са проблеми, които изискват проучване или преработване на някои “разклонения”, всяко от които може да се насочи отново в други разклонения.</p>
<p id="recursive_puzzle"><a class="p_ident" id="p_KNlnW1VpW2" href="./03_functions.html#p_KNlnW1VpW2"></a>Помислете за този пъзел: като се започне от цифрата 1 и на няколко пъти добавяте 5 или умножавате по 3, могат да бъдат произведени безкрайно количество от нови номера. Как бихте написали функция, която по един номер, се опитва да намери поредицата от такива събирания и умножения, които произвеждат този номер? Например за номер 13 може да бъде постигнат, като първо се умножава по 3 и след това се добавя 5, докато не надхвърли номер 15.</p>
<p><a class="p_ident" id="p_ca4W5yMbty" href="./03_functions.html#p_ca4W5yMbty"></a>Това е рекурсивното решение:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_x9E2vbHeNP" href="./03_functions.html#c_x9E2vbHeNP"></a><span class="cm-keyword">function</span> <span class="cm-variable">findSolution</span>(<span class="cm-def">target</span>) {
  <span class="cm-keyword">function</span> <span class="cm-def">find</span>(<span class="cm-def">start</span>, <span class="cm-def">history</span>) {
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">start</span> <span class="cm-operator">==</span> <span class="cm-variable-2">target</span>)
      <span class="cm-keyword">return</span> <span class="cm-variable-2">history</span>;
    <span class="cm-keyword">else</span> <span class="cm-keyword">if</span> (<span class="cm-variable-2">start</span> <span class="cm-operator">&gt;</span> <span class="cm-variable-2">target</span>)
      <span class="cm-keyword">return</span> <span class="cm-atom">null</span>;
    <span class="cm-keyword">else</span>
      <span class="cm-keyword">return</span> <span class="cm-variable-2">find</span>(<span class="cm-variable-2">start</span> <span class="cm-operator">+</span> <span class="cm-number">5</span>, <span class="cm-string">"("</span> <span class="cm-operator">+</span> <span class="cm-variable-2">history</span> <span class="cm-operator">+</span> <span class="cm-string">" + 5)"</span>) <span class="cm-operator">||</span>
             <span class="cm-variable-2">find</span>(<span class="cm-variable-2">start</span> <span class="cm-operator">*</span> <span class="cm-number">3</span>, <span class="cm-string">"("</span> <span class="cm-operator">+</span> <span class="cm-variable-2">history</span> <span class="cm-operator">+</span> <span class="cm-string">" * 3)"</span>);
  }
  <span class="cm-keyword">return</span> <span class="cm-variable-2">find</span>(<span class="cm-number">1</span>, <span class="cm-string">"1"</span>);
}

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">findSolution</span>(<span class="cm-number">24</span>));
<span class="cm-comment">// → (((1 * 3) + 5) * 3)</span></pre>
<p><a class="p_ident" id="p_fhaqzpNMMF" href="./03_functions.html#p_fhaqzpNMMF"></a>Имайте в предвид, че тази програма не е задължително да намери най-кратката последователност на операциите. Ние сме доволни, ако намери всяка последователност за всички.</p>
<p><a class="p_ident" id="p_NWnjWt3C1V" href="./03_functions.html#p_NWnjWt3C1V"></a>Не е задължително да очакваме веднага да разберем как работи . Но нека да поработим с нея, тъй като тя дава възможност за чудесно упражнение в рекурсивното мислене.</p>
<p><a class="p_ident" id="p_TdwUEI2F58" href="./03_functions.html#p_TdwUEI2F58"></a>Вътрешната функция <code>find</code> прави действителна рекурсия. Тя взема два аргумента- текущия номер и <em>string</em>, който записва как се достига до този номер и връща <em>string</em>, който показва как се стига до целта или <code>null</code>.</p>
<p><a class="p_ident" id="p_QSzesXs0Kg" href="./03_functions.html#p_QSzesXs0Kg"></a>За да направи това, функцията изпълнява едно от следните три действия. Ако текущия(<em>current</em>) номер е номера на целта(<em>target</em>), текущата история(<em>history</em>) е просто начин за постигане на тази цел, така че просто се връща с <em>return</em>. Ако текущия номер е по-голям от целта, няма смисъл от по-нататъшното разглеждане на тази история, тъй като събирането и умножението, ще направят номера по-голям. И на края, ако все още сме далеч от целта, функцията се опитва от двете възможности, които започват от сегашния брой, извикваща себе си два пъти по веднъж за всеки от следващите стъпки. Ако първата връща нещо, което не е <code>null</code>, тя се връща за втората. В противен случай, на второто извикване се връща - независимо от това дали тя произвежда <em>string</em> или <code>null</code>.</p>
<p><a class="p_ident" id="p_QvX/6dUvST" href="./03_functions.html#p_QvX/6dUvST"></a>За да разберем по-добре как функцията произвежда ефекта, който търсим, нека да разгледаме всички повиквания към <code>find</code>, които са направени при търсене на решението за броя 13.</p>
<pre>find(1, "1")
  find(6, "(1 + 5)")
    find(11, "((1 + 5) + 5)")
      find(16, "(((1 + 5) + 5) + 5)")
        too big
      find(33, "(((1 + 5) + 5) * 3)")
        too big
    find(18, "((1 + 5) * 3)")
      too big
  find(3, "(1 * 3)")
    find(8, "((1 * 3) + 5)")
      find(13, "(((1 * 3) + 5) + 5)")
        found!</pre>
<p><a class="p_ident" id="p_acU+LwVT0i" href="./03_functions.html#p_acU+LwVT0i"></a>Изместването на вътре предполага, дълбочината на стека за повикване. Първият <code>find</code> извиква себе си два пъти, за да проучи решенията, които започват с <code>(1 + 5)</code> и <code>(1 * 3)</code>. Първото повикване се опитва да намери решение, което започва с <code>(1 + 5)</code> и с помощта на рекурсия, изследва всеки отговор, който се получава- число по-малко или равно на целевия номер. Тъй като не намира номер, който да улучи целта, той връща <code>null</code> обратно, към първото извикване. Там оператора <code>||</code> води извикването към <code>(1 * 3)</code>.
  Това търсене има повече късмет, защото първото рекурсивно извикване, улучва целевия брой 13.Това най-вътрешно рекурсивно извикване, връща string и всеки един от <code>||</code> операторите в междинните нива, като един string и в крайна сметка връща нашето решение.</p>
<h2><a class="h_ident" id="h_eVDWIAuyBK" href="./03_functions.html#h_eVDWIAuyBK"></a>Нарастване  на  функции</h2>
<p><a class="p_ident" id="p_FDJnaYNBaa" href="./03_functions.html#p_FDJnaYNBaa"></a>Има повече от два естествени начина функциите да бъдат въведени в програмите.</p>
<p><a class="p_ident" id="p_zNh7WEzSLI" href="./03_functions.html#p_zNh7WEzSLI"></a>Първият е написването на много подобен код няколко пъти. Ние искаме да избегнем това, тъй като повече код означава повече възможности за грешки и повече материал за четене от хора опитващи се да разберат програмата. Така че, ако се повтаря функционалноста, намери добро име за нея и я сложи във функция.</p>
<p><a class="p_ident" id="p_HJxU0H/STP" href="./03_functions.html#p_HJxU0H/STP"></a>Вторият начин е, да видите дали имате нужда от някоя функция, която не е написана още и напишете своя собствена функция. Ще започнете от названието на функцията, а след това напишете нейното тяло. Може дори да започнете да пишете код, който използва функцията преди да определите самата функция.</p>
<p><a class="p_ident" id="p_7YCpyNM9KP" href="./03_functions.html#p_7YCpyNM9KP"></a>Колко трудно е да се намери подходящо име за функция е добър показател за това, колко ясна е концепцията, която се опитвате да приключите. Нека минем през един пример.</p>
<p><a class="p_ident" id="p_NB82EwGY1X" href="./03_functions.html#p_NB82EwGY1X"></a>Ние искаме да напишем програма, която отпечатва две числа - броят на кравите и пилетата във ферма, с думите <code>Cows</code> и <code>Chickens</code> и нули преди числото, така че винаги да е три цифри.</p>
<pre>007 Cows
011 Chickens</pre>
<p><a class="p_ident" id="p_Vjv/1yrqWB" href="./03_functions.html#p_Vjv/1yrqWB"></a>Ясно е, че се пита за функция с два аргумента. Да кодираме:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_3FZcO2H/2C" href="./03_functions.html#c_3FZcO2H/2C"></a><span class="cm-keyword">function</span> <span class="cm-variable">printFarmInventory</span>(<span class="cm-def">cows</span>, <span class="cm-def">chickens</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">cowString</span> <span class="cm-operator">=</span> <span class="cm-variable">String</span>(<span class="cm-variable-2">cows</span>);
  <span class="cm-keyword">while</span> (<span class="cm-variable-2">cowString</span>.<span class="cm-property">length</span> <span class="cm-operator">&lt;</span> <span class="cm-number">3</span>)
    <span class="cm-variable-2">cowString</span> <span class="cm-operator">=</span> <span class="cm-string">"0"</span> <span class="cm-operator">+</span> <span class="cm-variable-2">cowString</span>;
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable-2">cowString</span> <span class="cm-operator">+</span> <span class="cm-string">" Cows"</span>);
  <span class="cm-keyword">var</span> <span class="cm-def">chickenString</span> <span class="cm-operator">=</span> <span class="cm-variable">String</span>(<span class="cm-variable-2">chickens</span>);
  <span class="cm-keyword">while</span> (<span class="cm-variable-2">chickenString</span>.<span class="cm-property">length</span> <span class="cm-operator">&lt;</span> <span class="cm-number">3</span>)
    <span class="cm-variable-2">chickenString</span> <span class="cm-operator">=</span> <span class="cm-string">"0"</span> <span class="cm-operator">+</span> <span class="cm-variable-2">chickenString</span>;
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable-2">chickenString</span> <span class="cm-operator">+</span> <span class="cm-string">" Chickens"</span>);
}
<span class="cm-variable">printFarmInventory</span>(<span class="cm-number">7</span>, <span class="cm-number">11</span>);</pre>
<p><a class="p_ident" id="p_iRp07gdia7" href="./03_functions.html#p_iRp07gdia7"></a>Добавянето на <code>.length</code>след стойността на <em>string</em>, ще ни даде дължината на този <em>string</em>. По този начин <code>while</code> цикъла пази добавянето на нули пред номера на <em>string</em>, докато той е дълъг най- малко три знака.</p>
<p><a class="p_ident" id="p_hlBZoLuLCG" href="./03_functions.html#p_hlBZoLuLCG"></a>Мисията е изпълнена! Но то точно, когато сме готови да изпратим на земеделския производител кода (заедно с яка фактура, разбира се), той се обажда и казва, че започнал да гледа и прасета и не можем ли ние да разширим софтуера да отпечатва и прасета?</p>
<p><a class="p_ident" id="p_h9O1PaViIa" href="./03_functions.html#p_h9O1PaViIa"></a>Сигурно можем. Но точно, като сме в процес на копиране и вмъкване на тези четири линии отново, да спрем и се замислим. Дали има по-добър начин. Ето един първи опит:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_MyKuhBUtsp" href="./03_functions.html#c_MyKuhBUtsp"></a><span class="cm-keyword">function</span> <span class="cm-variable">printZeroPaddedWithLabel</span>(<span class="cm-def">number</span>, <span class="cm-def">label</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">numberString</span> <span class="cm-operator">=</span> <span class="cm-variable">String</span>(<span class="cm-variable-2">number</span>);
  <span class="cm-keyword">while</span> (<span class="cm-variable-2">numberString</span>.<span class="cm-property">length</span> <span class="cm-operator">&lt;</span> <span class="cm-number">3</span>)
    <span class="cm-variable-2">numberString</span> <span class="cm-operator">=</span> <span class="cm-string">"0"</span> <span class="cm-operator">+</span> <span class="cm-variable-2">numberString</span>;
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable-2">numberString</span> <span class="cm-operator">+</span> <span class="cm-string">" "</span> <span class="cm-operator">+</span> <span class="cm-variable-2">label</span>);
}

<span class="cm-keyword">function</span> <span class="cm-variable">printFarmInventory</span>(<span class="cm-def">cows</span>, <span class="cm-def">chickens</span>, <span class="cm-def">pigs</span>) {
  <span class="cm-variable">printZeroPaddedWithLabel</span>(<span class="cm-variable-2">cows</span>, <span class="cm-string">"Cows"</span>);
  <span class="cm-variable">printZeroPaddedWithLabel</span>(<span class="cm-variable-2">chickens</span>, <span class="cm-string">"Chickens"</span>);
  <span class="cm-variable">printZeroPaddedWithLabel</span>(<span class="cm-variable-2">pigs</span>, <span class="cm-string">"Pigs"</span>);
}

<span class="cm-variable">printFarmInventory</span>(<span class="cm-number">7</span>, <span class="cm-number">11</span>, <span class="cm-number">3</span>);</pre>
<p><a class="p_ident" id="p_6/4BxnwWvK" href="./03_functions.html#p_6/4BxnwWvK"></a>Работи! Но това име <code>printZeroPaddedWithLabel</code> е малко неудобно. То смесва три неща - печат, нула-подплънка и добавяне на етикет в една функция.</p>
<p><a class="p_ident" id="p_/zEyox400N" href="./03_functions.html#p_/zEyox400N"></a>Вместо премахване на повтарящата се част от нашата програма за търговия на едро, да опитаме да изберем една единствена концепция.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_BF/ji546Xh" href="./03_functions.html#c_BF/ji546Xh"></a><span class="cm-keyword">function</span> <span class="cm-variable">zeroPad</span>(<span class="cm-def">number</span>, <span class="cm-def">width</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">string</span> <span class="cm-operator">=</span> <span class="cm-variable">String</span>(<span class="cm-variable-2">number</span>);
  <span class="cm-keyword">while</span> (<span class="cm-variable-2">string</span>.<span class="cm-property">length</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">width</span>)
    <span class="cm-variable-2">string</span> <span class="cm-operator">=</span> <span class="cm-string">"0"</span> <span class="cm-operator">+</span> <span class="cm-variable-2">string</span>;
  <span class="cm-keyword">return</span> <span class="cm-variable-2">string</span>;
}

<span class="cm-keyword">function</span> <span class="cm-variable">printFarmInventory</span>(<span class="cm-def">cows</span>, <span class="cm-def">chickens</span>, <span class="cm-def">pigs</span>) {
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">zeroPad</span>(<span class="cm-variable-2">cows</span>, <span class="cm-number">3</span>) <span class="cm-operator">+</span> <span class="cm-string">" Cows"</span>);
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">zeroPad</span>(<span class="cm-variable-2">chickens</span>, <span class="cm-number">3</span>) <span class="cm-operator">+</span> <span class="cm-string">" Chickens"</span>);
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">zeroPad</span>(<span class="cm-variable-2">pigs</span>, <span class="cm-number">3</span>) <span class="cm-operator">+</span> <span class="cm-string">" Pigs"</span>);
}

<span class="cm-variable">printFarmInventory</span>(<span class="cm-number">7</span>, <span class="cm-number">16</span>, <span class="cm-number">3</span>);</pre>
<p><a class="p_ident" id="p_GAKg8ZzVbj" href="./03_functions.html#p_GAKg8ZzVbj"></a>Функция с очевидно хубавото име, като <code>zeroPad</code> прави по-лесно за някой, който чете кода, да разбере какво прави той. Това е полезно в повече ситуации, от колкото само тази специална програма. Например може да го използвате за да отпечатате добре подравнени таблици от числа.</p>
<p><a class="p_ident" id="p_JtW9SrsIA6" href="./03_functions.html#p_JtW9SrsIA6"></a>Колко интелигентна и гъвкава трябва да бъде нашата функция? Можем да напишем ужасно проста функция, която просто подава номера, широки три знака на сложен форматиращ генератор за номера, който се занимава с дробни и отрицателни числа, подравняване на точки и т.н.</p>
<p><a class="p_ident" id="p_EWzoSpSKwh" href="./03_functions.html#p_EWzoSpSKwh"></a>Полезен принцип е да не се добавя интелигентност, освен ако не сте абсолютно сигурни, че се нуждаете от нея. Може да се изкушите да пишете общи рамки за всяка малка функционалност на която попаднете. Не се поддавайте на това желание. Ще свършите някаква реална работа, но вие ще се окажете пред написването на много код, който никога няма да използвате.</p>
<h2 id="pure"><a class="h_ident" id="h_EdyBGBF6y/" href="./03_functions.html#h_EdyBGBF6y/"></a>Функции  и  странични  ефекти</h2>
<p><a class="p_ident" id="p_Yv2DEaMWee" href="./03_functions.html#p_Yv2DEaMWee"></a>Функциите могат да бъдат разделени, на тези които се извикват за техните странични ефекти и онези, които се извикват за връщане на стойност.(Въпреки, че това определено е възможно, една функция да има и странични ефекти и да връща стойност.)</p>
<p><a class="p_ident" id="p_NoFe+XFM0N" href="./03_functions.html#p_NoFe+XFM0N"></a>Функцията в примера с фермата, <code>printZeroPaddedWithLabel</code> извиква нейния страничен ефект: тя отпечатва ред. Във втората версия, <code>zeroPad</code> се извиква нейното връщане на стойност. Не е съвпадение, че втория вариант е полезен в повече ситуации от първия. Функциите, които създават стойности са по-лесни за комбиниране по нов начин, отколкото функции, които пряко изпълняват странични ефекти.</p>
<p><a class="p_ident" id="p_jtr5vcWSkM" href="./03_functions.html#p_jtr5vcWSkM"></a>Чистата функция е специфичен вид функция за производство на стойност, която не само няма странични ефекти, но и не разчита на странични ефекти от други кодове, например, тя не чете глобални променливи, които по някога се променят от други кодове.Чистата функция има хубавото качество, когато е извикана със същите аргументи, тя винаги да произвежда една и съща стойност( и не прави нищо друго) . Това се прави за да разсъждава лесно. Извикването на такава функция може да бъде заместено от нейния умствен резултат, без да се променя смисъла на кодекса. Когато не сте сигурни, че чистата функция работи правилно, може да я тествате, като просто я извикате и знам, че ако тя работи в този контекст, ще работи във всеки друг контекст. <em>Nonpure</em> функциите могат да връщат различни стойности на базата на всички видове фактори и имат странични ефекти, които могат да бъдат трудно тествани и измислени.</p>
<p><a class="p_ident" id="p_BQs40ApxUr" href="./03_functions.html#p_BQs40ApxUr"></a>И все пак, няма нужда да се чувствате зле, когато пишете функции, които не са чисти или водят свещена война срещу вашия код. Страничните ефекти често са полезни. Може да има начин да се напише чиста версия на <code>console.log</code>, но <code>console.log</code> със сигурност е полезна. Някои операции са също по-лесни да се изразят по ефективен начин, когато използваме странични ефекти, така че скоростта на изчисленията може да бъде причина за избягване на чистотата.</p>
<h2><a class="h_ident" id="h_ErccPg/l98" href="./03_functions.html#h_ErccPg/l98"></a>Резюме</h2>
<p><a class="p_ident" id="p_mvDkl8+Eqg" href="./03_functions.html#p_mvDkl8+Eqg"></a>Тази глава ви научи как да пишете свои собствени функции. Функция е ключова дума, която когато се използва като израз, може да създаде стойност функция. Когато се използва, като твърдение, тя може да се използва за деклариране на променлива, която да даде на функция, като нейна стойност.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_YPhf/PZ0FA" href="./03_functions.html#c_YPhf/PZ0FA"></a><span class="cm-comment">// Create a function value f</span>
<span class="cm-keyword">var</span> <span class="cm-variable">f</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">a</span>) {
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable-2">a</span> <span class="cm-operator">+</span> <span class="cm-number">2</span>);
};

<span class="cm-comment">// Declare g to be a function</span>
<span class="cm-keyword">function</span> <span class="cm-variable">g</span>(<span class="cm-def">a</span>, <span class="cm-def">b</span>) {
  <span class="cm-keyword">return</span> <span class="cm-variable-2">a</span> <span class="cm-operator">*</span> <span class="cm-variable-2">b</span> <span class="cm-operator">*</span> <span class="cm-number">3.5</span>;
}</pre>
<p><a class="p_ident" id="p_kjcgm0IFsi" href="./03_functions.html#p_kjcgm0IFsi"></a>Ключов аспект в разбирането на функции е разбирането на локалните приложни обхвати. Параметри и променливи, декларирани в тялото на функцията са локални за функцията, пресъздадени всеки път, когато функцията се извиква и не се виждат от вън. Функции обявени в други функции имат достъп до локалния характер на външната функция.</p>
<p><a class="p_ident" id="p_Iv45OfFBke" href="./03_functions.html#p_Iv45OfFBke"></a>Разделянето на задачите, които изпълнява програмата в различни функции е от полза. Няма нужда от много повтаряне за да разберете, че  функциите могат да направят програмата, по-разбираема чрез групиране на код в концептуални парчета, по същия начин, както глави и раздели съдействат за организиране на обикновен текст.</p>
<h2><a class="h_ident" id="h_TcUD2vzyMe" href="./03_functions.html#h_TcUD2vzyMe"></a>Упражнения</h2>
<h3><a class="h_ident" id="h_XTmO7z7MPq" href="./03_functions.html#h_XTmO7z7MPq"></a>Минимум</h3>
<p><a class="p_ident" id="p_aW/Uoj4mDd" href="./03_functions.html#p_aW/Uoj4mDd"></a>В <a href="./02_program_structure.html#return_values">предишната глава</a> въведохме стандартната функция <code>Math.min</code> която връща най-малкия аргумент. Можем да го направим сами сега. Напишете функция <code>min</code>, която взема два аргумента и връща по-малкия.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_gJBIM0zfO9" href="./03_functions.html#c_gJBIM0zfO9"></a><span class="cm-comment">// Your code here.</span>

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">min</span>(<span class="cm-number">0</span>, <span class="cm-number">10</span>));
<span class="cm-comment">// → 0</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">min</span>(<span class="cm-number">0</span>, <span class="cm-operator">-</span><span class="cm-number">10</span>));
<span class="cm-comment">// → -10</span></pre>
<div class="solution"><div class="solution-text">
<p><a class="p_ident" id="p_jbGq7vKDsS" href="./03_functions.html#p_jbGq7vKDsS"></a>Ако имате проблеми с поставянето на скоби или със скоби на точното място, за да получите валидна дефиниция на функция, започнете, като копирате един от примерите в тази глава и го променете.</p>
<p><a class="p_ident" id="p_kvKzukD1Sf" href="./03_functions.html#p_kvKzukD1Sf"></a>Функцията може да съдържа множество <code>return</code> изявления.</p>
</div></div>
<h3><a class="h_ident" id="h_jxl1p970Fy" href="./03_functions.html#h_jxl1p970Fy"></a>Рекурсия</h3>
<p><a class="p_ident" id="p_iDq2OgBOGw" href="./03_functions.html#p_iDq2OgBOGw"></a>Видяхме, че <code>%</code> (оператора за остатък) може да се използва, за да се провери дали даден номер е четен или с <code>% 2</code> дали се дели на две. Ето още един начин, по който може да се определи дали дадено положително цяло число е четно или нечетно.</p>
<div class="ulist"><ul>
<li>
<p><a class="p_ident" id="p_lCOBPDdrEk" href="./03_functions.html#p_lCOBPDdrEk"></a>
нула е четно.
</p>
</li>
<li>
<p><a class="p_ident" id="p_fWhtKbL+Su" href="./03_functions.html#p_fWhtKbL+Su"></a>
едно е нечетно.
</p>
</li>
<li>
<p><a class="p_ident" id="p_1dwrqpocrW" href="./03_functions.html#p_1dwrqpocrW"></a>за всеки друг брой <em>N</em>, неговата четност е <em>N</em> - 2.
</p>
</li>
</ul></div>
<p><a class="p_ident" id="p_zxMN8E0WOI" href="./03_functions.html#p_zxMN8E0WOI"></a>Направете рекурсивна функция <code>isEven</code> съответстваща на това описание. Функцията трябва да приема <code>number</code> параметри и да връща булева стойност.</p>
<p><a class="p_ident" id="p_0+fMeza2x5" href="./03_functions.html#p_0+fMeza2x5"></a>Пробвайте с 50 и 75. Вижте как се държи с -1. Защо? Сещате ли се начин да се оправи това?</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_QLgWQR2Q0C" href="./03_functions.html#c_QLgWQR2Q0C"></a><span class="cm-comment">// Your code here.</span>

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">isEven</span>(<span class="cm-number">50</span>));
<span class="cm-comment">// → true</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">isEven</span>(<span class="cm-number">75</span>));
<span class="cm-comment">// → false</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">isEven</span>(<span class="cm-operator">-</span><span class="cm-number">1</span>));
<span class="cm-comment">// → ??</span></pre>
<div class="solution"><div class="solution-text">
<p><a class="p_ident" id="p_4Nl1/L8dAN" href="./03_functions.html#p_4Nl1/L8dAN"></a>Вашата функция вероятно ще изглежда, като нещо подобно на вътрешната функция за <code>find</code> в рекурсивния <code>findSolution</code>
<a href="./03_functions.html#recursive_puzzle">пример</a> на тази глава, с <code>if</code>/<code>else if</code>/<code>else</code> последователност за тестване на, кой от трите случая се прилага. Финалът на <code>else</code>, който съответства на третия случай, прави рекурсивно извикване. Всяка от бримките на тестовете трябва да съдържа <code>return</code> изявление или някакъв друг начин, за осигуряване на връщане на определена стойност.</p>
<p><a class="p_ident" id="p_QIaN+xYJ+M" href="./03_functions.html#p_QIaN+xYJ+M"></a>Когато е дадено отрицателно число, функцията ще се самоизвика отново и отново, като си подава все по-отрицателно число и по този начин все по-далеч и по-далеч от крайния си резултат. Това в крайна сметка ще изчерпи пространството на стека и ще се откаже.</p>
</div></div>
<h3><a class="h_ident" id="h_3rsiDgC2do" href="./03_functions.html#h_3rsiDgC2do"></a>Bean  броене</h3>
<p><a class="p_ident" id="p_8y74cOkS91" href="./03_functions.html#p_8y74cOkS91"></a>Можете да получите <em>N</em>-тия характер на писмо от <em>string</em> с написването на <code>"string".charAt(N)</code>, подобно на начина, по който вземаме дължината му с <code>"s".length</code>. Върнатата стойност ще бъде  string, съдържащ само един знак(например <code>"b"</code>). Първият знак има позиция нула, което означава, че последният ще бъде намерен в позиция <code>string.length - 1</code>. С други думи, <em>string</em> от две букви, ще има позиции 0 и 1.</p>
<p><a class="p_ident" id="p_3+wBcfMbYR" href="./03_functions.html#p_3+wBcfMbYR"></a>Напишете функция <code>countBs</code>, която взема <em>string</em>, като единствен аргумент и връща число, което показва колко много главни “B” има в <em>string</em>.</p>
<p><a class="p_ident" id="p_WdA52+sgwM" href="./03_functions.html#p_WdA52+sgwM"></a>На следващо място, напишете функция, наречена <code>countChar</code>, която се държи като <code>countBs</code>, освен това взема втори аргумент, който показва характера, който трябва да се брои (вместо само да брои главни “B”). Пренапишете <code>countBs</code> да се възползва от тази нова функция.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_Xb4A/OaxUr" href="./03_functions.html#c_Xb4A/OaxUr"></a><span class="cm-comment">// Your code here.</span>

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">countBs</span>(<span class="cm-string">"BBC"</span>));
<span class="cm-comment">// → 2</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">countChar</span>(<span class="cm-string">"kakkerlak"</span>, <span class="cm-string">"k"</span>));
<span class="cm-comment">// → 4</span></pre>
<div class="solution"><div class="solution-text">
<p><a class="p_ident" id="p_DGiAPWNd0Y" href="./03_functions.html#p_DGiAPWNd0Y"></a> Цикъла във вашата функция ще трябва да разгледа всеки характер в <em>string</em>  започвайки от индекс нула до един по-долу в дължината му (<code>&lt; string.length</code>). Ако характера на текущата позиция е същия, като този, който функцията търси, се добавя 1 към брояч-променливата. След като цикъла е приключил, броячът може да се върне.</p>
<p><a class="p_ident" id="p_vxmtiGDt1B" href="./03_functions.html#p_vxmtiGDt1B"></a>Погрижете се да направите всички променливи, използвани във функцията локални за функцията с помощта на ключовата дума <code>var</code>.</p>
</div></div>
<nav>
  <a href="./02_program_structure.html" title="previous chapter">◀</a>
  <a href="./index.html" title="cover">◆</a>
  <a href="./04_data.html" title="next chapter">▶</a>
</nav>
</article>
</body></html>