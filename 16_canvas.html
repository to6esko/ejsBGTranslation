<!DOCTYPE html>
<!-- saved from url=(0044)./16_canvas.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <title>Drawing on Canvas :: Eloquent JavaScript</title>
  <link rel="stylesheet" href="./media/codemirror.css">
  <script src="./media/acorn_codemirror.js"></script>
  <link rel="stylesheet" href="./media/ejs.css">
  <script src="./media/sandbox.js"></script>
  <script src="./media/ejs.js"></script>
  <script>var chapNum = 16;var sandboxLoadFiles = ["code/chapter/15_game.js", "code/game_levels.js", "code/chapter/16_canvas.js"];</script>
</head>

<body><article>
<nav>
  <a href="./15_game.html" title="previous chapter">◀</a>
  <a href="./index.html" title="cover">◆</a>
  <a href="./17_http.html" title="next chapter">▶</a>
</nav>

<h1><div class="chap_num">Глава 16</div>Рисуване върху платно</h1>
<blockquote>
<p><a class="p_ident" id="p_ubdp8gf0Gn" href="./16_canvas.html#p_ubdp8gf0Gn"></a>Drawing е една измама.”</p>
 <footer>M.C. Escher, <cite>цитиран от Bruno Ernst в The Magic Mirror на Ешер</cite></footer>
</blockquote>
<p><a class="p_ident" id="p_rMRN8Q3Ilr" href="./16_canvas.html#p_rMRN8Q3Ilr"></a>Браузърът ни дава няколко начина за показване на графики. Най-простият се използва за позициониране на стилове и оцветяване на редови DOM елементи. Така може да стигнете доста далеч, както играта в <a href="./15_game.html#game">предната глава</a> показа. Чрез добавяне на полупрозрачни изображения за фон на разклоненията, можем да ги направим да изглеждат точно така, както ние искаме. Възможно е дори да се върти или наклони разклонение с помощта на <code>transform</code> стила.</p>
<p><a class="p_ident" id="p_4MfzfTYnsB" href="./16_canvas.html#p_4MfzfTYnsB"></a>Но можем да използваме DOM за нещо, за което не е бил първоначално проектиран. Някои задачи, като чертане на линия между произволни точки, са изключително неудобни с редовни HTML елементи.</p>
<p><a class="p_ident" id="p_ETEHgjW4XZ" href="./16_canvas.html#p_ETEHgjW4XZ"></a>Има две алтернативи. Първата е DOM базирана, като използва <em>Scalable Vector Graphics (SVG)</em> вместо HTML елементи. Мислете за SVG, като диалект за описване на документи, който се фокусира върху формите, а не върху текста. Можете да вградите SVG документ в HTML документ или да го включите с <code>&lt;img&gt;</code> таг.</p>
<p><a class="p_ident" id="p_wU9UQEILbC" href="./16_canvas.html#p_wU9UQEILbC"></a>Втората алтернатива се нарича <em>canvas</em> (платно). Платното е единичен DOM елемент, който капсулира картина. То осигурява програмен интерфейс за съставяне на фигури върху област взета от разклонение. Основната разлика между <em>canvas</em>  и SVG, е че в SVG е запазено оригиналното описание на формите, така че те да могат да бъдат местени или променяни по размер по всяко време. Докато платното от друга страна превръща формите в пиксели (цветни точки на изображението) и веднага след, като те са създадени не помни, какво представляват тези пиксели. Единственият начин да се движат формите по платното (или част от формите на <em>canvas</em>) е да изчистите платното и да прехвърлите формата на нова позиция.</p>
<h2><a class="h_ident" id="h_UPzm0CiZhQ" href="./16_canvas.html#h_UPzm0CiZhQ"></a>SVG</h2>
<p><a class="p_ident" id="p_gCxXcLPC1N" href="./16_canvas.html#p_gCxXcLPC1N"></a>Тази книга няма да набляга на подробности за SVG, но накратко ще обясним как става това. В <a href="./16_canvas.html#graphics_tradeoffs">края на главата</a> ще се върнем на компромисите, които трябва да се имат в предвид при вземане на решение, кой изготвящ механизъм е по-подходящ за дадено приложение.</p>
<p><a class="p_ident" id="p_aF1bihN0fO" href="./16_canvas.html#p_aF1bihN0fO"></a>Това е HTML документ с проста SVG картина в него:</p>
<pre data-language="text/html" class="snippet cm-s-default" data-sandbox="svg"><a class="c_ident" id="c_51NWnKIFCi" href="./16_canvas.html#c_51NWnKIFCi"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>Normal HTML here.<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">svg</span> <span class="cm-attribute">xmlns</span>=<span class="cm-string">"http://www.w3.org/2000/svg"</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">circle</span> <span class="cm-attribute">r</span>=<span class="cm-string">"50"</span> <span class="cm-attribute">cx</span>=<span class="cm-string">"50"</span> <span class="cm-attribute">cy</span>=<span class="cm-string">"50"</span> <span class="cm-attribute">fill</span>=<span class="cm-string">"red"</span><span class="cm-tag cm-bracket">/&gt;</span>
  <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">rect</span> <span class="cm-attribute">x</span>=<span class="cm-string">"120"</span> <span class="cm-attribute">y</span>=<span class="cm-string">"5"</span> <span class="cm-attribute">width</span>=<span class="cm-string">"90"</span> <span class="cm-attribute">height</span>=<span class="cm-string">"90"</span>
        <span class="cm-attribute">stroke</span>=<span class="cm-string">"blue"</span> <span class="cm-attribute">fill</span>=<span class="cm-string">"none"</span><span class="cm-tag cm-bracket">/&gt;</span>
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">svg</span><span class="cm-tag cm-bracket">&gt;</span></pre>
<p><a class="p_ident" id="p_sJ+IuoXUNA" href="./16_canvas.html#p_sJ+IuoXUNA"></a>Атрибута <code>xmlns</code> променя елемента (и неговите деца) в различно <em>XML namespace</em> (пространство) от имена. Това пространство от имена идентифицирано с URL уточнява диалекта, на който в момента говорим. <code>&lt;circle&gt;</code> и <code>&lt;rect&gt;</code> таговете, които не съществуват в HTML, нямат значение за изготвянето на формите в SVG - те изготвят форми, използвайки стила и положението, определено от техните атрибути.</p>
<p><a class="p_ident" id="p_DcMLpWRkj0" href="./16_canvas.html#p_DcMLpWRkj0"></a>Тези маркери създават DOM елементи, точно като HTML тагове. Например, това променя <code>&lt;circle&gt;</code> елемента да бъде оцветен в циан вместо червено.</p>
<pre data-language="javascript" class="snippet cm-s-default" data-sandbox="svg"><a class="c_ident" id="c_nTTh9qtCeV" href="./16_canvas.html#c_nTTh9qtCeV"></a><span class="cm-keyword">var</span> <span class="cm-variable">circle</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">"circle"</span>);
<span class="cm-variable">circle</span>.<span class="cm-property">setAttribute</span>(<span class="cm-string">"fill"</span>, <span class="cm-string">"cyan"</span>);</pre>
<h2><a class="h_ident" id="h_QXPPgw0nn4" href="./16_canvas.html#h_QXPPgw0nn4"></a>Canvas  елемент</h2>
<p><a class="p_ident" id="p_81TEgZtPp7" href="./16_canvas.html#p_81TEgZtPp7"></a><em>Canvas</em>  графики могат да се правят върху <code>&lt;canvas&gt;</code> елемент. Можем да дадем на такъв елемент <code>width</code> и <code>height</code> атрибути за определяне на размера му в пиксели.</p>
<p><a class="p_ident" id="p_oQeTfkBH6v" href="./16_canvas.html#p_oQeTfkBH6v"></a>Новото платно е празно, което означава, че е напълно прозрачно и по този начин се появява, като празно пространство в документа.</p>
<p><a class="p_ident" id="p_r+b1t0y8Si" href="./16_canvas.html#p_r+b1t0y8Si"></a>Тага <code>&lt;canvas&gt;</code> е предназначен за подкрепа на различни стилове на рисуване. За да получим достъп до действителния интерфейс на една рисунка, първо трябва да създадем обстановка, която е обект чиито методи предоставят интерфейс за чертане. В момента има два широко подкрепяни стилове: <code>"2d"</code> - за двуизмерни графики и <code>"webgl"</code> - за триизмерна графика през интерфейса на  OpenGL.</p>
<p><a class="p_ident" id="p_JaC7mTUVQ0" href="./16_canvas.html#p_JaC7mTUVQ0"></a>Тази книга няма да обсъжда WebGL. Ще се придържаме към двете измерения. Но ако се интересувате от триизмерна графика ви препоръчвам да разгледате  WebGL. Той осигурява много директен интерфейс към съвременния графичен хардуер и по този начин ви позволява да направите ефективно дори сложни сцени, използвайки JavaScript.</p>
<p><a class="p_ident" id="p_GM4b1ASHzf" href="./16_canvas.html#p_GM4b1ASHzf"></a>Контекста е създаден през <code>getContext</code> метода на <code>&lt;canvas&gt;</code> елемента.</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class="c_ident" id="c_jWP86QSU3M" href="./16_canvas.html#c_jWP86QSU3M"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>Before canvas.<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">canvas</span> <span class="cm-attribute">width</span>=<span class="cm-string">"120"</span> <span class="cm-attribute">height</span>=<span class="cm-string">"60"</span><span class="cm-tag cm-bracket">&gt;&lt;/</span><span class="cm-tag">canvas</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>After canvas.<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-keyword">var</span> <span class="cm-variable">canvas</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">"canvas"</span>);
  <span class="cm-keyword">var</span> <span class="cm-variable">context</span> <span class="cm-operator">=</span> <span class="cm-variable">canvas</span>.<span class="cm-property">getContext</span>(<span class="cm-string">"2d"</span>);
  <span class="cm-variable">context</span>.<span class="cm-property">fillStyle</span> <span class="cm-operator">=</span> <span class="cm-string">"red"</span>;
  <span class="cm-variable">context</span>.<span class="cm-property">fillRect</span>(<span class="cm-number">10</span>, <span class="cm-number">10</span>, <span class="cm-number">100</span>, <span class="cm-number">50</span>);
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>
<p><a class="p_ident" id="p_fv4PQSHT32" href="./16_canvas.html#p_fv4PQSHT32"></a>След създаване на контекст обект, примерът чертае червен правоъгълник 100 пиксела на 50 пиксела, с координати - горен ляв ъгъл (10, 10).</p>
<p><a class="p_ident" id="p_e1SRsTstnD" href="./16_canvas.html#p_e1SRsTstnD"></a>Точно както в HTML (и SVG), координатната система поставя платното на точка (0, 0) в гония ляв ъгъл и положителната ос у слиза от там. Така че, (10, 10) е 10 пиксела по надолу и по надясно от горния ляв ъгъл.</p>
<h2 id="fill_stroke"><a class="h_ident" id="h_pcnyueRl1y" href="./16_canvas.html#h_pcnyueRl1y"></a>Запълване  и  очертания</h2>
<p><a class="p_ident" id="p_UvxB22/zji" href="./16_canvas.html#p_UvxB22/zji"></a>В интерфейса на платното, формата може да бъде <em>filled</em> (запълнена), което означава, че на площта е даден цвят и модел или може да бъде <em>stroked</em> (очертана), което означава, че линията рисува неговия ръб. Същата терминология използва и SVG.</p>
<p><a class="p_ident" id="p_jXutP8Kp6D" href="./16_canvas.html#p_jXutP8Kp6D"></a>Метода <code>fillRect</code> запълва правоъгълника. Той взема първо х и у координатите на горния ляв ъгъл на правоъгълника, а след това неговата ширина и височина. Метода <code>strokeRect</code> е подобен и чертае очертанията на правоъгълника.</p>
<p><a class="p_ident" id="p_a+mohoFrQD" href="./16_canvas.html#p_a+mohoFrQD"></a>Метода <em>neither</em> взема някои допълнителни параметри. Цвят на пълнежа, дебелина на очертанията и т.н. той не се определя от един аргумент на метода (както може да се очаква), а по-скоро от свойствата на контекста на обекта.</p>
<p><a class="p_ident" id="p_qwtIen1h5e" href="./16_canvas.html#p_qwtIen1h5e"></a>Свойството <code>fillStyle</code> променя начина на запълване на формата. Може да се настрои със <em>string</em>, който определя цвят и може да се използва всеки цвят, който се разбира със CSS.</p>
<p><a class="p_ident" id="p_z2EgIJKmOE" href="./16_canvas.html#p_z2EgIJKmOE"></a>Свойството <code>strokeStyle</code> работи по подобен начин, но определя цвета използван за очертаваща линия. Ширината на тази линия се определя от свойството <code>lineWidth</code>, което може да съдържа всяко положително число.</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class="c_ident" id="c_SjVWfvP4XI" href="./16_canvas.html#c_SjVWfvP4XI"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">canvas</span><span class="cm-tag cm-bracket">&gt;&lt;/</span><span class="cm-tag">canvas</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-keyword">var</span> <span class="cm-variable">cx</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">"canvas"</span>).<span class="cm-property">getContext</span>(<span class="cm-string">"2d"</span>);
  <span class="cm-variable">cx</span>.<span class="cm-property">strokeStyle</span> <span class="cm-operator">=</span> <span class="cm-string">"blue"</span>;
  <span class="cm-variable">cx</span>.<span class="cm-property">strokeRect</span>(<span class="cm-number">5</span>, <span class="cm-number">5</span>, <span class="cm-number">50</span>, <span class="cm-number">50</span>);
  <span class="cm-variable">cx</span>.<span class="cm-property">lineWidth</span> <span class="cm-operator">=</span> <span class="cm-number">5</span>;
  <span class="cm-variable">cx</span>.<span class="cm-property">strokeRect</span>(<span class="cm-number">135</span>, <span class="cm-number">5</span>, <span class="cm-number">50</span>, <span class="cm-number">50</span>);
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>
<p><a class="p_ident" id="p_AIygWrCmAA" href="./16_canvas.html#p_AIygWrCmAA"></a>Когато няма определен атрибут <code>width</code> или <code>height</code>, както в предишния пример, елемента на платното получава ширина по-подразбиране от 300 пиксела и височина от 150 пиксела.</p>
<h2><a class="h_ident" id="h_E+fhFyL32D" href="./16_canvas.html#h_E+fhFyL32D"></a>Paths (път)</h2>
<p><a class="p_ident" id="p_EjhhpUs4B/" href="./16_canvas.html#p_EjhhpUs4B/"></a>Paths (път)  е поредица от линии. Интерфейса на 2d платното използва един особен подход за описване на такъв път. Той е направен изцяло чрез странични ефекти. Paths не са стойности, които могат да се съхраняват и подават наоколо. Вместо това, ако искате да направите нещо с пътя, можете да направите поредица от извиквания на метод, с които да опишете своята форма.</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class="c_ident" id="c_RrsnV8j3mk" href="./16_canvas.html#c_RrsnV8j3mk"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">canvas</span><span class="cm-tag cm-bracket">&gt;&lt;/</span><span class="cm-tag">canvas</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-keyword">var</span> <span class="cm-variable">cx</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">"canvas"</span>).<span class="cm-property">getContext</span>(<span class="cm-string">"2d"</span>);
  <span class="cm-variable">cx</span>.<span class="cm-property">beginPath</span>();
  <span class="cm-keyword">for</span> (<span class="cm-keyword">var</span> <span class="cm-variable">y</span> <span class="cm-operator">=</span> <span class="cm-number">10</span>; <span class="cm-variable">y</span> <span class="cm-operator">&lt;</span> <span class="cm-number">100</span>; <span class="cm-variable">y</span> <span class="cm-operator">+=</span> <span class="cm-number">10</span>) {
    <span class="cm-variable">cx</span>.<span class="cm-property">moveTo</span>(<span class="cm-number">10</span>, <span class="cm-variable">y</span>);
    <span class="cm-variable">cx</span>.<span class="cm-property">lineTo</span>(<span class="cm-number">90</span>, <span class="cm-variable">y</span>);
  }
  <span class="cm-variable">cx</span>.<span class="cm-property">stroke</span>();
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>
<p><a class="p_ident" id="p_CWuGebDoSl" href="./16_canvas.html#p_CWuGebDoSl"></a>Този пример създава път с няколко на брой  хоризонтални линии сегменти и след това използва <code>stroke</code> метод. Всеки сегмент е създаден с <code>lineTo</code>, от където започва текущата позиция на пътя. Тази позиция обикновено е края на последния сегмент, освен ако не е извикана <code>moveTo</code>. В такъв случай следващият сегмент ще започне в позицията подадена от <code>moveTo</code>.</p>
<p><a class="p_ident" id="p_/C3/H/w2FX" href="./16_canvas.html#p_/C3/H/w2FX"></a>При запълване на пътя (с помощта на <code>fill</code> метода) всяка форма се запълва отделно. Пътят може да съдържа множество форми - всяка от които започва с <code>moveTo</code>. Но пътят трябва да бъде затворен (което означава , че неговото начало и край са едно и също местоположение), преди да може да бъде запълнен. Ако пътя не е затворен, се добавя допълнителна линия от края до началото на пътя и формата се запълва.</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class="c_ident" id="c_a6T1eLJBay" href="./16_canvas.html#c_a6T1eLJBay"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">canvas</span><span class="cm-tag cm-bracket">&gt;&lt;/</span><span class="cm-tag">canvas</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-keyword">var</span> <span class="cm-variable">cx</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">"canvas"</span>).<span class="cm-property">getContext</span>(<span class="cm-string">"2d"</span>);
  <span class="cm-variable">cx</span>.<span class="cm-property">beginPath</span>();
  <span class="cm-variable">cx</span>.<span class="cm-property">moveTo</span>(<span class="cm-number">50</span>, <span class="cm-number">10</span>);
  <span class="cm-variable">cx</span>.<span class="cm-property">lineTo</span>(<span class="cm-number">10</span>, <span class="cm-number">70</span>);
  <span class="cm-variable">cx</span>.<span class="cm-property">lineTo</span>(<span class="cm-number">90</span>, <span class="cm-number">70</span>);
  <span class="cm-variable">cx</span>.<span class="cm-property">fill</span>();
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>
<p><a class="p_ident" id="p_9unYw61//h" href="./16_canvas.html#p_9unYw61//h"></a>Този пример чертае запълнен триъгълник. Имайте в предвид, че само две от страните на триъгълника са изрично изготвени. Третата, от долния десен ъгъл обратно към началото се подразбира и няма да бъде там, когато се очертава пътя.</p>
<p><a class="p_ident" id="p_6TyHPpw704" href="./16_canvas.html#p_6TyHPpw704"></a>Вие също може да използвате метода <code>closePath</code> изрично да затвори пътя, чрез добавяне на действителен сегмент линия обратно към началото на пътя. Този сегмент е съставен, когато се очератава пътя.</p>
<h2><a class="h_ident" id="h_B8g7k6vws+" href="./16_canvas.html#h_B8g7k6vws+"></a>Curves (криви линии)</h2>
<p><a class="p_ident" id="p_xee0Jzlsic" href="./16_canvas.html#p_xee0Jzlsic"></a>Пътя може да съдържа криви линии. Те са за съжаление, малко по-ангажиращи, от колкото правите линии.</p>
<p><a class="p_ident" id="p_q2PxOrpPav" href="./16_canvas.html#p_q2PxOrpPav"></a>Метода <code>quadraticCurveTo</code> чертае крива до дадена точка. За определяне на кривината на линията, е дадена една контролна точка, както и точка дестинация. Представете си, че тази контролна точка привлича линията и по този начин я изкривява. Линията не минава през контролната точка. По-скоро, посоката на линията от нейната начална и крайна точка, ще бъде такава, че да съвпадне с линията до контролната точка. Следващият пример илюстрира това.</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class="c_ident" id="c_+OifyNljo7" href="./16_canvas.html#c_+OifyNljo7"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">canvas</span><span class="cm-tag cm-bracket">&gt;&lt;/</span><span class="cm-tag">canvas</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-keyword">var</span> <span class="cm-variable">cx</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">"canvas"</span>).<span class="cm-property">getContext</span>(<span class="cm-string">"2d"</span>);
  <span class="cm-variable">cx</span>.<span class="cm-property">beginPath</span>();
  <span class="cm-variable">cx</span>.<span class="cm-property">moveTo</span>(<span class="cm-number">10</span>, <span class="cm-number">90</span>);
  <span class="cm-comment">// control=(60,10) goal=(90,90)</span>
  <span class="cm-variable">cx</span>.<span class="cm-property">quadraticCurveTo</span>(<span class="cm-number">60</span>, <span class="cm-number">10</span>, <span class="cm-number">90</span>, <span class="cm-number">90</span>);
  <span class="cm-variable">cx</span>.<span class="cm-property">lineTo</span>(<span class="cm-number">60</span>, <span class="cm-number">10</span>);
  <span class="cm-variable">cx</span>.<span class="cm-property">closePath</span>();
  <span class="cm-variable">cx</span>.<span class="cm-property">stroke</span>();
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>
<p><a class="p_ident" id="p_OIjzl6Dc9Y" href="./16_canvas.html#p_OIjzl6Dc9Y"></a>Ние чертаем квадратна крива от ляво на дясно с (60,10), като контролна точка, а след това правим две отсечки, които минават през контролната точка и обратно до началото на линията. Резултата донякъде прилича на емблема на <em>Star Trek</em>. Можете да видите ефекта на контролната точка: лиите идващи от долните ъгли започват в посоката на контролната точка и след това изкривяват към целата си.</p>
<p><a class="p_ident" id="p_Nd10AmdUxD" href="./16_canvas.html#p_Nd10AmdUxD"></a> Метода <code>bezierCurveTo</code> чертае подобни криви. Но вместо една контролна точка, той използва 2 за всяка от крайните точки на линията. Това е скица, която илюстрира поведението на подобна крива.</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class="c_ident" id="c_54UmXjaHEO" href="./16_canvas.html#c_54UmXjaHEO"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">canvas</span><span class="cm-tag cm-bracket">&gt;&lt;/</span><span class="cm-tag">canvas</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-keyword">var</span> <span class="cm-variable">cx</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">"canvas"</span>).<span class="cm-property">getContext</span>(<span class="cm-string">"2d"</span>);
  <span class="cm-variable">cx</span>.<span class="cm-property">beginPath</span>();
  <span class="cm-variable">cx</span>.<span class="cm-property">moveTo</span>(<span class="cm-number">10</span>, <span class="cm-number">90</span>);
  <span class="cm-comment">// control1=(10,10) control2=(90,10) goal=(50,90)</span>
  <span class="cm-variable">cx</span>.<span class="cm-property">bezierCurveTo</span>(<span class="cm-number">10</span>, <span class="cm-number">10</span>, <span class="cm-number">90</span>, <span class="cm-number">10</span>, <span class="cm-number">50</span>, <span class="cm-number">90</span>);
  <span class="cm-variable">cx</span>.<span class="cm-property">lineTo</span>(<span class="cm-number">90</span>, <span class="cm-number">10</span>);
  <span class="cm-variable">cx</span>.<span class="cm-property">lineTo</span>(<span class="cm-number">10</span>, <span class="cm-number">10</span>);
  <span class="cm-variable">cx</span>.<span class="cm-property">closePath</span>();
  <span class="cm-variable">cx</span>.<span class="cm-property">stroke</span>();
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>
<p><a class="p_ident" id="p_UVt0ID9CaV" href="./16_canvas.html#p_UVt0ID9CaV"></a>Двете контролни точки определят посоката на двата края на кривата. Колкото са по далеч от своята кореспондираща точка, толкова повече кривата ще е “изпъкнала” в тази посока.</p>
<p><a class="p_ident" id="p_tMRY3uv3sU" href="./16_canvas.html#p_tMRY3uv3sU"></a>С такива криви може да бъде трудно да се работи, не винаги е ясно, как да намерим контролните точки, които осигуряват формата, която търсим. Понякога може да се изчисли, а понякога ще трябва да се търси подходяща  стойност с метода на проба-грешка.</p>
<p><a class="p_ident" id="p_A4ndRHX5Et" href="./16_canvas.html#p_A4ndRHX5Et"></a><em>Arcs</em>-фрагментите на окръжности са по-лесни. Метода <code>arcTo</code> взема не по-малко от 5 аргумента. Първите четири аргумента действат малко, като аргументите на <code>quadraticCurveTo</code>. Първата двойка определя контролната точка, а втората двойка дестинацията на линията. Петият аргумент осигурява радиуса на дъгата. Метода концептуално проектира и ъгъл - линията отива до контролната точка и после до точката на дестинацията и с процента на ъгъла оформя част от кръга с дадения радиус. Метода <code>arcTo</code> чертае заоблената част, както и линията от началната точка до началото на заоблената част.</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class="c_ident" id="c_6HNaUmfESZ" href="./16_canvas.html#c_6HNaUmfESZ"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">canvas</span><span class="cm-tag cm-bracket">&gt;&lt;/</span><span class="cm-tag">canvas</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-keyword">var</span> <span class="cm-variable">cx</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">"canvas"</span>).<span class="cm-property">getContext</span>(<span class="cm-string">"2d"</span>);
  <span class="cm-variable">cx</span>.<span class="cm-property">beginPath</span>();
  <span class="cm-variable">cx</span>.<span class="cm-property">moveTo</span>(<span class="cm-number">10</span>, <span class="cm-number">10</span>);
  <span class="cm-comment">// control=(90,10) goal=(90,90) radius=20</span>
  <span class="cm-variable">cx</span>.<span class="cm-property">arcTo</span>(<span class="cm-number">90</span>, <span class="cm-number">10</span>, <span class="cm-number">90</span>, <span class="cm-number">90</span>, <span class="cm-number">20</span>);
  <span class="cm-variable">cx</span>.<span class="cm-property">moveTo</span>(<span class="cm-number">10</span>, <span class="cm-number">10</span>);
  <span class="cm-comment">// control=(90,10) goal=(90,90) radius=80</span>
  <span class="cm-variable">cx</span>.<span class="cm-property">arcTo</span>(<span class="cm-number">90</span>, <span class="cm-number">10</span>, <span class="cm-number">90</span>, <span class="cm-number">90</span>, <span class="cm-number">80</span>);
  <span class="cm-variable">cx</span>.<span class="cm-property">stroke</span>();
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>
<p><a class="p_ident" id="p_+oDzi4kZW+" href="./16_canvas.html#p_+oDzi4kZW+"></a>Метода <code>arcTo</code> не чертае линия от края на заоблената част до целевата позиция, въпреки че думата <em>to</em> в неговото име загатва, че го прави. Можем да го свържем, като извикаме <code>lineTo</code> с координатите на същата цел за да добавим частта от линията.</p>
<p><a class="p_ident" id="p_amjPveUnsp" href="./16_canvas.html#p_amjPveUnsp"></a>За да начертаем кръг можем да използваме четири извиквания на <code>arcTo</code> (всяко по 90 градуса). Но метода <code>arc</code> осигурява по-лесен начин. Той взема чифт координати - център на дъгата, радиус и след това начало и край на ъгъла.</p>
<p><a class="p_ident" id="p_R0hMJ8VOzu" href="./16_canvas.html#p_R0hMJ8VOzu"></a>Тези последните два периметъра позволяват да се изготви само част от кръг. Ъглите се измерват в радиани, а не в градуси. Това означава, че пълен кръг има ъгъл 2π или <code>2 * Math.PI</code>, което е около 6.28. Ъгълът започва да се измерва от точка в дясно от центъра на кръга в посока по часовниковата стрелка. Можем да използваме за старт 0 и край по-голям 2π (да речем 7) за да направим пълен кръг.</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class="c_ident" id="c_24IzNZRzqE" href="./16_canvas.html#c_24IzNZRzqE"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">canvas</span><span class="cm-tag cm-bracket">&gt;&lt;/</span><span class="cm-tag">canvas</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-keyword">var</span> <span class="cm-variable">cx</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">"canvas"</span>).<span class="cm-property">getContext</span>(<span class="cm-string">"2d"</span>);
  <span class="cm-variable">cx</span>.<span class="cm-property">beginPath</span>();
  <span class="cm-comment">// center=(50,50) radius=40 angle=0 to 7</span>
  <span class="cm-variable">cx</span>.<span class="cm-property">arc</span>(<span class="cm-number">50</span>, <span class="cm-number">50</span>, <span class="cm-number">40</span>, <span class="cm-number">0</span>, <span class="cm-number">7</span>);
  <span class="cm-comment">// center=(150,50) radius=40 angle=0 to ½π</span>
  <span class="cm-variable">cx</span>.<span class="cm-property">arc</span>(<span class="cm-number">150</span>, <span class="cm-number">50</span>, <span class="cm-number">40</span>, <span class="cm-number">0</span>, <span class="cm-number">0.5</span> <span class="cm-operator">*</span> <span class="cm-variable">Math</span>.<span class="cm-property">PI</span>);
  <span class="cm-variable">cx</span>.<span class="cm-property">stroke</span>();
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>
<p><a class="p_ident" id="p_NhI3gukqbY" href="./16_canvas.html#p_NhI3gukqbY"></a>Получената картина съдържа линия на дясно от пълния кръг (първото извикване на <code>arc</code>) и после в дясно четвърт кръг(второто извикване на <code>arc</code>). Подобно на метода за пътя, линията прекарана с arc е свързана с предишния сегмент по подразбиране. Ще трябва да извикате <code>moveTo</code> или да започнете нов път, ако искате да избегнете това.</p>
<h2 id="pie_chart"><a class="h_ident" id="h_9yOdkmATfT" href="./16_canvas.html#h_9yOdkmATfT"></a>Рисуване  на  кръгова  диаграма</h2>
<p><a class="p_ident" id="p_Rd++tqzkHn" href="./16_canvas.html#p_Rd++tqzkHn"></a>Представете си, че току-що сте почнали работа в EconomiCorp Inc и вашата първа задача е да направите кръгова диаграма на резултатите от техните изследвания за удовлетвореността на клиентите.</p>
<p><a class="p_ident" id="p_NOg95U8NVA" href="./16_canvas.html#p_NOg95U8NVA"></a>Променливата <code>results</code> съдържа масив от обекти, които представляват отговорите от проучването.</p>
<pre data-language="javascript" class="snippet cm-s-default" data-sandbox="pie"><a class="c_ident" id="c_Wu/ylZx+Sb" href="./16_canvas.html#c_Wu/ylZx+Sb"></a><span class="cm-keyword">var</span> <span class="cm-variable">results</span> <span class="cm-operator">=</span> [
  {<span class="cm-property">name</span>: <span class="cm-string">"Satisfied"</span>, <span class="cm-property">count</span>: <span class="cm-number">1043</span>, <span class="cm-property">color</span>: <span class="cm-string">"lightblue"</span>},
  {<span class="cm-property">name</span>: <span class="cm-string">"Neutral"</span>, <span class="cm-property">count</span>: <span class="cm-number">563</span>, <span class="cm-property">color</span>: <span class="cm-string">"lightgreen"</span>},
  {<span class="cm-property">name</span>: <span class="cm-string">"Unsatisfied"</span>, <span class="cm-property">count</span>: <span class="cm-number">510</span>, <span class="cm-property">color</span>: <span class="cm-string">"pink"</span>},
  {<span class="cm-property">name</span>: <span class="cm-string">"No comment"</span>, <span class="cm-property">count</span>: <span class="cm-number">175</span>, <span class="cm-property">color</span>: <span class="cm-string">"silver"</span>}
];</pre>
<p><a class="p_ident" id="p_P3SJQbINGf" href="./16_canvas.html#p_P3SJQbINGf"></a>За да направим кръговата диаграма, ние рисуваме парчета от пай, всяко съставено от дъга и чифт линии към центъра на тази дъга. Можем да изчислим ъгъла на всяка дъга, като разделим пълния кръг (2π) на общия брой от отговорите и след това умножим този номер по броя на хората от даден избор.</p>
<pre data-language="text/html" class="snippet cm-s-default" data-sandbox="pie"><a class="c_ident" id="c_wLkuRg8oTT" href="./16_canvas.html#c_wLkuRg8oTT"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">canvas</span> <span class="cm-attribute">width</span>=<span class="cm-string">"200"</span> <span class="cm-attribute">height</span>=<span class="cm-string">"200"</span><span class="cm-tag cm-bracket">&gt;&lt;/</span><span class="cm-tag">canvas</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-keyword">var</span> <span class="cm-variable">cx</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">"canvas"</span>).<span class="cm-property">getContext</span>(<span class="cm-string">"2d"</span>);
  <span class="cm-keyword">var</span> <span class="cm-variable">total</span> <span class="cm-operator">=</span> <span class="cm-variable">results</span>.<span class="cm-property">reduce</span>(<span class="cm-keyword">function</span>(<span class="cm-def">sum</span>, <span class="cm-def">choice</span>) {
    <span class="cm-keyword">return</span> <span class="cm-variable-2">sum</span> <span class="cm-operator">+</span> <span class="cm-variable-2">choice</span>.<span class="cm-property">count</span>;
  }, <span class="cm-number">0</span>);
  <span class="cm-comment">// Start at the top</span>
  <span class="cm-keyword">var</span> <span class="cm-variable">currentAngle</span> <span class="cm-operator">=</span> <span class="cm-operator">-</span><span class="cm-number">0.5</span> <span class="cm-operator">*</span> <span class="cm-variable">Math</span>.<span class="cm-property">PI</span>;
  <span class="cm-variable">results</span>.<span class="cm-property">forEach</span>(<span class="cm-keyword">function</span>(<span class="cm-def">result</span>) {
    <span class="cm-keyword">var</span> <span class="cm-def">sliceAngle</span> <span class="cm-operator">=</span> (<span class="cm-variable-2">result</span>.<span class="cm-property">count</span> <span class="cm-operator">/</span> <span class="cm-variable">total</span>) <span class="cm-operator">*</span> <span class="cm-number">2</span> <span class="cm-operator">*</span> <span class="cm-variable">Math</span>.<span class="cm-property">PI</span>;
    <span class="cm-variable">cx</span>.<span class="cm-property">beginPath</span>();
    <span class="cm-comment">// center=100,100, radius=100</span>
    <span class="cm-comment">// from current angle, clockwise by slice's angle</span>
    <span class="cm-variable">cx</span>.<span class="cm-property">arc</span>(<span class="cm-number">100</span>, <span class="cm-number">100</span>, <span class="cm-number">100</span>,
           <span class="cm-variable">currentAngle</span>, <span class="cm-variable">currentAngle</span> <span class="cm-operator">+</span> <span class="cm-variable-2">sliceAngle</span>);
    <span class="cm-variable">currentAngle</span> <span class="cm-operator">+=</span> <span class="cm-variable-2">sliceAngle</span>;
    <span class="cm-variable">cx</span>.<span class="cm-property">lineTo</span>(<span class="cm-number">100</span>, <span class="cm-number">100</span>);
    <span class="cm-variable">cx</span>.<span class="cm-property">fillStyle</span> <span class="cm-operator">=</span> <span class="cm-variable-2">result</span>.<span class="cm-property">color</span>;
    <span class="cm-variable">cx</span>.<span class="cm-property">fill</span>();
  });
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>
<p><a class="p_ident" id="p_e5+MpAPZp1" href="./16_canvas.html#p_e5+MpAPZp1"></a>Но диаграмата не ни казва, какво означава, което не е много полезно. Имаме нужда да вкараме текст във платното.</p>
<h2><a class="h_ident" id="h_wzKMObDin3" href="./16_canvas.html#h_wzKMObDin3"></a>Текст</h2>
<p><a class="p_ident" id="p_/MkzAT+yJW" href="./16_canvas.html#p_/MkzAT+yJW"></a>2D контекста на платното за рисуване осигурява методите <code>fillText</code> и <code>strokeText</code>. Последния е полезен за очертаване на букви, но обикновено <code>fillText</code> е този, който ни трябва. Той запълва даден текст с текущия <code>fillColor</code>.</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class="c_ident" id="c_Q1AmUAb2Hj" href="./16_canvas.html#c_Q1AmUAb2Hj"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">canvas</span><span class="cm-tag cm-bracket">&gt;&lt;/</span><span class="cm-tag">canvas</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-keyword">var</span> <span class="cm-variable">cx</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">"canvas"</span>).<span class="cm-property">getContext</span>(<span class="cm-string">"2d"</span>);
  <span class="cm-variable">cx</span>.<span class="cm-property">font</span> <span class="cm-operator">=</span> <span class="cm-string">"28px Georgia"</span>;
  <span class="cm-variable">cx</span>.<span class="cm-property">fillStyle</span> <span class="cm-operator">=</span> <span class="cm-string">"fuchsia"</span>;
  <span class="cm-variable">cx</span>.<span class="cm-property">fillText</span>(<span class="cm-string">"I can draw text, too!"</span>, <span class="cm-number">10</span>, <span class="cm-number">50</span>);
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>
<p><a class="p_ident" id="p_n79D894g2i" href="./16_canvas.html#p_n79D894g2i"></a>Можем да определим размера, стила и шрифта със свойството <code>font</code>. Този пример само дава размера на шрифта и <em>family name</em>. Можем да добавим <code>italic</code> или <code> в началото на <em>string</em>-а за да изберем стил.</p>
<p><a class="p_ident" id="p_3LlDU7wt/M" href="./16_canvas.html#p_3LlDU7wt/M"></a>Последните два аргумента на <code>fillText</code> (и <code>strokeText</code>) осигуряват място, където се изготвя шрифта. По подразбиране, те показват позицията на началото на азбучната основа на текста, това на коя линия стоят буквите, без да брои части за манипулиране, като <em>j</em> или <em>p</em>. Можем да променим хоризонталното положение, като настроим <code>textAlign</code> свойството да е <code>"end"</code> или <code>"center"</code> и вертикалното положение, като зададем на <code>textBaseline</code> да е <code>"top"</code>, <code>"middle"</code> или <code>"bottom"</code>.</p>
<p><a class="p_ident" id="p_/4NicYFaZd" href="./16_canvas.html#p_/4NicYFaZd"></a>Ще се върнем към нашата кръгова диаграма и проблемът с етикетиране на резените в <a href="./16_canvas.html#exercise_pie_chart">упражненията</a> на края на главата.</p>
<h2><a class="h_ident" id="h_CehxyY/vO5" href="./16_canvas.html#h_CehxyY/vO5"></a>Снимки (images)</h2>
<p><a class="p_ident" id="p_y7aK+8CMcM" href="./16_canvas.html#p_y7aK+8CMcM"></a>In computer graphics, a
distinction is often made between <em>vector</em> graphics and <em>bitmap</em>
graphics. The first is what we have been doing so far in this
chapter—specifying a picture by giving a logical description of
shapes. Bitmap graphics, on the other hand, don’t specify actual
shapes but rather work with pixel data (rasters of colored dots).</p>
<p><a class="p_ident" id="p_qlIKv8QV+7" href="./16_canvas.html#p_qlIKv8QV+7"></a>Метода <code>drawImage</code> ни позволява да изготвим пикселни данни върху платното. Тези пикселни данни могат да произхождат от  един <code>&lt;img&gt;</code> елемент или от друго платно, нито пък да бъдат видими в самия документ. Следващият пример създава самостоятелен <code>&lt;img&gt;</code> елемент и зарежда файл с изображение в него. Но не можем веднага за започнем да ползваме тази снимка, понеже браузърът не може да я донесе все още. За да направим това, трябва да регистрираме <code>"load"</code> за боравене със събития и да направим чертежа, след като изображението е заредено.</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class="c_ident" id="c_OAnOFm8i7l" href="./16_canvas.html#c_OAnOFm8i7l"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">canvas</span><span class="cm-tag cm-bracket">&gt;&lt;/</span><span class="cm-tag">canvas</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-keyword">var</span> <span class="cm-variable">cx</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">"canvas"</span>).<span class="cm-property">getContext</span>(<span class="cm-string">"2d"</span>);
  <span class="cm-keyword">var</span> <span class="cm-variable">img</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">createElement</span>(<span class="cm-string">"img"</span>);
  <span class="cm-variable">img</span>.<span class="cm-property">src</span> <span class="cm-operator">=</span> <span class="cm-string">"img/hat.png"</span>;
  <span class="cm-variable">img</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">"load"</span>, <span class="cm-keyword">function</span>() {
    <span class="cm-keyword">for</span> (<span class="cm-keyword">var</span> <span class="cm-def">x</span> <span class="cm-operator">=</span> <span class="cm-number">10</span>; <span class="cm-variable-2">x</span> <span class="cm-operator">&lt;</span> <span class="cm-number">200</span>; <span class="cm-variable-2">x</span> <span class="cm-operator">+=</span> <span class="cm-number">30</span>)
      <span class="cm-variable">cx</span>.<span class="cm-property">drawImage</span>(<span class="cm-variable">img</span>, <span class="cm-variable-2">x</span>, <span class="cm-number">10</span>);
  });
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>
<p><a class="p_ident" id="p_RxRhSVTbGY" href="./16_canvas.html#p_RxRhSVTbGY"></a>По подразбиране <code>drawImage</code> ще изготви изображението в оригиналния му размер. Можем също така да му дадем два допълнителни аргумента за промяна на ширината и височината.</p>
<p><a class="p_ident" id="p_/bLIqvw4R4" href="./16_canvas.html#p_/bLIqvw4R4"></a>Когато на <code>drawImage</code> са дадени девет аргумента, може да се използва за да се направи само един фрагмент от изображението. От втория до петия аргумент посочват правоъгълника (Х , У , ширина , височина) на изображението източник, което трябва да бъде копирано, а от шести до девети аргумент посочват правоъгълника (на платното), в който трябва да се копира изображението.</p>
<p><a class="p_ident" id="p_xKlo8wmmgJ" href="./16_canvas.html#p_xKlo8wmmgJ"></a>Това може да се използва за опаковане на множество <em>sprites</em> (спрайтове - елементи на снимка) в един файл с изображение, а след това да се направи само частта от която се нуждаем. Например, имаме тази картина съдържаща един герой в няколко пози.</p>
<div class="image">
  <img src="./media/player_big.png" alt="Various poses of a game character">
</div>
<p><a class="p_ident" id="p_u8W4Vqh39a" href="./16_canvas.html#p_u8W4Vqh39a"></a>С редуващи се пози, можем да покажем анимация, която прилича на ходене на героя.</p>
<p><a class="p_ident" id="p_vwSjUDbC98" href="./16_canvas.html#p_vwSjUDbC98"></a>За да анимираме тази снимка на платното, <code>clearRect</code> метода ще ни е полезен. Той прилича на <code>fillRect</code> но вместо да оцветява правоъгълника, той го прави прозрачен, премахва предварително изготвените пиксели.</p>
<p><a class="p_ident" id="p_VcrdBA3T8z" href="./16_canvas.html#p_VcrdBA3T8z"></a>Ние знаем, че всеки спрайт (всяка под-картинка), е 24 пиксела широка и 30 пиксела висока. Следният код зарежда изображението и след това създава интервал (повтарящ се таймер) за да изготви следващия кадър.</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class="c_ident" id="c_w48FwMDvG4" href="./16_canvas.html#c_w48FwMDvG4"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">canvas</span><span class="cm-tag cm-bracket">&gt;&lt;/</span><span class="cm-tag">canvas</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-keyword">var</span> <span class="cm-variable">cx</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">"canvas"</span>).<span class="cm-property">getContext</span>(<span class="cm-string">"2d"</span>);
  <span class="cm-keyword">var</span> <span class="cm-variable">img</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">createElement</span>(<span class="cm-string">"img"</span>);
  <span class="cm-variable">img</span>.<span class="cm-property">src</span> <span class="cm-operator">=</span> <span class="cm-string">"img/player.png"</span>;
  <span class="cm-keyword">var</span> <span class="cm-variable">spriteW</span> <span class="cm-operator">=</span> <span class="cm-number">24</span>, <span class="cm-variable">spriteH</span> <span class="cm-operator">=</span> <span class="cm-number">30</span>;
  <span class="cm-variable">img</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">"load"</span>, <span class="cm-keyword">function</span>() {
    <span class="cm-keyword">var</span> <span class="cm-def">cycle</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>;
    <span class="cm-variable">setInterval</span>(<span class="cm-keyword">function</span>() {
      <span class="cm-variable">cx</span>.<span class="cm-property">clearRect</span>(<span class="cm-number">0</span>, <span class="cm-number">0</span>, <span class="cm-variable">spriteW</span>, <span class="cm-variable">spriteH</span>);
      <span class="cm-variable">cx</span>.<span class="cm-property">drawImage</span>(<span class="cm-variable">img</span>,
                   <span class="cm-comment">// source rectangle</span>
                   <span class="cm-variable-2">cycle</span> <span class="cm-operator">*</span> <span class="cm-variable">spriteW</span>, <span class="cm-number">0</span>, <span class="cm-variable">spriteW</span>, <span class="cm-variable">spriteH</span>,
                   <span class="cm-comment">// destination rectangle</span>
                   <span class="cm-number">0</span>,               <span class="cm-number">0</span>, <span class="cm-variable">spriteW</span>, <span class="cm-variable">spriteH</span>);
      <span class="cm-variable-2">cycle</span> <span class="cm-operator">=</span> (<span class="cm-variable-2">cycle</span> <span class="cm-operator">+</span> <span class="cm-number">1</span>) <span class="cm-operator">%</span> <span class="cm-number">8</span>;
    }, <span class="cm-number">120</span>);
  });
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>
<p><a class="p_ident" id="p_FwoYTH1Pg7" href="./16_canvas.html#p_FwoYTH1Pg7"></a>Променливата <code>cycle</code> следи нашата позиция в анимацията. С всяка рамка тя се увеличава се връща обратно в 0-7 диапазона с помощта на оператора за остатък. Тази променлива се използва за изчисляване на х-координатите на спрайта за текущата поза в картината.</p>
<h2><a class="h_ident" id="h_3BwjEnWhbh" href="./16_canvas.html#h_3BwjEnWhbh"></a>Трансформация</h2>
<p><a class="p_ident" id="p_b00lbwHiev" href="./16_canvas.html#p_b00lbwHiev"></a>Но ако искаме нашия герой да ходи на ляво вместо на дясно? Можем да добавим още един набор от спрайтове, разбира се. Но също така може да възложим на платното да направи снимката обратно.</p>
<p><a class="p_ident" id="p_JnX4LFnuKL" href="./16_canvas.html#p_JnX4LFnuKL"></a>Извиквайки <code>scale</code> метода ще доведе до нещо изготвено след това да бъде намалено. Този метод взема два параметъра, един да създаде хоризонтален мащаб и един за задаване на вертикална скала.</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class="c_ident" id="c_jcUQ4xDEVZ" href="./16_canvas.html#c_jcUQ4xDEVZ"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">canvas</span><span class="cm-tag cm-bracket">&gt;&lt;/</span><span class="cm-tag">canvas</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-keyword">var</span> <span class="cm-variable">cx</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">"canvas"</span>).<span class="cm-property">getContext</span>(<span class="cm-string">"2d"</span>);
  <span class="cm-variable">cx</span>.<span class="cm-property">scale</span>(<span class="cm-number">3</span>, <span class="cm-number">.5</span>);
  <span class="cm-variable">cx</span>.<span class="cm-property">beginPath</span>();
  <span class="cm-variable">cx</span>.<span class="cm-property">arc</span>(<span class="cm-number">50</span>, <span class="cm-number">50</span>, <span class="cm-number">40</span>, <span class="cm-number">0</span>, <span class="cm-number">7</span>);
  <span class="cm-variable">cx</span>.<span class="cm-property">lineWidth</span> <span class="cm-operator">=</span> <span class="cm-number">3</span>;
  <span class="cm-variable">cx</span>.<span class="cm-property">stroke</span>();
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>
<p><a class="p_ident" id="p_u+8/LLl96H" href="./16_canvas.html#p_u+8/LLl96H"></a>Мащабирането ще вземе всичко за  рисувания двойник, включително ширината на линията, която трябва да бъде разтегната или стеснена, както е посочено. Мащабиране с отрицателна сума ще обърне картинката. Огледалното обръщане се случва в точка (0, 0), което означава, че също ще обърне посоката на координатната система. Когато се прилага хоризонтално мащабиране с използване на -1, формата начертана на позиция х 100 , ще се прехвърли на позиция -100.</p>
<p><a class="p_ident" id="p_bZnJ+aZtFS" href="./16_canvas.html#p_bZnJ+aZtFS"></a>Така че, за да обърнем една картина, не можем просто да добавим <code>cx.scale(-1, 1)</code>, тъй като това би преместило нашата картина извън платното, където тя няма да се вижда. Може да регулираме координатите дадени на <code>drawImage</code> да компенсира това чрез изтегляне на образа в позиция х -50 вместо 0. Друго решение, което не изисква код, който да променя мащаба на рисунката, е да се коригира оста, около която мащабирането се случва.</p>
<p><a class="p_ident" id="p_LbiF7s9yt4" href="./16_canvas.html#p_LbiF7s9yt4"></a>Има няколко други метода освен <code>scale</code> , които влияят на координатната система на платното. Можем да завъртим в последствие начертаните форми с <code>rotate</code> метода и да ги преместим с <code>translate</code> метода. Заинтригуващо и объркващо е, че тези трансформации се натупват, което означава, че всяка следваща се случва в сравнение с предишната трансформация.</p>
<p><a class="p_ident" id="p_mkNUtuNxcG" href="./16_canvas.html#p_mkNUtuNxcG"></a>Така че, ако се транслира с 10 хоризонтални пиксела два пъти, всичко ще бъде изтеглено на 20 пиксела надясно. Ние първо трябва да преместим центъра на координатната система на (50, 50) и след това да завъртим с 20 градуса (0.1π в радиани), така че въртенето да се случи в точка (50, 50).</p>
<div class="image">
  <img src="./media/transform.svg" alt="Stacking transformations">
</div>
<p><a class="p_ident" id="p_TGBwm05/cn" href="./16_canvas.html#p_TGBwm05/cn"></a>Но ако първо завъртим с 20 градуса и след това транслираме с (50, 50) транслацията ще се случи в завъртяна координатна система и по този начин ще се произведе различна ориентация. Редът, в който трябва да се случва трансформацията е приложна материя.</p>
<p><a class="p_ident" id="p_9a1O8aEtUA" href="./16_canvas.html#p_9a1O8aEtUA"></a>За да обърнем картината около вертикалната линия в дадено х- положение можем да направим следното:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_81ITeF67ab" href="./16_canvas.html#c_81ITeF67ab"></a><span class="cm-keyword">function</span> <span class="cm-variable">flipHorizontally</span>(<span class="cm-def">context</span>, <span class="cm-def">around</span>) {
  <span class="cm-variable-2">context</span>.<span class="cm-property">translate</span>(<span class="cm-variable-2">around</span>, <span class="cm-number">0</span>);
  <span class="cm-variable-2">context</span>.<span class="cm-property">scale</span>(<span class="cm-operator">-</span><span class="cm-number">1</span>, <span class="cm-number">1</span>);
  <span class="cm-variable-2">context</span>.<span class="cm-property">translate</span>(<span class="cm-operator">-</span><span class="cm-variable-2">around</span>, <span class="cm-number">0</span>);
}</pre>
<p><a class="p_ident" id="p_qob4Y7lZ5I" href="./16_canvas.html#p_qob4Y7lZ5I"></a>Ние преместваме оста у , където искаме да бъде нашето огледало, за да приложим огледалното отражение и накрая преместваме оста у обратно в нейното определено място в огледалната система. Следната картинка обяснява, защото това работи:</p>
<div class="image">
  <img src="./media/mirror.svg" alt="Mirroring around a vertical line">
</div>
<p><a class="p_ident" id="p_AGahdKv9Zv" href="./16_canvas.html#p_AGahdKv9Zv"></a>Това показва координатната система преди и след, отразявайки я през централната линия. Ако се направи триъгълник в положение  х-позиция, по подразбиране това е мястото, където е триъгълник 1. Извикването на <code>flipHorizontally</code> първо прави транслация на дясно, което ни отвежда до триъгълник 2. След мащабирането, обръща триъгълника обратно в позиция 3. Но това не е мястото, където трябва да бъде отразено от дадената линия. Второто извикване на <code>translate</code> поправя това - то анулира първоначалната транслация и прави триъгълник 4 да се появи точно там, където трябва.</p>
<p><a class="p_ident" id="p_akkrexzSeV" href="./16_canvas.html#p_akkrexzSeV"></a>Сега можем да нарисуваме огледален герой на позиция (100, 0) с обръщане на картината около вертикалния център на героя.</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class="c_ident" id="c_v9+6Eb8JBI" href="./16_canvas.html#c_v9+6Eb8JBI"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">canvas</span><span class="cm-tag cm-bracket">&gt;&lt;/</span><span class="cm-tag">canvas</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-keyword">var</span> <span class="cm-variable">cx</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">"canvas"</span>).<span class="cm-property">getContext</span>(<span class="cm-string">"2d"</span>);
  <span class="cm-keyword">var</span> <span class="cm-variable">img</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">createElement</span>(<span class="cm-string">"img"</span>);
  <span class="cm-variable">img</span>.<span class="cm-property">src</span> <span class="cm-operator">=</span> <span class="cm-string">"img/player.png"</span>;
  <span class="cm-keyword">var</span> <span class="cm-variable">spriteW</span> <span class="cm-operator">=</span> <span class="cm-number">24</span>, <span class="cm-variable">spriteH</span> <span class="cm-operator">=</span> <span class="cm-number">30</span>;
  <span class="cm-variable">img</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">"load"</span>, <span class="cm-keyword">function</span>() {
    <span class="cm-variable">flipHorizontally</span>(<span class="cm-variable">cx</span>, <span class="cm-number">100</span> <span class="cm-operator">+</span> <span class="cm-variable">spriteW</span> <span class="cm-operator">/</span> <span class="cm-number">2</span>);
    <span class="cm-variable">cx</span>.<span class="cm-property">drawImage</span>(<span class="cm-variable">img</span>, <span class="cm-number">0</span>, <span class="cm-number">0</span>, <span class="cm-variable">spriteW</span>, <span class="cm-variable">spriteH</span>,
                 <span class="cm-number">100</span>, <span class="cm-number">0</span>, <span class="cm-variable">spriteW</span>, <span class="cm-variable">spriteH</span>);
  });
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>
<h2><a class="h_ident" id="h_Z+iS7LhRr9" href="./16_canvas.html#h_Z+iS7LhRr9"></a>Съхраняване  и  изчистване  на трансформации</h2>
<p><a class="p_ident" id="p_Az5iI5GbrT" href="./16_canvas.html#p_Az5iI5GbrT"></a>Натрупването на трансформации е наоколо. Всичко останало чертаем след изготвянето на огледалния характер и го съпоставяме. Това може да е проблем.</p>
<p><a class="p_ident" id="p_4R4LetOdqr" href="./16_canvas.html#p_4R4LetOdqr"></a>Възможно е да запишем текущата трансформация, някои правят така рисуват и трансформират, а след това възстановяват старата трансформация. Това обикновено е правилното нещо, което трябва да направи дадена функция, която трябва да трансформира временно координатната система. Първо запазваме трансформационния код, който извиканата функция използва. След това функцията върши нещо (използвайки съществуващата трансформация ), евентуално добавяне на още трансформации. И на края се връща към трансформацията, с която сме започнали.</p>
<p><a class="p_ident" id="p_65OomGfaeV" href="./16_canvas.html#p_65OomGfaeV"></a>Методите <code>save</code> и <code>restore</code> в контекста на 2D върху платното, извършват този вид управление на трансформация. Те концептуално запазват натрупванията на трансформации. Когато извикаме <code>save</code> текущото състояние се вкарва в стека, а когато се извика <code>restore</code> състоянието на върха на стека се изважда и се използва, като контекст на настоящата трансформация.</p>
<p><a class="p_ident" id="p_+U4XOiej4f" href="./16_canvas.html#p_+U4XOiej4f"></a>Функцията <code>branch</code> в следващия пример илюстрира, какво може да направим с функция, която променя трансформацията и след това призовава друга функция (в този случай себе си), която продължава  рисуването в дадената трансформация.</p>
<p><a class="p_ident" id="p_2U+6WbJ0Or" href="./16_canvas.html#p_2U+6WbJ0Or"></a>Тази функция чертае <em>treelike</em> (дървовидна) фигура с чертаеща линия, премествайки центъра на координатната система в края на линията и извикваща себе си два пъти - първо завърта на ляво, а след това на дясно. Всяко извикване намалява дължината на изготвянето на клона и рекурсията спира, когато дължината падне под 8.</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class="c_ident" id="c_Dj0p46rTuu" href="./16_canvas.html#c_Dj0p46rTuu"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">canvas</span> <span class="cm-attribute">width</span>=<span class="cm-string">"600"</span> <span class="cm-attribute">height</span>=<span class="cm-string">"300"</span><span class="cm-tag cm-bracket">&gt;&lt;/</span><span class="cm-tag">canvas</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-keyword">var</span> <span class="cm-variable">cx</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">"canvas"</span>).<span class="cm-property">getContext</span>(<span class="cm-string">"2d"</span>);
  <span class="cm-keyword">function</span> <span class="cm-variable">branch</span>(<span class="cm-def">length</span>, <span class="cm-def">angle</span>, <span class="cm-def">scale</span>) {
    <span class="cm-variable">cx</span>.<span class="cm-property">fillRect</span>(<span class="cm-number">0</span>, <span class="cm-number">0</span>, <span class="cm-number">1</span>, <span class="cm-variable-2">length</span>);
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">length</span> <span class="cm-operator">&lt;</span> <span class="cm-number">8</span>) <span class="cm-keyword">return</span>;
    <span class="cm-variable">cx</span>.<span class="cm-property">save</span>();
    <span class="cm-variable">cx</span>.<span class="cm-property">translate</span>(<span class="cm-number">0</span>, <span class="cm-variable-2">length</span>);
    <span class="cm-variable">cx</span>.<span class="cm-property">rotate</span>(<span class="cm-operator">-</span><span class="cm-variable-2">angle</span>);
    <span class="cm-variable">branch</span>(<span class="cm-variable-2">length</span> <span class="cm-operator">*</span> <span class="cm-variable-2">scale</span>, <span class="cm-variable-2">angle</span>, <span class="cm-variable-2">scale</span>);
    <span class="cm-variable">cx</span>.<span class="cm-property">rotate</span>(<span class="cm-number">2</span> <span class="cm-operator">*</span> <span class="cm-variable-2">angle</span>);
    <span class="cm-variable">branch</span>(<span class="cm-variable-2">length</span> <span class="cm-operator">*</span> <span class="cm-variable-2">scale</span>, <span class="cm-variable-2">angle</span>, <span class="cm-variable-2">scale</span>);
    <span class="cm-variable">cx</span>.<span class="cm-property">restore</span>();
  }
  <span class="cm-variable">cx</span>.<span class="cm-property">translate</span>(<span class="cm-number">300</span>, <span class="cm-number">0</span>);
  <span class="cm-variable">branch</span>(<span class="cm-number">60</span>, <span class="cm-number">0.5</span>, <span class="cm-number">0.8</span>);
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>
<p><a class="p_ident" id="p_Fr9r9ZmPHu" href="./16_canvas.html#p_Fr9r9ZmPHu"></a>Ако извикванията на <code>save</code> и <code>restore</code> не бяха направени, второто рекурсивно извикване на <code>branch</code> ще се окаже в позицията и въртенето на първото извикване. То няма да бъде свързано към сегашното дърво, а по-скоро към най-вътрешния, най-десния клон на дървото съставено от първото извикване. Получената форма може да бъде интересна, но това не е рисунка на дърво.</p>
<h2 id="canvasdisplay"><a class="h_ident" id="h_TOqgrv5vzl" href="./16_canvas.html#h_TOqgrv5vzl"></a>Обратно  в  играта</h2>
<p><a class="p_ident" id="p_v/iifj4dhd" href="./16_canvas.html#p_v/iifj4dhd"></a>Сега вече знаем достатъчно за платното за рисуване, за да можем да работим върху базовото платно на дисплей системата на играта от <a href="./15_game.html#game">предишната глава</a>. Новият дисплей вече няма да показва само цветни кутии. Вместо това ще използваме <code>drawImage</code> да рисуваме картини, които представляват елементи на играта.</p>
<p><a class="p_ident" id="p_dy1myCUsaF" href="./16_canvas.html#p_dy1myCUsaF"></a>Първо ще определим типа на обекта на <code>CanvasDisplay</code> подкрепящ същия интерфейс, както <code>DOMDisplay</code> от <a href="./15_game.html#domdisplay">Глава 15</a>, а именно методите <code>drawFrame</code> и <code>clear</code>.</p>
<p><a class="p_ident" id="p_H/XEh6pFg7" href="./16_canvas.html#p_H/XEh6pFg7"></a>Този обект съдържа малко повече информация от колкото <code>DOMDisplay</code>. Вместо да използва позицията за скролване на своя DOM елемент, той проследява собствения си демонстрационен прозорец, който ни казва, каква част от нивото гледаме в момента. Той също така проследява времето и употребата му, за да реши коя анимационна рамка да използва. И най-накрая, поддържа <code>flipPlayer</code> свойството, така че дори когато играчът стои на едно място, е с лице обърнато в посоката на последното преместване.</p>
<pre data-language="javascript" class="snippet cm-s-default" data-sandbox="game"><a class="c_ident" id="c_HHQyVLbj+1" href="./16_canvas.html#c_HHQyVLbj+1"></a><span class="cm-keyword">function</span> <span class="cm-variable">CanvasDisplay</span>(<span class="cm-def">parent</span>, <span class="cm-def">level</span>) {
  <span class="cm-keyword">this</span>.<span class="cm-property">canvas</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">createElement</span>(<span class="cm-string">"canvas"</span>);
  <span class="cm-keyword">this</span>.<span class="cm-property">canvas</span>.<span class="cm-property">width</span> <span class="cm-operator">=</span> <span class="cm-variable">Math</span>.<span class="cm-property">min</span>(<span class="cm-number">600</span>, <span class="cm-variable-2">level</span>.<span class="cm-property">width</span> <span class="cm-operator">*</span> <span class="cm-variable">scale</span>);
  <span class="cm-keyword">this</span>.<span class="cm-property">canvas</span>.<span class="cm-property">height</span> <span class="cm-operator">=</span> <span class="cm-variable">Math</span>.<span class="cm-property">min</span>(<span class="cm-number">450</span>, <span class="cm-variable-2">level</span>.<span class="cm-property">height</span> <span class="cm-operator">*</span> <span class="cm-variable">scale</span>);
  <span class="cm-variable-2">parent</span>.<span class="cm-property">appendChild</span>(<span class="cm-keyword">this</span>.<span class="cm-property">canvas</span>);
  <span class="cm-keyword">this</span>.<span class="cm-property">cx</span> <span class="cm-operator">=</span> <span class="cm-keyword">this</span>.<span class="cm-property">canvas</span>.<span class="cm-property">getContext</span>(<span class="cm-string">"2d"</span>);

  <span class="cm-keyword">this</span>.<span class="cm-property">level</span> <span class="cm-operator">=</span> <span class="cm-variable-2">level</span>;
  <span class="cm-keyword">this</span>.<span class="cm-property">animationTime</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>;
  <span class="cm-keyword">this</span>.<span class="cm-property">flipPlayer</span> <span class="cm-operator">=</span> <span class="cm-atom">false</span>;

  <span class="cm-keyword">this</span>.<span class="cm-property">viewport</span> <span class="cm-operator">=</span> {
    <span class="cm-property">left</span>: <span class="cm-number">0</span>,
    <span class="cm-property">top</span>: <span class="cm-number">0</span>,
    <span class="cm-property">width</span>: <span class="cm-keyword">this</span>.<span class="cm-property">canvas</span>.<span class="cm-property">width</span> <span class="cm-operator">/</span> <span class="cm-variable">scale</span>,
    <span class="cm-property">height</span>: <span class="cm-keyword">this</span>.<span class="cm-property">canvas</span>.<span class="cm-property">height</span> <span class="cm-operator">/</span> <span class="cm-variable">scale</span>
  };

  <span class="cm-keyword">this</span>.<span class="cm-property">drawFrame</span>(<span class="cm-number">0</span>);
}

<span class="cm-variable">CanvasDisplay</span>.<span class="cm-property">prototype</span>.<span class="cm-property">clear</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>() {
  <span class="cm-keyword">this</span>.<span class="cm-property">canvas</span>.<span class="cm-property">parentNode</span>.<span class="cm-property">removeChild</span>(<span class="cm-keyword">this</span>.<span class="cm-property">canvas</span>);
};</pre>
<p><a class="p_ident" id="p_blt6VbEw4l" href="./16_canvas.html#p_blt6VbEw4l"></a>Брояча <code>animationTime</code> е причината, поради която подадохме размерът на стъпката на <code>drawFrame</code> в
<a href="./15_game.html#domdisplay">Глава 15</a>, въпреки че <code>DOMDisplay</code> не го използва. Нашата нова <code>drawFrame</code> функция използва брояча за проследяване на времето, така че да може да превключваме между анимационните рамки основани на текущото време.</p>
<pre data-language="javascript" class="snippet cm-s-default" data-sandbox="game"><a class="c_ident" id="c_L5SVcjdikr" href="./16_canvas.html#c_L5SVcjdikr"></a><span class="cm-variable">CanvasDisplay</span>.<span class="cm-property">prototype</span>.<span class="cm-property">drawFrame</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">step</span>) {
  <span class="cm-keyword">this</span>.<span class="cm-property">animationTime</span> <span class="cm-operator">+=</span> <span class="cm-variable-2">step</span>;

  <span class="cm-keyword">this</span>.<span class="cm-property">updateViewport</span>();
  <span class="cm-keyword">this</span>.<span class="cm-property">clearDisplay</span>();
  <span class="cm-keyword">this</span>.<span class="cm-property">drawBackground</span>();
  <span class="cm-keyword">this</span>.<span class="cm-property">drawActors</span>();
};</pre>
<p><a class="p_ident" id="p_hwAtbz1fs3" href="./16_canvas.html#p_hwAtbz1fs3"></a>Другите които ползват проследяването на времето са методът за актуализиране на изгледа на текущата позиция на играчите, чертане на фона, изпълването на цялото платно с фонов цвят и актьорите върху него. Имайте в предвид, че това е различен подход от този в <a href="./15_game.html#domdisplay">Глава 15</a>, където чертаем фона веднъж и скролваме опакования DOM елемент за да го преместим.</p>
<p><a class="p_ident" id="p_sX9ENmCEO9" href="./16_canvas.html#p_sX9ENmCEO9"></a>Защото формите на платното са само пиксели и след като ги начертаем няма начин да ги преместим (или отстраним). Единствения начин да се актуализира дисплея на платното е да го изчистим и преначертаем сцената отново.</p>
<p><a class="p_ident" id="p_Kn4mJDmduk" href="./16_canvas.html#p_Kn4mJDmduk"></a>Методът <code>updateViewport</code> е подобен на <code>DOMDisplay</code>-скрол метода <code>scrollPlayerIntoView</code>. Той проверява дали играчът е твърде близо до ръба на екрана и движи изгледа, когато случаят е такъв.</p>
<pre data-language="javascript" class="snippet cm-s-default" data-sandbox="game"><a class="c_ident" id="c_MzrEz+RF51" href="./16_canvas.html#c_MzrEz+RF51"></a><span class="cm-variable">CanvasDisplay</span>.<span class="cm-property">prototype</span>.<span class="cm-property">updateViewport</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>() {
  <span class="cm-keyword">var</span> <span class="cm-def">view</span> <span class="cm-operator">=</span> <span class="cm-keyword">this</span>.<span class="cm-property">viewport</span>, <span class="cm-def">margin</span> <span class="cm-operator">=</span> <span class="cm-variable-2">view</span>.<span class="cm-property">width</span> <span class="cm-operator">/</span> <span class="cm-number">3</span>;
  <span class="cm-keyword">var</span> <span class="cm-def">player</span> <span class="cm-operator">=</span> <span class="cm-keyword">this</span>.<span class="cm-property">level</span>.<span class="cm-property">player</span>;
  <span class="cm-keyword">var</span> <span class="cm-def">center</span> <span class="cm-operator">=</span> <span class="cm-variable-2">player</span>.<span class="cm-property">pos</span>.<span class="cm-property">plus</span>(<span class="cm-variable-2">player</span>.<span class="cm-property">size</span>.<span class="cm-property">times</span>(<span class="cm-number">0.5</span>));

  <span class="cm-keyword">if</span> (<span class="cm-variable-2">center</span>.<span class="cm-property">x</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">view</span>.<span class="cm-property">left</span> <span class="cm-operator">+</span> <span class="cm-variable-2">margin</span>)
    <span class="cm-variable-2">view</span>.<span class="cm-property">left</span> <span class="cm-operator">=</span> <span class="cm-variable">Math</span>.<span class="cm-property">max</span>(<span class="cm-variable-2">center</span>.<span class="cm-property">x</span> <span class="cm-operator">-</span> <span class="cm-variable-2">margin</span>, <span class="cm-number">0</span>);
  <span class="cm-keyword">else</span> <span class="cm-keyword">if</span> (<span class="cm-variable-2">center</span>.<span class="cm-property">x</span> <span class="cm-operator">&gt;</span> <span class="cm-variable-2">view</span>.<span class="cm-property">left</span> <span class="cm-operator">+</span> <span class="cm-variable-2">view</span>.<span class="cm-property">width</span> <span class="cm-operator">-</span> <span class="cm-variable-2">margin</span>)
    <span class="cm-variable-2">view</span>.<span class="cm-property">left</span> <span class="cm-operator">=</span> <span class="cm-variable">Math</span>.<span class="cm-property">min</span>(<span class="cm-variable-2">center</span>.<span class="cm-property">x</span> <span class="cm-operator">+</span> <span class="cm-variable-2">margin</span> <span class="cm-operator">-</span> <span class="cm-variable-2">view</span>.<span class="cm-property">width</span>,
                         <span class="cm-keyword">this</span>.<span class="cm-property">level</span>.<span class="cm-property">width</span> <span class="cm-operator">-</span> <span class="cm-variable-2">view</span>.<span class="cm-property">width</span>);
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">center</span>.<span class="cm-property">y</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">view</span>.<span class="cm-property">top</span> <span class="cm-operator">+</span> <span class="cm-variable-2">margin</span>)
    <span class="cm-variable-2">view</span>.<span class="cm-property">top</span> <span class="cm-operator">=</span> <span class="cm-variable">Math</span>.<span class="cm-property">max</span>(<span class="cm-variable-2">center</span>.<span class="cm-property">y</span> <span class="cm-operator">-</span> <span class="cm-variable-2">margin</span>, <span class="cm-number">0</span>);
  <span class="cm-keyword">else</span> <span class="cm-keyword">if</span> (<span class="cm-variable-2">center</span>.<span class="cm-property">y</span> <span class="cm-operator">&gt;</span> <span class="cm-variable-2">view</span>.<span class="cm-property">top</span> <span class="cm-operator">+</span> <span class="cm-variable-2">view</span>.<span class="cm-property">height</span> <span class="cm-operator">-</span> <span class="cm-variable-2">margin</span>)
    <span class="cm-variable-2">view</span>.<span class="cm-property">top</span> <span class="cm-operator">=</span> <span class="cm-variable">Math</span>.<span class="cm-property">min</span>(<span class="cm-variable-2">center</span>.<span class="cm-property">y</span> <span class="cm-operator">+</span> <span class="cm-variable-2">margin</span> <span class="cm-operator">-</span> <span class="cm-variable-2">view</span>.<span class="cm-property">height</span>,
                        <span class="cm-keyword">this</span>.<span class="cm-property">level</span>.<span class="cm-property">height</span> <span class="cm-operator">-</span> <span class="cm-variable-2">view</span>.<span class="cm-property">height</span>);
};</pre>
<p><a class="p_ident" id="p_qSUMwlAFeW" href="./16_canvas.html#p_qSUMwlAFeW"></a>Извикванията на <code>Math.max</code> и <code>Math.min</code> гарантират, че демонстрационния прозорец не показва пространството извън нивото. <code>Math.max(x, 0)</code> гарантира, че полученият брой не е по-малък то нула. <code>Math.min</code> по подобен начин, подсигурява стойността да стои под определената граница.</p>
<p><a class="p_ident" id="p_uxQ4EAtiQh" href="./16_canvas.html#p_uxQ4EAtiQh"></a>При спиране на дисплея, ще използваме по-различен цвят в зависимост от това дали играча печели (по-светло) или губи (по-тъмно).</p>
<pre data-language="javascript" class="snippet cm-s-default" data-sandbox="game"><a class="c_ident" id="c_o8QL4qiSHv" href="./16_canvas.html#c_o8QL4qiSHv"></a><span class="cm-variable">CanvasDisplay</span>.<span class="cm-property">prototype</span>.<span class="cm-property">clearDisplay</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>() {
  <span class="cm-keyword">if</span> (<span class="cm-keyword">this</span>.<span class="cm-property">level</span>.<span class="cm-property">status</span> <span class="cm-operator">==</span> <span class="cm-string">"won"</span>)
    <span class="cm-keyword">this</span>.<span class="cm-property">cx</span>.<span class="cm-property">fillStyle</span> <span class="cm-operator">=</span> <span class="cm-string">"rgb(68, 191, 255)"</span>;
  <span class="cm-keyword">else</span> <span class="cm-keyword">if</span> (<span class="cm-keyword">this</span>.<span class="cm-property">level</span>.<span class="cm-property">status</span> <span class="cm-operator">==</span> <span class="cm-string">"lost"</span>)
    <span class="cm-keyword">this</span>.<span class="cm-property">cx</span>.<span class="cm-property">fillStyle</span> <span class="cm-operator">=</span> <span class="cm-string">"rgb(44, 136, 214)"</span>;
  <span class="cm-keyword">else</span>
    <span class="cm-keyword">this</span>.<span class="cm-property">cx</span>.<span class="cm-property">fillStyle</span> <span class="cm-operator">=</span> <span class="cm-string">"rgb(52, 166, 251)"</span>;
  <span class="cm-keyword">this</span>.<span class="cm-property">cx</span>.<span class="cm-property">fillRect</span>(<span class="cm-number">0</span>, <span class="cm-number">0</span>,
                   <span class="cm-keyword">this</span>.<span class="cm-property">canvas</span>.<span class="cm-property">width</span>, <span class="cm-keyword">this</span>.<span class="cm-property">canvas</span>.<span class="cm-property">height</span>);
};</pre>
<p><a class="p_ident" id="p_TjOnlogmqf" href="./16_canvas.html#p_TjOnlogmqf"></a>За да начертаем задния план, ще използваме плочите, които са видими в текущия демонстрационен прозорец, използвайки същия подход използван в <code>obstacleAt</code> в <a href="./15_game.html#viewport">предишната глава</a>.</p>
<pre data-language="javascript" class="snippet cm-s-default" data-sandbox="game"><a class="c_ident" id="c_IWmtRFoUx5" href="./16_canvas.html#c_IWmtRFoUx5"></a><span class="cm-keyword">var</span> <span class="cm-variable">otherSprites</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">createElement</span>(<span class="cm-string">"img"</span>);
<span class="cm-variable">otherSprites</span>.<span class="cm-property">src</span> <span class="cm-operator">=</span> <span class="cm-string">"img/sprites.png"</span>;

<span class="cm-variable">CanvasDisplay</span>.<span class="cm-property">prototype</span>.<span class="cm-property">drawBackground</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>() {
  <span class="cm-keyword">var</span> <span class="cm-def">view</span> <span class="cm-operator">=</span> <span class="cm-keyword">this</span>.<span class="cm-property">viewport</span>;
  <span class="cm-keyword">var</span> <span class="cm-def">xStart</span> <span class="cm-operator">=</span> <span class="cm-variable">Math</span>.<span class="cm-property">floor</span>(<span class="cm-variable-2">view</span>.<span class="cm-property">left</span>);
  <span class="cm-keyword">var</span> <span class="cm-def">xEnd</span> <span class="cm-operator">=</span> <span class="cm-variable">Math</span>.<span class="cm-property">ceil</span>(<span class="cm-variable-2">view</span>.<span class="cm-property">left</span> <span class="cm-operator">+</span> <span class="cm-variable-2">view</span>.<span class="cm-property">width</span>);
  <span class="cm-keyword">var</span> <span class="cm-def">yStart</span> <span class="cm-operator">=</span> <span class="cm-variable">Math</span>.<span class="cm-property">floor</span>(<span class="cm-variable-2">view</span>.<span class="cm-property">top</span>);
  <span class="cm-keyword">var</span> <span class="cm-def">yEnd</span> <span class="cm-operator">=</span> <span class="cm-variable">Math</span>.<span class="cm-property">ceil</span>(<span class="cm-variable-2">view</span>.<span class="cm-property">top</span> <span class="cm-operator">+</span> <span class="cm-variable-2">view</span>.<span class="cm-property">height</span>);

  <span class="cm-keyword">for</span> (<span class="cm-keyword">var</span> <span class="cm-def">y</span> <span class="cm-operator">=</span> <span class="cm-variable-2">yStart</span>; <span class="cm-variable-2">y</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">yEnd</span>; <span class="cm-variable-2">y</span><span class="cm-operator">++</span>) {
    <span class="cm-keyword">for</span> (<span class="cm-keyword">var</span> <span class="cm-def">x</span> <span class="cm-operator">=</span> <span class="cm-variable-2">xStart</span>; <span class="cm-variable-2">x</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">xEnd</span>; <span class="cm-variable-2">x</span><span class="cm-operator">++</span>) {
      <span class="cm-keyword">var</span> <span class="cm-def">tile</span> <span class="cm-operator">=</span> <span class="cm-keyword">this</span>.<span class="cm-property">level</span>.<span class="cm-property">grid</span>[<span class="cm-variable-2">y</span>][<span class="cm-variable-2">x</span>];
      <span class="cm-keyword">if</span> (<span class="cm-variable-2">tile</span> <span class="cm-operator">==</span> <span class="cm-atom">null</span>) <span class="cm-keyword">continue</span>;
      <span class="cm-keyword">var</span> <span class="cm-def">screenX</span> <span class="cm-operator">=</span> (<span class="cm-variable-2">x</span> <span class="cm-operator">-</span> <span class="cm-variable-2">view</span>.<span class="cm-property">left</span>) <span class="cm-operator">*</span> <span class="cm-variable">scale</span>;
      <span class="cm-keyword">var</span> <span class="cm-def">screenY</span> <span class="cm-operator">=</span> (<span class="cm-variable-2">y</span> <span class="cm-operator">-</span> <span class="cm-variable-2">view</span>.<span class="cm-property">top</span>) <span class="cm-operator">*</span> <span class="cm-variable">scale</span>;
      <span class="cm-keyword">var</span> <span class="cm-def">tileX</span> <span class="cm-operator">=</span> <span class="cm-variable-2">tile</span> <span class="cm-operator">==</span> <span class="cm-string">"lava"</span> <span class="cm-operator">?</span> <span class="cm-variable">scale</span> : <span class="cm-number">0</span>;
      <span class="cm-keyword">this</span>.<span class="cm-property">cx</span>.<span class="cm-property">drawImage</span>(<span class="cm-variable">otherSprites</span>,
                        <span class="cm-variable-2">tileX</span>,         <span class="cm-number">0</span>, <span class="cm-variable">scale</span>, <span class="cm-variable">scale</span>,
                        <span class="cm-variable-2">screenX</span>, <span class="cm-variable-2">screenY</span>, <span class="cm-variable">scale</span>, <span class="cm-variable">scale</span>);
    }
  }
};</pre>
<p><a class="p_ident" id="p_exCLyNQQL6" href="./16_canvas.html#p_exCLyNQQL6"></a>Плочите, които не са празни (нула) са съставени с <code>drawImage</code>. Изображението <code>otherSprites</code> съдържа снимките, използвани за други елементи на играча. То съдържа от ляво на дясно, плочите на стената, на лавата и спрайт на монетата.</p>
<div class="image">
  <img src="./media/sprites_big.png" alt="Sprites for our game">
</div>
<p><a class="p_ident" id="p_1R4HdSFR8E" href="./16_canvas.html#p_1R4HdSFR8E"></a>Основата на плочите е 20 на 20 пиксела, тъй като ще използваме същия мащаб, както в <code>DOMDisplay</code>. По този начин се компенсира отместването на плочите за лавата с 20 (стойността на <code>scale</code> променливата) и отместването на стените с 0.</p>
<p><a class="p_ident" id="p_KIwkr/Frrz" href="./16_canvas.html#p_KIwkr/Frrz"></a>Ние не се притесняваме за изчакването на зареждането на спрайта. Извикването на <code>drawImage</code> с образ, който все още не е зареден, просто няма да прави нищо. По този начин, може да не успее да направи играта правилно първите няколко кадъра, докато изображението все още се зарежда, но това не е сериозен проблем. Тъй като ние продължаваме да актуализираме екрана и правилната сцена ще се появи веднага, след като зареждането приключи.</p>
<p><a class="p_ident" id="p_/1DXjZpAsq" href="./16_canvas.html#p_/1DXjZpAsq"></a>Характера за ходене показан по-рано, ще се използва за представяне на играча. Кода на чертането трябва да избере правилната посока на спрайта и се базира на текущите движения на играча. Първите осем спрайта съдържат анимацията на ходенето. Когато играча се движи по протежение на пода, ние преминаваме през тях на базата на размерите на дисплей - <code>animationTime</code> свойството. Това се измерва в секунди, и ние искаме да се движи в рамките на 12 кадъра в секунда, така че времето се умножава по 12 първо. Когато играчът стои на място, ние не ползваме деветия спрайт. По време на скока, като се позоваваме на факта, че вертикалната скорост не е нула  използваме деветия най-десен спрайт.</p>
<p><a class="p_ident" id="p_wuDMxn8vbx" href="./16_canvas.html#p_wuDMxn8vbx"></a>Тъй като спрайтовете са малко по-широки от обекта на играча - 24 вместо 16 пиксела, за да се позволи известно пространство за ръцете и краката, метода трябва да коригира х-координата и ширината от дадените размери (<code>playerXOverlap</code>).</p>
<pre data-language="javascript" class="snippet cm-s-default" data-sandbox="game"><a class="c_ident" id="c_+F2ZqW5kde" href="./16_canvas.html#c_+F2ZqW5kde"></a><span class="cm-keyword">var</span> <span class="cm-variable">playerSprites</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">createElement</span>(<span class="cm-string">"img"</span>);
<span class="cm-variable">playerSprites</span>.<span class="cm-property">src</span> <span class="cm-operator">=</span> <span class="cm-string">"img/player.png"</span>;
<span class="cm-keyword">var</span> <span class="cm-variable">playerXOverlap</span> <span class="cm-operator">=</span> <span class="cm-number">4</span>;

<span class="cm-variable">CanvasDisplay</span>.<span class="cm-property">prototype</span>.<span class="cm-property">drawPlayer</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">x</span>, <span class="cm-def">y</span>, <span class="cm-def">width</span>,
                                              <span class="cm-def">height</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">sprite</span> <span class="cm-operator">=</span> <span class="cm-number">8</span>, <span class="cm-def">player</span> <span class="cm-operator">=</span> <span class="cm-keyword">this</span>.<span class="cm-property">level</span>.<span class="cm-property">player</span>;
  <span class="cm-variable-2">width</span> <span class="cm-operator">+=</span> <span class="cm-variable">playerXOverlap</span> <span class="cm-operator">*</span> <span class="cm-number">2</span>;
  <span class="cm-variable-2">x</span> <span class="cm-operator">-=</span> <span class="cm-variable">playerXOverlap</span>;
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">player</span>.<span class="cm-property">speed</span>.<span class="cm-property">x</span> <span class="cm-operator">!=</span> <span class="cm-number">0</span>)
    <span class="cm-keyword">this</span>.<span class="cm-property">flipPlayer</span> <span class="cm-operator">=</span> <span class="cm-variable-2">player</span>.<span class="cm-property">speed</span>.<span class="cm-property">x</span> <span class="cm-operator">&lt;</span> <span class="cm-number">0</span>;

  <span class="cm-keyword">if</span> (<span class="cm-variable-2">player</span>.<span class="cm-property">speed</span>.<span class="cm-property">y</span> <span class="cm-operator">!=</span> <span class="cm-number">0</span>)
    <span class="cm-variable-2">sprite</span> <span class="cm-operator">=</span> <span class="cm-number">9</span>;
  <span class="cm-keyword">else</span> <span class="cm-keyword">if</span> (<span class="cm-variable-2">player</span>.<span class="cm-property">speed</span>.<span class="cm-property">x</span> <span class="cm-operator">!=</span> <span class="cm-number">0</span>)
    <span class="cm-variable-2">sprite</span> <span class="cm-operator">=</span> <span class="cm-variable">Math</span>.<span class="cm-property">floor</span>(<span class="cm-keyword">this</span>.<span class="cm-property">animationTime</span> <span class="cm-operator">*</span> <span class="cm-number">12</span>) <span class="cm-operator">%</span> <span class="cm-number">8</span>;

  <span class="cm-keyword">this</span>.<span class="cm-property">cx</span>.<span class="cm-property">save</span>();
  <span class="cm-keyword">if</span> (<span class="cm-keyword">this</span>.<span class="cm-property">flipPlayer</span>)
    <span class="cm-variable">flipHorizontally</span>(<span class="cm-keyword">this</span>.<span class="cm-property">cx</span>, <span class="cm-variable-2">x</span> <span class="cm-operator">+</span> <span class="cm-variable-2">width</span> <span class="cm-operator">/</span> <span class="cm-number">2</span>);

  <span class="cm-keyword">this</span>.<span class="cm-property">cx</span>.<span class="cm-property">drawImage</span>(<span class="cm-variable">playerSprites</span>,
                    <span class="cm-variable-2">sprite</span> <span class="cm-operator">*</span> <span class="cm-variable-2">width</span>, <span class="cm-number">0</span>, <span class="cm-variable-2">width</span>, <span class="cm-variable-2">height</span>,
                    <span class="cm-variable-2">x</span>,              <span class="cm-variable-2">y</span>, <span class="cm-variable-2">width</span>, <span class="cm-variable-2">height</span>);

  <span class="cm-keyword">this</span>.<span class="cm-property">cx</span>.<span class="cm-property">restore</span>();
};</pre>
<p><a class="p_ident" id="p_gswQ2kj9pD" href="./16_canvas.html#p_gswQ2kj9pD"></a>Метода <code>drawPlayer</code> се извиква с <code>drawActors</code>, който изготвя всички участници в играта.</p>
<pre data-language="javascript" class="snippet cm-s-default" data-sandbox="game"><a class="c_ident" id="c_aB4vicy3VE" href="./16_canvas.html#c_aB4vicy3VE"></a><span class="cm-variable">CanvasDisplay</span>.<span class="cm-property">prototype</span>.<span class="cm-property">drawActors</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>() {
  <span class="cm-keyword">this</span>.<span class="cm-property">level</span>.<span class="cm-property">actors</span>.<span class="cm-property">forEach</span>(<span class="cm-keyword">function</span>(<span class="cm-def">actor</span>) {
    <span class="cm-keyword">var</span> <span class="cm-def">width</span> <span class="cm-operator">=</span> <span class="cm-variable-2">actor</span>.<span class="cm-property">size</span>.<span class="cm-property">x</span> <span class="cm-operator">*</span> <span class="cm-variable">scale</span>;
    <span class="cm-keyword">var</span> <span class="cm-def">height</span> <span class="cm-operator">=</span> <span class="cm-variable-2">actor</span>.<span class="cm-property">size</span>.<span class="cm-property">y</span> <span class="cm-operator">*</span> <span class="cm-variable">scale</span>;
    <span class="cm-keyword">var</span> <span class="cm-def">x</span> <span class="cm-operator">=</span> (<span class="cm-variable-2">actor</span>.<span class="cm-property">pos</span>.<span class="cm-property">x</span> <span class="cm-operator">-</span> <span class="cm-keyword">this</span>.<span class="cm-property">viewport</span>.<span class="cm-property">left</span>) <span class="cm-operator">*</span> <span class="cm-variable">scale</span>;
    <span class="cm-keyword">var</span> <span class="cm-def">y</span> <span class="cm-operator">=</span> (<span class="cm-variable-2">actor</span>.<span class="cm-property">pos</span>.<span class="cm-property">y</span> <span class="cm-operator">-</span> <span class="cm-keyword">this</span>.<span class="cm-property">viewport</span>.<span class="cm-property">top</span>) <span class="cm-operator">*</span> <span class="cm-variable">scale</span>;
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">actor</span>.<span class="cm-property">type</span> <span class="cm-operator">==</span> <span class="cm-string">"player"</span>) {
      <span class="cm-keyword">this</span>.<span class="cm-property">drawPlayer</span>(<span class="cm-variable-2">x</span>, <span class="cm-variable-2">y</span>, <span class="cm-variable-2">width</span>, <span class="cm-variable-2">height</span>);
    } <span class="cm-keyword">else</span> {
      <span class="cm-keyword">var</span> <span class="cm-def">tileX</span> <span class="cm-operator">=</span> (<span class="cm-variable-2">actor</span>.<span class="cm-property">type</span> <span class="cm-operator">==</span> <span class="cm-string">"coin"</span> <span class="cm-operator">?</span> <span class="cm-number">2</span> : <span class="cm-number">1</span>) <span class="cm-operator">*</span> <span class="cm-variable">scale</span>;
      <span class="cm-keyword">this</span>.<span class="cm-property">cx</span>.<span class="cm-property">drawImage</span>(<span class="cm-variable">otherSprites</span>,
                        <span class="cm-variable-2">tileX</span>, <span class="cm-number">0</span>, <span class="cm-variable-2">width</span>, <span class="cm-variable-2">height</span>,
                        <span class="cm-variable-2">x</span>,     <span class="cm-variable-2">y</span>, <span class="cm-variable-2">width</span>, <span class="cm-variable-2">height</span>);
    }
  }, <span class="cm-keyword">this</span>);
};</pre>
<p><a class="p_ident" id="p_PD+LPXwCgk" href="./16_canvas.html#p_PD+LPXwCgk"></a>При изготвянето на нещо, което не е играч, ние гледаме неговият вид, за да открием офсета на правилния спрайт. Плочите за лава се намират с офсет 20, а спрайта на монетата се намира с офсет 40 (два пъти скалата).</p>
<p><a class="p_ident" id="p_e6Z9O4bib+" href="./16_canvas.html#p_e6Z9O4bib+"></a>Ние трябва да извадим позицията на изгледа, когато изчисляваме положението на актьора, тъй като точка (0, 0) на нашето платно съответства на горния ляв ъгъл на изгледа, а не на горния ляв ъгъл на нивото. Можем също да използваме транслация за това. Така или иначе работи.</p>
<p><a class="p_ident" id="p_4VReSkKraV" href="./16_canvas.html#p_4VReSkKraV"></a>Показания следващ малък документ, свързва новия дисплей в <code>runGame</code>:</p>
<pre data-language="text/html" class="snippet cm-s-default" data-sandbox="game" data-focus="true"><a class="c_ident" id="c_VOS8HEBUxB" href="./16_canvas.html#c_VOS8HEBUxB"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">body</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
    <span class="cm-variable">runGame</span>(<span class="cm-variable">GAME_LEVELS</span>, <span class="cm-variable">CanvasDisplay</span>);
  <span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">body</span><span class="cm-tag cm-bracket">&gt;</span></pre>
<h2 id="graphics_tradeoffs"><a class="h_ident" id="h_T6CfghQSfx" href="./16_canvas.html#h_T6CfghQSfx"></a>Избор  на  графични  интерфейси</h2>
<p><a class="p_ident" id="p_hiYOCc2tar" href="./16_canvas.html#p_hiYOCc2tar"></a>Винаги, когато имате нужда от генериране на графики в браузъра, можете да избирате между обикновен HTML, SVG и canvas (платно). Няма най-добър вариант, който да работи във всички ситуации. Всеки вариант има силни и слаби страни.</p>
<p><a class="p_ident" id="p_O7BQaYbnwn" href="./16_canvas.html#p_O7BQaYbnwn"></a>Обикновен HTML има предимството, че е прост. Той също така се интегрира добре с текст. И двата- SVG и canvas ви позволяват да изготвите текст, но те няма да ви помогнат да позиционирате този текст или го увиете, когато заеме повече от един ред. В HTML базиран на картина е лесно да се включат блокове текст.</p>
<p><a class="p_ident" id="p_6uH6l730WJ" href="./16_canvas.html#p_6uH6l730WJ"></a>SVG може да се използва за производство на чисти графики, които изглеждат добре на всяко ниво на увеличение. Той е по труден за  използване  от обикновен HTML, но е много по-мощен.</p>
<p><a class="p_ident" id="p_J5B7lFXtzE" href="./16_canvas.html#p_J5B7lFXtzE"></a>И двата - SVG  и  HTML изграждат структура от данни (DOM), които представляват картината. Това прави възможно да се променя, след като елементите са изготвени. Ако трябва да се промени на няколко пъти малка част от голямата  картина в отговор на това, което потребителя прави или част от анимацията, правенето на това в платното може да бъде ненужно скъпо. DOM също ни позволява да регистрираме манипулатори за събития на мишката за всеки елемент от картината (дори форми, изготвени с SVG). Но не може да направите това с <em>canvas</em>.</p>
<p><a class="p_ident" id="p_7N4OSlG5eS" href="./16_canvas.html#p_7N4OSlG5eS"></a>Но пиксело-ориентирания подход на <em>canvas</em> може да бъде предимство при изготвянето на огромно количество дребни елементи. Фактът, че не се изгражда структура от данни, а само многократно обръща върху същата повърхност пикселите, платното ни дава по-ниска цена на формата.</p>
<p><a class="p_ident" id="p_6P4A05RVAk" href="./16_canvas.html#p_6P4A05RVAk"></a>Има ефекти, като например рендерирането на един пиксел в даден момент (например използвайки <em>ray tracer</em>) или <em>postprocessing</em> изображение с JavaScript (замъгляване или изкривяване), което може да бъде обработено реалистично само с пиксел базирана техника.</p>
<p><a class="p_ident" id="p_lecWO5A8ae" href="./16_canvas.html#p_lecWO5A8ae"></a>В някои случаи може да искаме да комбинираме няколко от тези техники. Например, може да направим графика с SVG или платно, но да покажем текстова информация чрез позициониране на HTML елемента в горната част на картинката.</p>
<p><a class="p_ident" id="p_nXWEbGkTBm" href="./16_canvas.html#p_nXWEbGkTBm"></a>За не взискателни  приложения, наистина няма толкова значение, кой интерфейс ще изберем. <a href="./16_canvas.html#canvasdisplay">Вторият дисплей</a> който построихме за нашата игра в тази глава, може да бъде приложен с помощта на някоя от тези три графични технологии, тъй като не е необходимо да се направи текст, да се взаимодейства с мишката или да работи с изключително голямо количество елементи.</p>
<h2><a class="h_ident" id="h_ErccPg/l98" href="./16_canvas.html#h_ErccPg/l98"></a>Резюме</h2>
<p><a class="p_ident" id="p_tJH36yWkVt" href="./16_canvas.html#p_tJH36yWkVt"></a>В тази глава обсъдихме техники за рисуване на графики в браузъра, като се фокусирахме на <code>&lt;canvas&gt;</code> елементите.</p>
<p><a class="p_ident" id="p_zTR1kU1R2F" href="./16_canvas.html#p_zTR1kU1R2F"></a>Разклонението на платното представлява област в документ, който нашата програма може да разчита. Този чертеж се осъществява чрез контекста на графичен обект създаден с <code>getContext</code> метода.</p>
<p><a class="p_ident" id="p_77n8vdtsoS" href="./16_canvas.html#p_77n8vdtsoS"></a>Интерфейса на 2D чертането ни позволява да запълним или очертаем различни форми. Контекста на свойството <code>fillStyle</code> определя, как да запълним тези форми. Свойствата <code>strokeStyle</code> и <code>lineWidth</code> контролират начина на чертане на линиите.</p>
<p><a class="p_ident" id="p_p9lwBrZeDB" href="./16_canvas.html#p_p9lwBrZeDB"></a>Правоъгълници и части от текст могат да се направят с едно извикване на метод. Методите <code>fillRect</code> and <code>strokeRect</code> чертаят правоъгълници, а методите <code>fillText</code> и <code>strokeText</code> изготвят текста. За да изградим определени форми първо трябва да изградим път (<em>path</em>).</p>
<p><a class="p_ident" id="p_+WESqzV0sH" href="./16_canvas.html#p_+WESqzV0sH"></a>С извикването на <code>beginPath</code> започва новия път. Редица други методи добавят линии и криви на текущия път. Например <code>lineTo</code> за добавяне на права линия. Когато един път е завършен, той може да бъде запълнен със <code>fill</code> метод или очертан със <code>stroke</code> метода.</p>
<p><a class="p_ident" id="p_DjIq4BWBzl" href="./16_canvas.html#p_DjIq4BWBzl"></a>Преместването на пиксели от изображението или друго платно върху нашето платно се извършва с <code>drawImage</code> метода. По подразбиране, този метод се основава на цялото изображение -източник, но като му даде повече параметри, можем да копираме определена област от изображението. Ние използвахме това в нашата игра, като копирахме няколко индивидуални пози от изображението на характера на играта, което съдържа много такива пози.</p>
<p><a class="p_ident" id="p_EWHXtIfgMN" href="./16_canvas.html#p_EWHXtIfgMN"></a>Трансформациите ни позволяват да направим форма в няколко посоки. Контекста на 2D чертежа има текуща трансформация, която може да бъде променена с методите <code>translate</code>, <code>scale</code> и <code>rotate</code>. Това ще се отрази на всички следващи операции на чертането. Състоянието на трансформацията може да бъде съхранено със <code>save</code> метода и възстановено със <code>restore</code> метода.</p>
<p><a class="p_ident" id="p_CiZHyGysLU" href="./16_canvas.html#p_CiZHyGysLU"></a>При изготвянето на анимация върху платното, метода <code>clearRect</code> може да се използва за да се изчисти част от платното, преди да се  преначертае.</p>
<h2><a class="h_ident" id="h_TcUD2vzyMe" href="./16_canvas.html#h_TcUD2vzyMe"></a>Упражнения</h2>
<h3><a class="h_ident" id="h_sZheOHQF5N" href="./16_canvas.html#h_sZheOHQF5N"></a>Фигури</h3>
<p><a class="p_ident" id="p_ML2Sk/PrfT" href="./16_canvas.html#p_ML2Sk/PrfT"></a>Напишете програма , която чертае следните форми на платното.</p>
<div class="olist arabic"><ol class="arabic">
<li>
<p><a class="p_ident" id="p_jg9BlkxnI6" href="./16_canvas.html#p_jg9BlkxnI6"></a>
Трапец (правоъгълник, който е по-широк от едната страна) 
</p>
</li>
<li>
<p><a class="p_ident" id="p_TsmIPWkWaZ" href="./16_canvas.html#p_TsmIPWkWaZ"></a>
Червен диамант(правоъгълник  завъртян на 45 градуса или ¼π радиана)
</p>
</li>
<li>
<p><a class="p_ident" id="p_rB8lM2f3nJ" href="./16_canvas.html#p_rB8lM2f3nJ"></a>
Линия зиг-заг
</p>
</li>
<li>
<p><a class="p_ident" id="p_giU72/tC1m" href="./16_canvas.html#p_giU72/tC1m"></a>
Спирала, съставена от 100 праволинейни сегмента.
</p>
</li>
<li>
<p><a class="p_ident" id="p_BaFPNufkG9" href="./16_canvas.html#p_BaFPNufkG9"></a>
Жълта звезда
</p>
</li>
</ol></div>
<div class="image">
  <img src="./media/exercise_shapes.png" alt="The shapes to draw">
</div>
<p><a class="p_ident" id="p_rGwDFrV/8d" href="./16_canvas.html#p_rGwDFrV/8d"></a>При изготвянето на последните две, може да прегледате обяснението на <code>Math.cos</code> и <code>Math.sin</code> в <a href="./13_dom.html#sin_cos">Глава 13</a>, където се описва как да получим координатите на кръг с помоща на тези две функции.</p>
<p><a class="p_ident" id="p_8n4Hu9tdGs" href="./16_canvas.html#p_8n4Hu9tdGs"></a>Аз препоръчвам да създадете функция за всяка форма. Като и подаване на позиция и по желание други свойства, като например размери или броя на точките, като параметри. Алтернативата, която е хард-кодови номера върху целия код, има тенденцията да направи кода ненужно труден за четене и промяна.</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class="c_ident" id="c_QMiBHdgh/Q" href="./16_canvas.html#c_QMiBHdgh/Q"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">canvas</span> <span class="cm-attribute">width</span>=<span class="cm-string">"600"</span> <span class="cm-attribute">height</span>=<span class="cm-string">"200"</span><span class="cm-tag cm-bracket">&gt;&lt;/</span><span class="cm-tag">canvas</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-keyword">var</span> <span class="cm-variable">cx</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">"canvas"</span>).<span class="cm-property">getContext</span>(<span class="cm-string">"2d"</span>);

  <span class="cm-comment">// Your code here.</span>
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>
<div class="solution"><div class="solution-text">
<p><a class="p_ident" id="p_Up+HOpbg2b" href="./16_canvas.html#p_Up+HOpbg2b"></a>The trapezoid (1) is easy to draw using
a path. Pick suitable center coordinates and add each of the four
corners around that.</p>
<p><a class="p_ident" id="p_BsQmhM5bK3" href="./16_canvas.html#p_BsQmhM5bK3"></a>The diamond (2) can
be drawn the easy way, with a path, or the interesting way, with a
<code>rotate</code> transformation. To use rotation, you will have to apply a
trick similar to what we did in the <code>flipHorizontally</code> function.
Because you want to rotate around the center of your rectangle and
not around the point (0,0), you must first <code>translate</code> to there, then
rotate, and then translate back.</p>
<p><a class="p_ident" id="p_br/BxkXFdB" href="./16_canvas.html#p_br/BxkXFdB"></a>For the zigzag (3) it
becomes impractical to write a new call to <code>lineTo</code> for each line
segment. Instead, you should use a loop. You can have each
iteration draw either two line segments (right and then left again) or
one, in which case you must use the evenness (<code>% 2</code>) of the loop index
to determine whether to go left or right.</p>
<p><a class="p_ident" id="p_NIAmRwoOih" href="./16_canvas.html#p_NIAmRwoOih"></a>You’ll also need a loop for the spiral (4). If you draw a series
of points, with each point moving further along a circle around the
spiral’s center, you get a circle. If, during the loop, you vary the
radius of the circle on which you are putting the current point and
go around more than once, the result is a spiral.</p>
<p><a class="p_ident" id="p_TOvDefGKYH" href="./16_canvas.html#p_TOvDefGKYH"></a>The star (5) depicted is built out of
<code>quadraticCurveTo</code> lines. You could also draw one with straight lines.
Divide a circle into eight pieces, or a piece for each point you want your
star to have. Draw lines between these points, making them curve
toward the center of the star. With <code>quadraticCurveTo</code>, you can use
the center as the control point.</p>
</div></div>
<h3 id="exercise_pie_chart"><a class="h_ident" id="h_bJrtZj5liF" href="./16_canvas.html#h_bJrtZj5liF"></a>The pie chart</h3>
<p><a class="p_ident" id="p_5/ovyOQpmP" href="./16_canvas.html#p_5/ovyOQpmP"></a><a href="./16_canvas.html#pie_chart">Earlier</a> in the chapter, we
saw an example program that drew a pie chart. Modify this program so
that the name of each category is shown next to the slice that
represents it. Try to find a pleasing-looking way to automatically
position this text, which would work for other data sets as well. You
may assume that categories are no smaller than 5 percent (that is, there won’t be
a bunch of tiny ones next to each other).</p>
<p><a class="p_ident" id="p_nTwqKbJWIc" href="./16_canvas.html#p_nTwqKbJWIc"></a>You might again need <code>Math.sin</code> and <code>Math.cos</code>, as described in the
previous exercise.</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class="c_ident" id="c_HyVapEe7cw" href="./16_canvas.html#c_HyVapEe7cw"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">canvas</span> <span class="cm-attribute">width</span>=<span class="cm-string">"600"</span> <span class="cm-attribute">height</span>=<span class="cm-string">"300"</span><span class="cm-tag cm-bracket">&gt;&lt;/</span><span class="cm-tag">canvas</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-keyword">var</span> <span class="cm-variable">cx</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">"canvas"</span>).<span class="cm-property">getContext</span>(<span class="cm-string">"2d"</span>);
  <span class="cm-keyword">var</span> <span class="cm-variable">total</span> <span class="cm-operator">=</span> <span class="cm-variable">results</span>.<span class="cm-property">reduce</span>(<span class="cm-keyword">function</span>(<span class="cm-def">sum</span>, <span class="cm-def">choice</span>) {
    <span class="cm-keyword">return</span> <span class="cm-variable-2">sum</span> <span class="cm-operator">+</span> <span class="cm-variable-2">choice</span>.<span class="cm-property">count</span>;
  }, <span class="cm-number">0</span>);

  <span class="cm-keyword">var</span> <span class="cm-variable">currentAngle</span> <span class="cm-operator">=</span> <span class="cm-operator">-</span><span class="cm-number">0.5</span> <span class="cm-operator">*</span> <span class="cm-variable">Math</span>.<span class="cm-property">PI</span>;
  <span class="cm-keyword">var</span> <span class="cm-variable">centerX</span> <span class="cm-operator">=</span> <span class="cm-number">300</span>, <span class="cm-variable">centerY</span> <span class="cm-operator">=</span> <span class="cm-number">150</span>;
  <span class="cm-comment">// Add code to draw the slice labels in this loop.</span>
  <span class="cm-variable">results</span>.<span class="cm-property">forEach</span>(<span class="cm-keyword">function</span>(<span class="cm-def">result</span>) {
    <span class="cm-keyword">var</span> <span class="cm-def">sliceAngle</span> <span class="cm-operator">=</span> (<span class="cm-variable-2">result</span>.<span class="cm-property">count</span> <span class="cm-operator">/</span> <span class="cm-variable">total</span>) <span class="cm-operator">*</span> <span class="cm-number">2</span> <span class="cm-operator">*</span> <span class="cm-variable">Math</span>.<span class="cm-property">PI</span>;
    <span class="cm-variable">cx</span>.<span class="cm-property">beginPath</span>();
    <span class="cm-variable">cx</span>.<span class="cm-property">arc</span>(<span class="cm-variable">centerX</span>, <span class="cm-variable">centerY</span>, <span class="cm-number">100</span>,
           <span class="cm-variable">currentAngle</span>, <span class="cm-variable">currentAngle</span> <span class="cm-operator">+</span> <span class="cm-variable-2">sliceAngle</span>);
    <span class="cm-variable">currentAngle</span> <span class="cm-operator">+=</span> <span class="cm-variable-2">sliceAngle</span>;
    <span class="cm-variable">cx</span>.<span class="cm-property">lineTo</span>(<span class="cm-variable">centerX</span>, <span class="cm-variable">centerY</span>);
    <span class="cm-variable">cx</span>.<span class="cm-property">fillStyle</span> <span class="cm-operator">=</span> <span class="cm-variable-2">result</span>.<span class="cm-property">color</span>;
    <span class="cm-variable">cx</span>.<span class="cm-property">fill</span>();
  });
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>
<div class="solution"><div class="solution-text">
<p><a class="p_ident" id="p_HdZ8krVlO9" href="./16_canvas.html#p_HdZ8krVlO9"></a>You will need to call <code>fillText</code>
and set the context’s <code>textAlign</code> and <code>textBaseline</code> properties in
such a way that the text ends up where you want it.</p>
<p><a class="p_ident" id="p_+9lrfaiHeA" href="./16_canvas.html#p_+9lrfaiHeA"></a>A sensible way to position the labels would be to put the text on the
line going from the center of the pie through the middle of the slice.
You don’t want to put the text directly against the side of the pie
but rather move the text out to the side of the pie by a given number of pixels.</p>
<p><a class="p_ident" id="p_kM123YG/Z7" href="./16_canvas.html#p_kM123YG/Z7"></a>The angle of this line is <code>currentAngle + 0.5 * sliceAngle</code>. The
following code finds a position on this line, 120 pixels from the center:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_A0rK11DEAl" href="./16_canvas.html#c_A0rK11DEAl"></a><span class="cm-keyword">var</span> <span class="cm-variable">middleAngle</span> <span class="cm-operator">=</span> <span class="cm-variable">currentAngle</span> <span class="cm-operator">+</span> <span class="cm-number">0.5</span> <span class="cm-operator">*</span> <span class="cm-variable">sliceAngle</span>;
<span class="cm-keyword">var</span> <span class="cm-variable">textX</span> <span class="cm-operator">=</span> <span class="cm-variable">Math</span>.<span class="cm-property">cos</span>(<span class="cm-variable">middleAngle</span>) <span class="cm-operator">*</span> <span class="cm-number">120</span> <span class="cm-operator">+</span> <span class="cm-variable">centerX</span>;
<span class="cm-keyword">var</span> <span class="cm-variable">textY</span> <span class="cm-operator">=</span> <span class="cm-variable">Math</span>.<span class="cm-property">sin</span>(<span class="cm-variable">middleAngle</span>) <span class="cm-operator">*</span> <span class="cm-number">120</span> <span class="cm-operator">+</span> <span class="cm-variable">centerY</span>;</pre>
<p><a class="p_ident" id="p_O8MP7v4Gfr" href="./16_canvas.html#p_O8MP7v4Gfr"></a>For <code>textBaseline</code>, the value <code>"middle"</code> is probably appropriate when
using this approach. What to use for <code>textAlign</code> depends on the side
of the circle we are on. On the left, it should be <code>"right"</code>, and on
the right, it should be <code>"left"</code> so that the text is positioned away
from the pie.</p>
<p><a class="p_ident" id="p_BmCLUHGaC3" href="./16_canvas.html#p_BmCLUHGaC3"></a>If you are not sure how to find out which side
of the circle a given angle is on, look to the explanation of
<code>Math.cos</code> in the previous exercise. The cosine of an angle tells us
which x-coordinate it corresponds to, which in turn tells us exactly
which side of the circle we are on.</p>
</div></div>
<h3><a class="h_ident" id="h_IoBBN8CiQ5" href="./16_canvas.html#h_IoBBN8CiQ5"></a>A bouncing ball</h3>
<p><a class="p_ident" id="p_QtPClJ4kuI" href="./16_canvas.html#p_QtPClJ4kuI"></a>Use
the <code>requestAnimationFrame</code> technique that we saw in
<a href="./13_dom.html#animationFrame">Chapter 13</a> and
<a href="./15_game.html#runAnimation">Chapter 15</a> to draw a box with a
bouncing ball in it. The ball moves at a constant
speed and bounces off the box’s sides when it hits them.</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class="c_ident" id="c_BlVpc3CK9m" href="./16_canvas.html#c_BlVpc3CK9m"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">canvas</span> <span class="cm-attribute">width</span>=<span class="cm-string">"400"</span> <span class="cm-attribute">height</span>=<span class="cm-string">"400"</span><span class="cm-tag cm-bracket">&gt;&lt;/</span><span class="cm-tag">canvas</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-keyword">var</span> <span class="cm-variable">cx</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">querySelector</span>(<span class="cm-string">"canvas"</span>).<span class="cm-property">getContext</span>(<span class="cm-string">"2d"</span>);

  <span class="cm-keyword">var</span> <span class="cm-variable">lastTime</span> <span class="cm-operator">=</span> <span class="cm-atom">null</span>;
  <span class="cm-keyword">function</span> <span class="cm-variable">frame</span>(<span class="cm-def">time</span>) {
    <span class="cm-keyword">if</span> (<span class="cm-variable">lastTime</span> <span class="cm-operator">!=</span> <span class="cm-atom">null</span>)
      <span class="cm-variable">updateAnimation</span>(<span class="cm-variable">Math</span>.<span class="cm-property">min</span>(<span class="cm-number">100</span>, <span class="cm-variable-2">time</span> <span class="cm-operator">-</span> <span class="cm-variable">lastTime</span>) <span class="cm-operator">/</span> <span class="cm-number">1000</span>);
    <span class="cm-variable">lastTime</span> <span class="cm-operator">=</span> <span class="cm-variable-2">time</span>;
    <span class="cm-variable">requestAnimationFrame</span>(<span class="cm-variable">frame</span>);
  }
  <span class="cm-variable">requestAnimationFrame</span>(<span class="cm-variable">frame</span>);

  <span class="cm-keyword">function</span> <span class="cm-variable">updateAnimation</span>(<span class="cm-def">step</span>) {
    <span class="cm-comment">// Your code here.</span>
  }
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>
<div class="solution"><div class="solution-text">
<p><a class="p_ident" id="p_v5+QhLhJAT" href="./16_canvas.html#p_v5+QhLhJAT"></a>A box is
easy to draw with <code>strokeRect</code>. Define a variable that holds its size
or define two variables if your box’s width and height differ. To create a
round ball, start a path, call <code>arc(x, y, radius, 0, 7)</code>, which creates an arc
going from zero to more than a whole circle, and fill it.</p>
<p><a class="p_ident" id="p_wlBTN9ml9f" href="./16_canvas.html#p_wlBTN9ml9f"></a>To model the ball’s position
and speed, you can use the <code>Vector</code> type from
<a href="./15_game.html#vector">Chapter 15</a>(which is available on this
page). Give it a starting speed, preferably one that is not purely
vertical or horizontal, and every frame, multiply that speed with
the amount of time that elapsed. When the ball gets too close to a
vertical wall, invert the x component in its speed. Likewise, invert
the y component when it hits a horizontal wall.</p>
<p><a class="p_ident" id="p_1wITPL6e42" href="./16_canvas.html#p_1wITPL6e42"></a>After finding the ball’s new
position and speed, use <code>clearRect</code> to delete the scene and redraw it
using the new position.</p>
</div></div>
<h3><a class="h_ident" id="h_3ePcd0S4v0" href="./16_canvas.html#h_3ePcd0S4v0"></a>Precomputed mirroring</h3>
<p><a class="p_ident" id="p_onlMAFaFji" href="./16_canvas.html#p_onlMAFaFji"></a>One unfortunate
thing about transformations is that they slow down drawing of
bitmaps. For vector graphics, the effect is less serious since
only a few points (for example, the center of a circle) need to be
transformed, after which drawing can happen as normal. For a bitmap
image, the position of each pixel has to be transformed, and
though it is possible that browsers will get more clever about
this in the future, this currently causes a measurable increase in
the time it takes to draw a bitmap.</p>
<p><a class="p_ident" id="p_b50ouk4znE" href="./16_canvas.html#p_b50ouk4znE"></a>In a game like ours, where we are drawing only a single transformed
sprite, this is a nonissue. But imagine that we need to draw hundreds
of characters or thousands of rotating particles from an explosion.</p>
<p><a class="p_ident" id="p_WgNsgEoaNe" href="./16_canvas.html#p_WgNsgEoaNe"></a>Think of a way to allow us to draw an inverted character without
loading additional image files and without having to make transformed
<code>drawImage</code> calls every frame.</p>
<div class="solution"><div class="solution-text">
<p><a class="p_ident" id="p_NmNTuxj7Ml" href="./16_canvas.html#p_NmNTuxj7Ml"></a>The key to the solution
is the fact that we can use a canvas element as a source image
when using <code>drawImage</code>. It is possible to create an extra <code>&lt;canvas&gt;</code>
element, without adding it to the document, and draw our inverted
sprites to it, once. When drawing an actual frame, we just copy the
already inverted sprites to the main canvas.</p>
<p><a class="p_ident" id="p_MbtRzmupcp" href="./16_canvas.html#p_MbtRzmupcp"></a>Some care would be required because images do not load
instantly. We do the inverted drawing only  once, and if we do it
before the image loads, it won’t draw anything. A <code>"load"</code> handler on
the image can be used to draw the inverted images to the extra canvas.
This canvas can be used as a drawing source immediately (it’ll simply
be blank until we draw the character onto it).</p>
</div></div>
<nav>
  <a href="./15_game.html" title="previous chapter">◀</a>
  <a href="./index.html" title="cover">◆</a>
  <a href="./17_http.html" title="next chapter">▶</a>
</nav>
</article>
</body></html>