<!DOCTYPE html>
<!-- saved from url=(0042)./15_game.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <title>Project: A Platform Game :: Eloquent JavaScript</title>
  <link rel="stylesheet" href="./media/codemirror.css">
  <script src="./media/acorn_codemirror.js"></script>
  <link rel="stylesheet" href="./media/ejs.css">
  <script src="./media/sandbox.js"></script>
  <script src="./media/ejs.js"></script>
  <script>var chapNum = 15;var sandboxLoadFiles = ["code/chapter/15_game.js", "code/game_levels.js"];</script>
</head>

<body><article>
<nav>
  <a href="./14_event.html" title="previous chapter">◀</a>
  <a href="./index.html" title="cover">◆</a>
  <a href="./16_canvas.html" title="next chapter">▶</a>
</nav>

<h1><div class="chap_num">Chapter 15</div>Проект: Платформа игра</h1>
<blockquote>
<p><a class="p_ident" id="p_kUA7+lr6ay" href="./15_game.html#p_kUA7+lr6ay"></a>Цялата реалност е една игра.”</p>
 <footer>Iain Banks, <cite>играч на игри</cite></footer>
</blockquote>
<p><a class="p_ident" id="p_LHKzmIPa3c" href="./15_game.html#p_LHKzmIPa3c"></a>Моят първи интерес към компютрите, както на много деца, възникна с компютърните игри. Бях очарован от мъничките компютърно симулирани светове, които мога да манипулирам и  чиито истории се развиваха, предполагам повече поради начина , по който въображението ми можеше да проектира, от колкото заради възможностите, които те действително предлагаха.</p>
<p><a class="p_ident" id="p_oGz9+U3nKJ" href="./15_game.html#p_oGz9+U3nKJ"></a>Не бих препоръчал кариера в проектиране на игри на никого. Много прилича на музикалната индустрия, несъответствието между нетърпеливи млади хора, които искат да работят в нея и реалното търсене на такива хора създава доста не здравословна среда. Но написването на игри за забавление е забавно.</p>
<p><a class="p_ident" id="p_j3t+HvGbaT" href="./15_game.html#p_j3t+HvGbaT"></a>В тази глава ще направим една проста игра платформа. Платформа игрите (или “jump and run” игри) са, както очаква играча, движение на една фигура през свят, който често е двуизмерен и се гледа от страни, и прави скокове върху или над неща.</p>
<h2><a class="h_ident" id="h_lMtTRzata0" href="./15_game.html#h_lMtTRzata0"></a>Играта</h2>
<p><a class="p_ident" id="p_C38xTPlNF8" href="./15_game.html#p_C38xTPlNF8"></a>Нашата игра ще бъде приблизително базирана на <a href="http://www.lessmilk.com/games/10">Dark Blue</a> от  Thomas Palef. Аз избрах тази игра, защото тя е едновременно забавна и малка, и може да бъде построена без прекалено много код. Тя изглежда така:</p>
<div class="image">
  <img src="./media/darkblue.png" alt="The game Dark Blue">
</div>
<p><a class="p_ident" id="p_mIXBfsCnQQ" href="./15_game.html#p_mIXBfsCnQQ"></a>Тъмната кутия представлява играчът, чиято задача е да събира жълти кутии (монети), като избягва червените неща (лава). Нивото е минато, когато всички монети са събрани.</p>
<p><a class="p_ident" id="p_g71I1Gdo7w" href="./15_game.html#p_g71I1Gdo7w"></a>Играчът може да се разхожда с левия и десния клавиш със стрелки и скача със стрелката на горе. Характера на скока е специалитет на тази игра. Той може да достигне няколко пъти собствената си височина и е в състояние да промени посоката си във въздуха. Това може да не е напълно реалистично, но помага на играча за усещането, че е в пряк контрол с аватара на екрана.</p>
<p><a class="p_ident" id="p_or+OtPnSO1" href="./15_game.html#p_or+OtPnSO1"></a>Играта се състои от фиксиран фон, изложен под формата на решетка, с движещи се елементи върху фона. Всяко поле на решетка е празно, твърдо или лава. За разлика от симулацията на изкуствения живот в <a href="./07_elife.html#elife">Глава 7</a>, позициите на тези елементи на са ограничени на мрежата, координатите им могат да бъдат дробни числа позволявайки плавно движение.</p>
<h2><a class="h_ident" id="h_hLFu/U4fE5" href="./15_game.html#h_hLFu/U4fE5"></a>Технология</h2>
<p><a class="p_ident" id="p_w6B1L26QOc" href="./15_game.html#p_w6B1L26QOc"></a>Ние ще използваме DOM на браузъра за да изведем играта на екрана и ще отчетем приноса на потребителите чрез манипулиране на клавишни събития.</p>
<p><a class="p_ident" id="p_wha4Kv9EnE" href="./15_game.html#p_wha4Kv9EnE"></a>Екран и клавиатура свързани с кода е само една малка част от работата, която трябва  да направите за изграждането на играта. Тъй като всичко изглежда, като цветни кутии рисунката не е сложна: ще създадем DOM елементи и използвайки стилизация ще им дадем фонов цвят, големина и позиция.</p>
<p><a class="p_ident" id="p_5a/S/bF/ru" href="./15_game.html#p_5a/S/bF/ru"></a>Можем да представим фона във вид на таблица, тъй като е неизменна мрежа от квадрати. Свободно движещи се елементи могат да бъдат наслагвани от горе и, използвайки абсолютно позиционирани елементи.</p>
<p><a class="p_ident" id="p_kmznnwbiqx" href="./15_game.html#p_kmznnwbiqx"></a>В игри и други програми, които трябва да анимирате графично и взаимодействие с потребители без да се забелязва забавяне, ефективността е много важна. Въпреки, че DOM не бил първоначално проектиран за графики с висока производителност, той всъщност е по-добър в това, от колкото очакваме. Ние видяхме няколко анимации в <a href="./13_dom.html#animation">Глава 13</a>. На една модерна машина, проста игра, като тази се представя добре дори и ако не се задълбочим в оптимизирането много.</p>
<p><a class="p_ident" id="p_wN87+E1mRv" href="./15_game.html#p_wN87+E1mRv"></a>В <a href="./16_canvas.html#canvas">следващата глава </a> ще разгледаме друга браузър технология - <code>&lt;canvas&gt;</code> таг, който осигурява по-традиционен начин за чертане на графики, които работят по отношение на форми и пиксели, а не DOM елементи.</p>
<h2><a class="h_ident" id="h_7UfwmBGLOk" href="./15_game.html#h_7UfwmBGLOk"></a>Нива</h2>
<p><a class="p_ident" id="p_qtbcbQFDkK" href="./15_game.html#p_qtbcbQFDkK"></a>В <a href="./07_elife.html#plan">Глава 7</a> използвахме масиви от <em>strings</em>, за да опишем двуизмерна мрежа. Можем да направим същото тук. Това ще ни позволи да изработим нива без да строим първо ниво редактор.</p>
<p><a class="p_ident" id="p_Y3dxlqZNOr" href="./15_game.html#p_Y3dxlqZNOr"></a>Едно просто ниво изглежда така:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_ydbtOFWK2H" href="./15_game.html#c_ydbtOFWK2H"></a><span class="cm-keyword">var</span> <span class="cm-variable">simpleLevelPlan</span> <span class="cm-operator">=</span> [
  <span class="cm-string">"                      "</span>,
  <span class="cm-string">"                      "</span>,
  <span class="cm-string">"  x              = x  "</span>,
  <span class="cm-string">"  x         o o    x  "</span>,
  <span class="cm-string">"  x @      xxxxx   x  "</span>,
  <span class="cm-string">"  xxxxx            x  "</span>,
  <span class="cm-string">"      x!!!!!!!!!!!!x  "</span>,
  <span class="cm-string">"      xxxxxxxxxxxxxx  "</span>,
  <span class="cm-string">"                      "</span>
];</pre>
<p><a class="p_ident" id="p_/+8Bj7dHhI" href="./15_game.html#p_/+8Bj7dHhI"></a>И двете: фиксираната мрежа и движещите се елементи ще бъдат включени в плана. Характерите на <code>x</code> са за стени, символите <em>space</em> са за празно пространство,  фиксираните удивителни знаци ! (<em>nonmoving</em>) представляват лава.</p>
<p><a class="p_ident" id="p_lnXaKIc8yw" href="./15_game.html#p_lnXaKIc8yw"></a>Знакът <code>@</code> определя мястото, където играчът започва. Всяко <code>o</code> е монета, а знака за равенство (<code>=</code>) означава блок от лава, която се движи напред-назад хризонтално. Имайте в предвид, че мрежата за тези позиции ще бъде настроена да съдържа празно пространство, а друга структура от данни ще се използва за проследяване на положението на движещите се елементи.</p>
<p><a class="p_ident" id="p_3Abhc0fnza" href="./15_game.html#p_3Abhc0fnza"></a>Ще поддържаме още два вида лава: символът (<code>|</code>), който ще представлява тръба за вертикално изригване на лава и <code>v</code> също за вертикално капене на лава, която не се мести напред-назад, а се движи само на долу и удряйки пода скача обратно в стартовата си позиция.</p>
<p><a class="p_ident" id="p_JSlRu3lL/0" href="./15_game.html#p_JSlRu3lL/0"></a>Цялата игра се състои от няколко нива, които играчът трябва да мине. Нивото е минато, когато всички монети са събрани. Ако играчът докосне лавата той умира и сегашното ниво се възстановява до началното си положение и играчът може да опита отново.</p>
<h2 id="level"><a class="h_ident" id="h_DeVC1tufta" href="./15_game.html#h_DeVC1tufta"></a>Четене на ниво</h2>
<p><a class="p_ident" id="p_+Eovnn74MN" href="./15_game.html#p_+Eovnn74MN"></a>Следната конструкция изражда обекта на нивото. Нейната теза трябва да бъде масив от <em>strings</em>, които определят нивото.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_PTlscRwogG" href="./15_game.html#c_PTlscRwogG"></a><span class="cm-keyword">function</span> <span class="cm-variable">Level</span>(<span class="cm-def">plan</span>) {
  <span class="cm-keyword">this</span>.<span class="cm-property">width</span> <span class="cm-operator">=</span> <span class="cm-variable-2">plan</span>[<span class="cm-number">0</span>].<span class="cm-property">length</span>;
  <span class="cm-keyword">this</span>.<span class="cm-property">height</span> <span class="cm-operator">=</span> <span class="cm-variable-2">plan</span>.<span class="cm-property">length</span>;
  <span class="cm-keyword">this</span>.<span class="cm-property">grid</span> <span class="cm-operator">=</span> [];
  <span class="cm-keyword">this</span>.<span class="cm-property">actors</span> <span class="cm-operator">=</span> [];

  <span class="cm-keyword">for</span> (<span class="cm-keyword">var</span> <span class="cm-def">y</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>; <span class="cm-variable-2">y</span> <span class="cm-operator">&lt;</span> <span class="cm-keyword">this</span>.<span class="cm-property">height</span>; <span class="cm-variable-2">y</span><span class="cm-operator">++</span>) {
    <span class="cm-keyword">var</span> <span class="cm-def">line</span> <span class="cm-operator">=</span> <span class="cm-variable-2">plan</span>[<span class="cm-variable-2">y</span>], <span class="cm-def">gridLine</span> <span class="cm-operator">=</span> [];
    <span class="cm-keyword">for</span> (<span class="cm-keyword">var</span> <span class="cm-def">x</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>; <span class="cm-variable-2">x</span> <span class="cm-operator">&lt;</span> <span class="cm-keyword">this</span>.<span class="cm-property">width</span>; <span class="cm-variable-2">x</span><span class="cm-operator">++</span>) {
      <span class="cm-keyword">var</span> <span class="cm-def">ch</span> <span class="cm-operator">=</span> <span class="cm-variable-2">line</span>[<span class="cm-variable-2">x</span>], <span class="cm-def">fieldType</span> <span class="cm-operator">=</span> <span class="cm-atom">null</span>;
      <span class="cm-keyword">var</span> <span class="cm-def">Actor</span> <span class="cm-operator">=</span> <span class="cm-variable">actorChars</span>[<span class="cm-variable-2">ch</span>];
      <span class="cm-keyword">if</span> (<span class="cm-variable-2">Actor</span>)
        <span class="cm-keyword">this</span>.<span class="cm-property">actors</span>.<span class="cm-property">push</span>(<span class="cm-keyword">new</span> <span class="cm-variable-2">Actor</span>(<span class="cm-keyword">new</span> <span class="cm-variable">Vector</span>(<span class="cm-variable-2">x</span>, <span class="cm-variable-2">y</span>), <span class="cm-variable-2">ch</span>));
      <span class="cm-keyword">else</span> <span class="cm-keyword">if</span> (<span class="cm-variable-2">ch</span> <span class="cm-operator">==</span> <span class="cm-string">"x"</span>)
        <span class="cm-variable-2">fieldType</span> <span class="cm-operator">=</span> <span class="cm-string">"wall"</span>;
      <span class="cm-keyword">else</span> <span class="cm-keyword">if</span> (<span class="cm-variable-2">ch</span> <span class="cm-operator">==</span> <span class="cm-string">"!"</span>)
        <span class="cm-variable-2">fieldType</span> <span class="cm-operator">=</span> <span class="cm-string">"lava"</span>;
      <span class="cm-variable-2">gridLine</span>.<span class="cm-property">push</span>(<span class="cm-variable-2">fieldType</span>);
    }
    <span class="cm-keyword">this</span>.<span class="cm-property">grid</span>.<span class="cm-property">push</span>(<span class="cm-variable-2">gridLine</span>);
  }

  <span class="cm-keyword">this</span>.<span class="cm-property">player</span> <span class="cm-operator">=</span> <span class="cm-keyword">this</span>.<span class="cm-property">actors</span>.<span class="cm-property">filter</span>(<span class="cm-keyword">function</span>(<span class="cm-def">actor</span>) {
    <span class="cm-keyword">return</span> <span class="cm-variable-2">actor</span>.<span class="cm-property">type</span> <span class="cm-operator">==</span> <span class="cm-string">"player"</span>;
  })[<span class="cm-number">0</span>];
  <span class="cm-keyword">this</span>.<span class="cm-property">status</span> <span class="cm-operator">=</span> <span class="cm-keyword">this</span>.<span class="cm-property">finishDelay</span> <span class="cm-operator">=</span> <span class="cm-atom">null</span>;
}</pre>
<p><a class="p_ident" id="p_ZIIJavICol" href="./15_game.html#p_ZIIJavICol"></a>За краткост, кода не се проверява за неправилен вход. Това предполага, че сме му дали завършен подходящ план за ниво със стартова позиция на играча и други важни неща.</p>
<p><a class="p_ident" id="p_x/twI7oWfP" href="./15_game.html#p_x/twI7oWfP"></a>Нивото съхранява неговата ширина и висичина заедно с две решетки - една за мрежата и една за актьорите, които са динамични елементи. Решетката е представена, като масив от масиви, където всеки от вътрешните масиви представлява хоризонтална линия и всеки квадрат съдържа или нула за празен квадрат или string за вида на пълния квадрат <code>"wall"</code> или <code>"lava"</code>.</p>
<p><a class="p_ident" id="p_lk9TyBu+V9" href="./15_game.html#p_lk9TyBu+V9"></a>Масивът за актьорите съдържа обекти, които следят текущото положение и състояние на динамичните елементи в нивото. Всеки от тях очаква да има: <code>pos</code> свойство, което дава позиция (координатите на неговата позиция спрямо горния ляв ъгъл), <code>size</code> свойството, което дава размер, а <code>type</code> свойството притежава <em>string</em> идентифициращ елементите  (<code>"lava"</code>, <code>"coin"</code> и <code>"player"</code>).</p>
<p><a class="p_ident" id="p_CHBpIMO/+A" href="./15_game.html#p_CHBpIMO/+A"></a>След изграждането на мрежата, ние използваме <code>filter</code> метод за намиране на обекта на актьора на играча, който се съхранява в свойството на нивото. <code>status</code> свойството следи дали играчът е спечелил или загубил. Когато това се случи, <code>finishDelay</code> се използва да подържа нивото активно за кратък период от време, така че анимацията просто да се покаже. (Незабавно възстановяване или излизане от нивото ще изглежда евтино.) Този метод може да се използва за да се разбере дали нивото е минато.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_5Zb+6efnJo" href="./15_game.html#c_5Zb+6efnJo"></a><span class="cm-variable">Level</span>.<span class="cm-property">prototype</span>.<span class="cm-property">isFinished</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>() {
  <span class="cm-keyword">return</span> <span class="cm-keyword">this</span>.<span class="cm-property">status</span> <span class="cm-operator">!=</span> <span class="cm-atom">null</span> <span class="cm-operator">&amp;&amp;</span> <span class="cm-keyword">this</span>.<span class="cm-property">finishDelay</span> <span class="cm-operator">&lt;</span> <span class="cm-number">0</span>;
};</pre>
<h2><a class="h_ident" id="h_pw0251T7gn" href="./15_game.html#h_pw0251T7gn"></a>Актьори</h2>
<p><a class="p_ident" id="p_E0kVEhfjBl" href="./15_game.html#p_E0kVEhfjBl"></a><a id="vector"></a> За съхраняване на положението и размерите на един актьор, ние ще се върнем към нашия надежден <code>Vector</code> тип, с неговите групи от х и у координати в обекта.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_/G1xAMXuR9" href="./15_game.html#c_/G1xAMXuR9"></a><span class="cm-keyword">function</span> <span class="cm-variable">Vector</span>(<span class="cm-def">x</span>, <span class="cm-def">y</span>) {
  <span class="cm-keyword">this</span>.<span class="cm-property">x</span> <span class="cm-operator">=</span> <span class="cm-variable-2">x</span>; <span class="cm-keyword">this</span>.<span class="cm-property">y</span> <span class="cm-operator">=</span> <span class="cm-variable-2">y</span>;
}
<span class="cm-variable">Vector</span>.<span class="cm-property">prototype</span>.<span class="cm-property">plus</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">other</span>) {
  <span class="cm-keyword">return</span> <span class="cm-keyword">new</span> <span class="cm-variable">Vector</span>(<span class="cm-keyword">this</span>.<span class="cm-property">x</span> <span class="cm-operator">+</span> <span class="cm-variable-2">other</span>.<span class="cm-property">x</span>, <span class="cm-keyword">this</span>.<span class="cm-property">y</span> <span class="cm-operator">+</span> <span class="cm-variable-2">other</span>.<span class="cm-property">y</span>);
};
<span class="cm-variable">Vector</span>.<span class="cm-property">prototype</span>.<span class="cm-property">times</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">factor</span>) {
  <span class="cm-keyword">return</span> <span class="cm-keyword">new</span> <span class="cm-variable">Vector</span>(<span class="cm-keyword">this</span>.<span class="cm-property">x</span> <span class="cm-operator">*</span> <span class="cm-variable-2">factor</span>, <span class="cm-keyword">this</span>.<span class="cm-property">y</span> <span class="cm-operator">*</span> <span class="cm-variable-2">factor</span>);
};</pre>
<p><a class="p_ident" id="p_YBJ9X5jC/P" href="./15_game.html#p_YBJ9X5jC/P"></a>Метода <code>times</code> скалира вектора от дадената сума. Това ще бъде полезно, когато трябва да се умножава скоростта на вектора по интервала от време, за да получим изминатото разстояние за даден интервал от време</p>
<p><a class="p_ident" id="p_ZUYAD4nQKB" href="./15_game.html#p_ZUYAD4nQKB"></a>В предишния раздел, обекта <code>actorChars</code> се използва от <code>Level</code> конструктора да асоциира характери с конструктор функции. Обекта изглежда по следния начин:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_yAQDMv58Ql" href="./15_game.html#c_yAQDMv58Ql"></a><span class="cm-keyword">var</span> <span class="cm-variable">actorChars</span> <span class="cm-operator">=</span> {
  <span class="cm-string cm-property">"@"</span>: <span class="cm-variable">Player</span>,
  <span class="cm-string cm-property">"o"</span>: <span class="cm-variable">Coin</span>,
  <span class="cm-string cm-property">"="</span>: <span class="cm-variable">Lava</span>, <span class="cm-string cm-property">"|"</span>: <span class="cm-variable">Lava</span>, <span class="cm-string cm-property">"v"</span>: <span class="cm-variable">Lava</span>
};</pre>
<p><a class="p_ident" id="p_Ezz8Z00Wak" href="./15_game.html#p_Ezz8Z00Wak"></a>Последните три характера са карта на лавата. <code>Lava</code>. The <code>Level</code> конструктора подава характера на актьора, като втори аргумент на конструктора и <code>Lava</code> конструктора  го използва за да коригира своето поведение (вертикално или хоризонтално подскачане или капене).</p>
<p><a class="p_ident" id="p_9z5NweLFob" href="./15_game.html#p_9z5NweLFob"></a>Типът на Player е изграден със следната конструкция. Той разполага със свойството <code>speed</code>, където съхранява сегашната скорост, която ще помогне да симулираме инерция и гравитация.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_GHc17EeS05" href="./15_game.html#c_GHc17EeS05"></a><span class="cm-keyword">function</span> <span class="cm-variable">Player</span>(<span class="cm-def">pos</span>) {
  <span class="cm-keyword">this</span>.<span class="cm-property">pos</span> <span class="cm-operator">=</span> <span class="cm-variable-2">pos</span>.<span class="cm-property">plus</span>(<span class="cm-keyword">new</span> <span class="cm-variable">Vector</span>(<span class="cm-number">0</span>, <span class="cm-operator">-</span><span class="cm-number">0.5</span>));
  <span class="cm-keyword">this</span>.<span class="cm-property">size</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">Vector</span>(<span class="cm-number">0.8</span>, <span class="cm-number">1.5</span>);
  <span class="cm-keyword">this</span>.<span class="cm-property">speed</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">Vector</span>(<span class="cm-number">0</span>, <span class="cm-number">0</span>);
}
<span class="cm-variable">Player</span>.<span class="cm-property">prototype</span>.<span class="cm-property">type</span> <span class="cm-operator">=</span> <span class="cm-string">"player"</span>;</pre>
<p><a class="p_ident" id="p_KwI14wjzqB" href="./15_game.html#p_KwI14wjzqB"></a><em>Player</em> е висок един и половина квадрата и първоначалното му положение е половин квадрат над позицията, където се появява символа <code>@</code>. По този начин, долната част се подравнява с дъното на квадрата, който изглежда навътре.</p>
<p><a class="p_ident" id="p_tERSi4X6Me" href="./15_game.html#p_tERSi4X6Me"></a>При изграждането на динамичния <code>Lava</code> обект, ние трябва да инициализираме обекта по различен начин в зависимост от характера, на който се основава. Динамичната лава се движи сама в зависимост от дадената и скорост, докато не срещне препятствие. В този момент ако има <code>repeatPos</code> свойство, тя ще скочи обратно към своята начална позиция (при капене). Ако това не стане, тя ще промени скоростта и ще продължи в друга посока. Конструктора само определя необходимите свойства. Методът, който прави действителното преместване ще бъде написан <a href="./15_game.html#actors">по-късно</a>.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_PTqOmT7FMn" href="./15_game.html#c_PTqOmT7FMn"></a><span class="cm-keyword">function</span> <span class="cm-variable">Lava</span>(<span class="cm-def">pos</span>, <span class="cm-def">ch</span>) {
  <span class="cm-keyword">this</span>.<span class="cm-property">pos</span> <span class="cm-operator">=</span> <span class="cm-variable-2">pos</span>;
  <span class="cm-keyword">this</span>.<span class="cm-property">size</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">Vector</span>(<span class="cm-number">1</span>, <span class="cm-number">1</span>);
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">ch</span> <span class="cm-operator">==</span> <span class="cm-string">"="</span>) {
    <span class="cm-keyword">this</span>.<span class="cm-property">speed</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">Vector</span>(<span class="cm-number">2</span>, <span class="cm-number">0</span>);
  } <span class="cm-keyword">else</span> <span class="cm-keyword">if</span> (<span class="cm-variable-2">ch</span> <span class="cm-operator">==</span> <span class="cm-string">"|"</span>) {
    <span class="cm-keyword">this</span>.<span class="cm-property">speed</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">Vector</span>(<span class="cm-number">0</span>, <span class="cm-number">2</span>);
  } <span class="cm-keyword">else</span> <span class="cm-keyword">if</span> (<span class="cm-variable-2">ch</span> <span class="cm-operator">==</span> <span class="cm-string">"v"</span>) {
    <span class="cm-keyword">this</span>.<span class="cm-property">speed</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">Vector</span>(<span class="cm-number">0</span>, <span class="cm-number">3</span>);
    <span class="cm-keyword">this</span>.<span class="cm-property">repeatPos</span> <span class="cm-operator">=</span> <span class="cm-variable-2">pos</span>;
  }
}
<span class="cm-variable">Lava</span>.<span class="cm-property">prototype</span>.<span class="cm-property">type</span> <span class="cm-operator">=</span> <span class="cm-string">"lava"</span>;</pre>
<p><a class="p_ident" id="p_h6fsluS1sx" href="./15_game.html#p_h6fsluS1sx"></a><code>Coin</code> актьорите са прости. Те просто стоят на мястото си. Но за да оживим малко играта им е дадено леко потрепване и леко движение напред и назад. За да проследим това, обекта на монетата съхранява базова позиция, както и <code>wobble</code> свойство, което следи фазата на подскачащото движение. Заедно те определят действителното положение на монетата (съхранено в <code>pos</code> свойството).</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_SwVUgnkT5j" href="./15_game.html#c_SwVUgnkT5j"></a><span class="cm-keyword">function</span> <span class="cm-variable">Coin</span>(<span class="cm-def">pos</span>) {
  <span class="cm-keyword">this</span>.<span class="cm-property">basePos</span> <span class="cm-operator">=</span> <span class="cm-keyword">this</span>.<span class="cm-property">pos</span> <span class="cm-operator">=</span> <span class="cm-variable-2">pos</span>.<span class="cm-property">plus</span>(<span class="cm-keyword">new</span> <span class="cm-variable">Vector</span>(<span class="cm-number">0.2</span>, <span class="cm-number">0.1</span>));
  <span class="cm-keyword">this</span>.<span class="cm-property">size</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">Vector</span>(<span class="cm-number">0.6</span>, <span class="cm-number">0.6</span>);
  <span class="cm-keyword">this</span>.<span class="cm-property">wobble</span> <span class="cm-operator">=</span> <span class="cm-variable">Math</span>.<span class="cm-property">random</span>() <span class="cm-operator">*</span> <span class="cm-variable">Math</span>.<span class="cm-property">PI</span> <span class="cm-operator">*</span> <span class="cm-number">2</span>;
}
<span class="cm-variable">Coin</span>.<span class="cm-property">prototype</span>.<span class="cm-property">type</span> <span class="cm-operator">=</span> <span class="cm-string">"coin"</span>;</pre>
<p><a class="p_ident" id="p_sinZPrR05b" href="./15_game.html#p_sinZPrR05b"></a>В <a href="./13_dom.html#sin_cos">Глава 13</a> видяхме, че <code>Math.sin</code> ни два  у-координата на точка от окръжност. С нея можем да координираме местенето назад и на пред в плавната форма на вълна и тъй като ще се движи в кръг, прави задължително функцията да моделира вълнообразно движение.</p>
<p><a class="p_ident" id="p_gQCua74XOk" href="./15_game.html#p_gQCua74XOk"></a>За да се избегне ситуация, в която всички монети се движат нагоре и надолу синхронизирано, началният етап за всяка монета ще бъде рандомизиран. Фазата на <code>Math.sin</code> вълната (ширината на една вълна) е 2π. Ние умножаваме стойността върната от <code>Math.random</code> по това число, за да даде на монетата случайна стартова позиция на вълната.</p>
<p><a class="p_ident" id="p_q4rwQ9GT76" href="./15_game.html#p_q4rwQ9GT76"></a>Сега сме написали всички необходими части за да представим размерите на нивото.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_+UfzWNonW2" href="./15_game.html#c_+UfzWNonW2"></a><span class="cm-keyword">var</span> <span class="cm-variable">simpleLevel</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">Level</span>(<span class="cm-variable">simpleLevelPlan</span>);
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">simpleLevel</span>.<span class="cm-property">width</span>, <span class="cm-string">"by"</span>, <span class="cm-variable">simpleLevel</span>.<span class="cm-property">height</span>);
<span class="cm-comment">// → 22 by 9</span></pre>
<p><a class="p_ident" id="p_lCdOTin0mI" href="./15_game.html#p_lCdOTin0mI"></a>Задачата напред е да покажем тези нива на екрана и да моделираме движението и времето вътре в тях.</p>
<h2><a class="h_ident" id="h_uCRd57RG2L" href="./15_game.html#h_uCRd57RG2L"></a>Капслулирането  като  бреме</h2>
<p><a class="p_ident" id="p_M65QHGE4qM" href="./15_game.html#p_M65QHGE4qM"></a>Повечето от кода в тази глава не се тревожи за капсулирането по две причини. Първо, капсулирането изисква допълнително усилие. Това прави програмите по-големи и изисква допълнителни концепции и интерфейси, които трябва да бъдат въведени. Понеже може да се създаде толкова много код, който един читател трябва да прочете, докато му се изцъклят очите, съм направил опит да запазя програмата малка.</p>
<p><a class="p_ident" id="p_xjLloHI+Wv" href="./15_game.html#p_xjLloHI+Wv"></a>Второ различните елементи в тази игра са толкова тясно свързани заедно, че ако поведението на един от тях се промени, това е малко вероятно, то другите едва ли ще останат същите. Интерфейси между елементите ще се окажат пред кодиране на много предположения за начина, по който играта работи. Това ги прави много по-малко ефективни, когато се промени една част от системата и все още трябва да се притесняваме за начина, по който тя влияе на другите части, защото техните интерфейси не биха обхванали новата ситуация.</p>
<p><a class="p_ident" id="p_JXDPJBULIv" href="./15_game.html#p_JXDPJBULIv"></a>Някои отрязани точки в една система се поддават добре на разделяне чрез строги интерфейси, но други не. Опитвайки се да капсулирате нещо, което не е с подходяща граница е сигурен начин да изгубите много енергия. Когато направите тази грешка, обикновено ще забележите, че вашите интерфейси стават опасно големи и подробни и че те трябва да бъдат променяни често, тъй като програмата се развива.</p>
<p><a class="p_ident" id="p_Eajw41C5DX" href="./15_game.html#p_Eajw41C5DX"></a>Има едно нещо, което ние ще капсулираме в тази глава и това е подсистемата за рисуване. Причината за това е, че ще покаже същата игра по различен начин в <a href="./16_canvas.html#canvasdisplay">следващата глава</a>. С пускането на рисунката зад интерфейса, можем просто да заредим една и съща игра, като програмата е включена в нов модул дисплей.</p>
<h2 id="domdisplay"><a class="h_ident" id="h_neNgUMdlHQ" href="./15_game.html#h_neNgUMdlHQ"></a>Чертеж</h2>
<p><a class="p_ident" id="p_bjlUPfTgQP" href="./15_game.html#p_bjlUPfTgQP"></a>Капсулирането на кода за рисуване се извършва чрез определяне на обекта на дисплея, в който се показва дадено ниво. Типа на дисплея, който определяме в тази глава ще се казва <code>DOMDisplay</code>, защото използва DOM елементи за да покаже нивото.</p>
<p><a class="p_ident" id="p_iqZAywSomZ" href="./15_game.html#p_iqZAywSomZ"></a>Ние ще използваме стил схема за да определим действителните цветове и други дълготрайни свойства на елементите, които съставляват играта. Също така, би било възможно директно да задаваме на елементите <code>style</code> свойства, когато ги създаваме, но това ще произведе повече многословни програми.</p>
<p><a class="p_ident" id="p_cp0ecVNl6a" href="./15_game.html#p_cp0ecVNl6a"></a>Следната помощна функция осигурява кратък начин за създаване на един елемент и даването му на клас.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_qgpBj12JLo" href="./15_game.html#c_qgpBj12JLo"></a><span class="cm-keyword">function</span> <span class="cm-variable">elt</span>(<span class="cm-def">name</span>, <span class="cm-def">className</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">elt</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">createElement</span>(<span class="cm-variable-2">name</span>);
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">className</span>) <span class="cm-variable-2">elt</span>.<span class="cm-property">className</span> <span class="cm-operator">=</span> <span class="cm-variable-2">className</span>;
  <span class="cm-keyword">return</span> <span class="cm-variable-2">elt</span>;
}</pre>
<p><a class="p_ident" id="p_Xjpq/reXQf" href="./15_game.html#p_Xjpq/reXQf"></a>Дисплея е създаден с даването му на родителски елемент, към който трябва да бъде добавен и един обект за ниво.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_NXRRW4iUHo" href="./15_game.html#c_NXRRW4iUHo"></a><span class="cm-keyword">function</span> <span class="cm-variable">DOMDisplay</span>(<span class="cm-def">parent</span>, <span class="cm-def">level</span>) {
  <span class="cm-keyword">this</span>.<span class="cm-property">wrap</span> <span class="cm-operator">=</span> <span class="cm-variable-2">parent</span>.<span class="cm-property">appendChild</span>(<span class="cm-variable">elt</span>(<span class="cm-string">"div"</span>, <span class="cm-string">"game"</span>));
  <span class="cm-keyword">this</span>.<span class="cm-property">level</span> <span class="cm-operator">=</span> <span class="cm-variable-2">level</span>;

  <span class="cm-keyword">this</span>.<span class="cm-property">wrap</span>.<span class="cm-property">appendChild</span>(<span class="cm-keyword">this</span>.<span class="cm-property">drawBackground</span>());
  <span class="cm-keyword">this</span>.<span class="cm-property">actorLayer</span> <span class="cm-operator">=</span> <span class="cm-atom">null</span>;
  <span class="cm-keyword">this</span>.<span class="cm-property">drawFrame</span>();
}</pre>
<p><a class="p_ident" id="p_ma7b253RBp" href="./15_game.html#p_ma7b253RBp"></a>Използваме факта, че <code>appendChild</code> връща  приложения елемент за създаване на елемент-обвивка и го съхранява във <code>wrap</code> свойството в единичен отчет.</p>
<p><a class="p_ident" id="p_IMKo7SUQR3" href="./15_game.html#p_IMKo7SUQR3"></a>Фона на нивото никога не се променя и се изготвя веднъж. Актьорите се преначертават всеки път, когато дисплея се актуализира. Свойството <code>actorLayer</code> ще бъде използвано от <code>drawFrame</code> за проследяване на елемента, който държи актьорите така че те лесно да бъдат премахнати или заменени.</p>
<p><a class="p_ident" id="p_si3+n3Lijy" href="./15_game.html#p_si3+n3Lijy"></a>Нашите координати и размери се проследяват в единици по отношение на размера на мрежата, където мащаб или разстояние от 1 означава една решетка-единица. При определяне на размера на пикселите, ние ще трябва да мащабираме тези координати нагоре- иначе всичко в играта ще бъде абсурдно малко в квадрат от едни пиксел. Променливата <code>scale</code> дава броят на пикселите, който един единствен елемент заема на екрана.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_3gR9dTLD4N" href="./15_game.html#c_3gR9dTLD4N"></a><span class="cm-keyword">var</span> <span class="cm-variable">scale</span> <span class="cm-operator">=</span> <span class="cm-number">20</span>;

<span class="cm-variable">DOMDisplay</span>.<span class="cm-property">prototype</span>.<span class="cm-property">drawBackground</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>() {
  <span class="cm-keyword">var</span> <span class="cm-def">table</span> <span class="cm-operator">=</span> <span class="cm-variable">elt</span>(<span class="cm-string">"table"</span>, <span class="cm-string">"background"</span>);
  <span class="cm-variable-2">table</span>.<span class="cm-property">style</span>.<span class="cm-property">width</span> <span class="cm-operator">=</span> <span class="cm-keyword">this</span>.<span class="cm-property">level</span>.<span class="cm-property">width</span> <span class="cm-operator">*</span> <span class="cm-variable">scale</span> <span class="cm-operator">+</span> <span class="cm-string">"px"</span>;
  <span class="cm-keyword">this</span>.<span class="cm-property">level</span>.<span class="cm-property">grid</span>.<span class="cm-property">forEach</span>(<span class="cm-keyword">function</span>(<span class="cm-def">row</span>) {
    <span class="cm-keyword">var</span> <span class="cm-def">rowElt</span> <span class="cm-operator">=</span> <span class="cm-variable-2">table</span>.<span class="cm-property">appendChild</span>(<span class="cm-variable">elt</span>(<span class="cm-string">"tr"</span>));
    <span class="cm-variable-2">rowElt</span>.<span class="cm-property">style</span>.<span class="cm-property">height</span> <span class="cm-operator">=</span> <span class="cm-variable">scale</span> <span class="cm-operator">+</span> <span class="cm-string">"px"</span>;
    <span class="cm-variable-2">row</span>.<span class="cm-property">forEach</span>(<span class="cm-keyword">function</span>(<span class="cm-def">type</span>) {
      <span class="cm-variable-2">rowElt</span>.<span class="cm-property">appendChild</span>(<span class="cm-variable">elt</span>(<span class="cm-string">"td"</span>, <span class="cm-variable-2">type</span>));
    });
  });
  <span class="cm-keyword">return</span> <span class="cm-variable-2">table</span>;
};</pre>
<p id="game_css"><a class="p_ident" id="p_d+zoai4uXa" href="./15_game.html#p_d+zoai4uXa"></a>Както бе споменато по-рано задният план се съставя, като <code>&lt;table&gt;</code> елемент. Това добре съответства на структурата на <code>grid</code> свойството в нивото - всеки ред на решетката се превръща в табличен ред (<code>&lt;tr&gt;</code> елемент). <em>Strings</em> в мрежата се използват, като имена на класове за клетките от таблицата (<code>&lt;td&gt;</code> елементи). Следния CSS помага получената таблица да изглежда, като желания заден план:</p>
<pre data-language="text/css" class="snippet cm-s-default"><a class="c_ident" id="c_j52CagBKSp" href="./15_game.html#c_j52CagBKSp"></a><span class="cm-qualifier">.background</span>    { <span class="cm-property">background</span>: <span class="cm-atom">rgb</span>(<span class="cm-number">52</span>, <span class="cm-number">166</span>, <span class="cm-number">251</span>);
                 <span class="cm-property">table-layout</span>: <span class="cm-atom">fixed</span>;
                 <span class="cm-property">border-spacing</span>: <span class="cm-number">0</span>;              }
<span class="cm-qualifier">.background</span> <span class="cm-tag">td</span> { <span class="cm-property">padding</span>: <span class="cm-number">0</span>;                     }
<span class="cm-qualifier">.lava</span>          { <span class="cm-property">background</span>: <span class="cm-atom">rgb</span>(<span class="cm-number">255</span>, <span class="cm-number">100</span>, <span class="cm-number">100</span>); }
<span class="cm-qualifier">.wall</span>          { <span class="cm-property">background</span>: <span class="cm-keyword">white</span>;              }</pre>
<p><a class="p_ident" id="p_Fm4CLmRVL5" href="./15_game.html#p_Fm4CLmRVL5"></a>Някои от тях, като (<code>table-layout</code>, <code>border-spacing</code> и <code>padding</code>) са използвани за подтискане на нежелано поведение по подразбиране. Ние не искаме оформлението на таблицата да зависи от съдържанието на неговите клетки, не искаме също пространство между клетките на таблицата или подплънка вътре в тях.</p>
<p><a class="p_ident" id="p_wtigqOBUxT" href="./15_game.html#p_wtigqOBUxT"></a>Правилото <code>background</code> задава цвета на фона. CSS  позволява цветовете да бъдат определени, като думи (<code>white, red </code> и т.н.) с формат <code>rgb(R, G, B)</code>, където червеното, зеленото и синьото са компонентите на цвета, разделени в три цифри от 0 до 255. Така че, в <code>rgb(52, 166, 251)</code> червеният компонент е 52, зеленият е 166, а синьото е 251. Синия  компонент е най-големият и полученият цвят ще е синкав. Можете да видите, че в 
<code>.lava</code> правилото, първата цифра (червено) е най-голяма.</p>
<p><a class="p_ident" id="p_EGE24ax3xh" href="./15_game.html#p_EGE24ax3xh"></a>Ние чертаем всеки участник чрез създаване на DOM елемент за него и създаваме позиция и размер, въз основа на качествата на актьора. Стойностите трябва да бъдат умножени по <code>scale</code> за да преминем от единици в пиксели.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_dh+IKCYnTO" href="./15_game.html#c_dh+IKCYnTO"></a><span class="cm-variable">DOMDisplay</span>.<span class="cm-property">prototype</span>.<span class="cm-property">drawActors</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>() {
  <span class="cm-keyword">var</span> <span class="cm-def">wrap</span> <span class="cm-operator">=</span> <span class="cm-variable">elt</span>(<span class="cm-string">"div"</span>);
  <span class="cm-keyword">this</span>.<span class="cm-property">level</span>.<span class="cm-property">actors</span>.<span class="cm-property">forEach</span>(<span class="cm-keyword">function</span>(<span class="cm-def">actor</span>) {
    <span class="cm-keyword">var</span> <span class="cm-def">rect</span> <span class="cm-operator">=</span> <span class="cm-variable-2">wrap</span>.<span class="cm-property">appendChild</span>(<span class="cm-variable">elt</span>(<span class="cm-string">"div"</span>,
                                    <span class="cm-string">"actor "</span> <span class="cm-operator">+</span> <span class="cm-variable-2">actor</span>.<span class="cm-property">type</span>));
    <span class="cm-variable-2">rect</span>.<span class="cm-property">style</span>.<span class="cm-property">width</span> <span class="cm-operator">=</span> <span class="cm-variable-2">actor</span>.<span class="cm-property">size</span>.<span class="cm-property">x</span> <span class="cm-operator">*</span> <span class="cm-variable">scale</span> <span class="cm-operator">+</span> <span class="cm-string">"px"</span>;
    <span class="cm-variable-2">rect</span>.<span class="cm-property">style</span>.<span class="cm-property">height</span> <span class="cm-operator">=</span> <span class="cm-variable-2">actor</span>.<span class="cm-property">size</span>.<span class="cm-property">y</span> <span class="cm-operator">*</span> <span class="cm-variable">scale</span> <span class="cm-operator">+</span> <span class="cm-string">"px"</span>;
    <span class="cm-variable-2">rect</span>.<span class="cm-property">style</span>.<span class="cm-property">left</span> <span class="cm-operator">=</span> <span class="cm-variable-2">actor</span>.<span class="cm-property">pos</span>.<span class="cm-property">x</span> <span class="cm-operator">*</span> <span class="cm-variable">scale</span> <span class="cm-operator">+</span> <span class="cm-string">"px"</span>;
    <span class="cm-variable-2">rect</span>.<span class="cm-property">style</span>.<span class="cm-property">top</span> <span class="cm-operator">=</span> <span class="cm-variable-2">actor</span>.<span class="cm-property">pos</span>.<span class="cm-property">y</span> <span class="cm-operator">*</span> <span class="cm-variable">scale</span> <span class="cm-operator">+</span> <span class="cm-string">"px"</span>;
  });
  <span class="cm-keyword">return</span> <span class="cm-variable-2">wrap</span>;
};</pre>
<p><a class="p_ident" id="p_N1paxjwHY8" href="./15_game.html#p_N1paxjwHY8"></a>За да дадем на един елемент повече от един клас, ние разделяме името на класа с интервали. В кода на CSS показан след малко, <code>actor</code> класа дава на актьорите абсолютно положение. Техният тип име се използва, като допълнителен клас за да им даде цвят. Ние не трябва да дефинираме отново <code>lava</code> класа, защото повторно използвахме класа за мрежата от лава квадрати, които ние дефинирахме по-рано.</p>
<pre data-language="text/css" class="snippet cm-s-default"><a class="c_ident" id="c_gIfxpyXJhS" href="./15_game.html#c_gIfxpyXJhS"></a><span class="cm-qualifier">.actor</span>  { <span class="cm-property">position</span>: <span class="cm-atom">absolute</span>;            }
<span class="cm-qualifier">.coin</span>   { <span class="cm-property">background</span>: <span class="cm-atom">rgb</span>(<span class="cm-number">241</span>, <span class="cm-number">229</span>, <span class="cm-number">89</span>); }
<span class="cm-qualifier">.player</span> { <span class="cm-property">background</span>: <span class="cm-atom">rgb</span>(<span class="cm-number">64</span>, <span class="cm-number">64</span>, <span class="cm-number">64</span>);   }</pre>
<p><a class="p_ident" id="p_ee+EdXi5xG" href="./15_game.html#p_ee+EdXi5xG"></a>Когато се актуализира дисплея, <code>drawFrame</code> метода първо премахва старите графики на актьорите, ако има такива и след това начертава нови в новите им позиции. Можем да се изкушим да използваме повторно DOM елементи за актьори, но за да направим тази работа ще ни трябва поток от много допълнителна информация между кода на дисплея и кода на симулацията. Също ще трябва да обединим актьорите с DOM елементи, а кода на чертежа трябва да отстрани елементите, когато техните участници изчезнат. Тъй като, ще има само една шепа участници в играта, преначертаването на всички тях не е скъпо.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_qkPcdGO1jk" href="./15_game.html#c_qkPcdGO1jk"></a><span class="cm-variable">DOMDisplay</span>.<span class="cm-property">prototype</span>.<span class="cm-property">drawFrame</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>() {
  <span class="cm-keyword">if</span> (<span class="cm-keyword">this</span>.<span class="cm-property">actorLayer</span>)
    <span class="cm-keyword">this</span>.<span class="cm-property">wrap</span>.<span class="cm-property">removeChild</span>(<span class="cm-keyword">this</span>.<span class="cm-property">actorLayer</span>);
  <span class="cm-keyword">this</span>.<span class="cm-property">actorLayer</span> <span class="cm-operator">=</span> <span class="cm-keyword">this</span>.<span class="cm-property">wrap</span>.<span class="cm-property">appendChild</span>(<span class="cm-keyword">this</span>.<span class="cm-property">drawActors</span>());
  <span class="cm-keyword">this</span>.<span class="cm-property">wrap</span>.<span class="cm-property">className</span> <span class="cm-operator">=</span> <span class="cm-string">"game "</span> <span class="cm-operator">+</span> (<span class="cm-keyword">this</span>.<span class="cm-property">level</span>.<span class="cm-property">status</span> <span class="cm-operator">||</span> <span class="cm-string">""</span>);
  <span class="cm-keyword">this</span>.<span class="cm-property">scrollPlayerIntoView</span>();
};</pre>
<p><a class="p_ident" id="p_sZEoSNaFbo" href="./15_game.html#p_sZEoSNaFbo"></a>Чрез добавяне на текущото състояние на нивото, като име на клас на обвивката, можем да оформим играчите - актьори малко по-различно, когато играча печели или губи чрез добавяне на CSS правило, което влиза в сила само, когато играча има родител елемент с дадения клас.</p>
<pre data-language="text/css" class="snippet cm-s-default"><a class="c_ident" id="c_r6Td1FPyF0" href="./15_game.html#c_r6Td1FPyF0"></a><span class="cm-qualifier">.lost</span> <span class="cm-qualifier">.player</span> {
  <span class="cm-property">background</span>: <span class="cm-atom">rgb</span>(<span class="cm-number">160</span>, <span class="cm-number">64</span>, <span class="cm-number">64</span>);
}
<span class="cm-qualifier">.won</span> <span class="cm-qualifier">.player</span> {
  <span class="cm-property">box-shadow</span>: <span class="cm-number">-4px</span> <span class="cm-number">-7px</span> <span class="cm-number">8px</span> <span class="cm-keyword">white</span>, <span class="cm-number">4px</span> <span class="cm-number">-7px</span> <span class="cm-number">8px</span> <span class="cm-keyword">white</span>;
}</pre>
<p><a class="p_ident" id="p_Ta1z3iQqo1" href="./15_game.html#p_Ta1z3iQqo1"></a>След докосване на лава, цвета на играча се променя в тъмно червено, което показва изгаряне. Когато и последната монета е събрана, ще използваме две сенки на замъглени бели кутии, една горе в ляво и една горе в дясно, за да създадем ефект на бял ореол.</p>
<p id="viewport"><a class="p_ident" id="p_hU1RuMZZhL" href="./15_game.html#p_hU1RuMZZhL"></a>Ние не можем да приемем, че нивата винаги се побират в демонстрационния прозорец. Ето защо ни е необходим <code>scrollPlayerIntoView</code> - той гарантира, че ако едно ниво излезе извън рамката, скрола на рамката ще се грижи играча да бъде винаги в центъра и. Следният CSS дава на опаковката на играта в DOM елемента максимален размер и гарантира, че всичко, което е извън кутията на елемента не се вижда. Ние също така даваме на външния елемент относителна позиция, така че актьорите в него да са позиционирани спрямо горния ляв ъгъл на нивото.</p>
<pre data-language="text/css" class="snippet cm-s-default"><a class="c_ident" id="c_BblQSzixfX" href="./15_game.html#c_BblQSzixfX"></a><span class="cm-qualifier">.game</span> {
  <span class="cm-property">overflow</span>: <span class="cm-atom">hidden</span>;
  <span class="cm-property">max-width</span>: <span class="cm-number">600px</span>;
  <span class="cm-property">max-height</span>: <span class="cm-number">450px</span>;
  <span class="cm-property">position</span>: <span class="cm-atom">relative</span>;
}</pre>
<p><a class="p_ident" id="p_1/wCuAnu9B" href="./15_game.html#p_1/wCuAnu9B"></a>В <code>scrollPlayerIntoView</code> метода, откриваме позицията на играча и актуализираме позицията на скрола на елемента на обвивката. Сменяме позицията на скрола чрез манипулиране на този елемент с <code>scrollLeft</code> и <code>scrollTop</code> свойствата, когато играча е твърде близо до края.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_JpSyU0Vlxc" href="./15_game.html#c_JpSyU0Vlxc"></a><span class="cm-variable">DOMDisplay</span>.<span class="cm-property">prototype</span>.<span class="cm-property">scrollPlayerIntoView</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>() {
  <span class="cm-keyword">var</span> <span class="cm-def">width</span> <span class="cm-operator">=</span> <span class="cm-keyword">this</span>.<span class="cm-property">wrap</span>.<span class="cm-property">clientWidth</span>;
  <span class="cm-keyword">var</span> <span class="cm-def">height</span> <span class="cm-operator">=</span> <span class="cm-keyword">this</span>.<span class="cm-property">wrap</span>.<span class="cm-property">clientHeight</span>;
  <span class="cm-keyword">var</span> <span class="cm-def">margin</span> <span class="cm-operator">=</span> <span class="cm-variable-2">width</span> <span class="cm-operator">/</span> <span class="cm-number">3</span>;

  <span class="cm-comment">// The viewport</span>
  <span class="cm-keyword">var</span> <span class="cm-def">left</span> <span class="cm-operator">=</span> <span class="cm-keyword">this</span>.<span class="cm-property">wrap</span>.<span class="cm-property">scrollLeft</span>, <span class="cm-def">right</span> <span class="cm-operator">=</span> <span class="cm-variable-2">left</span> <span class="cm-operator">+</span> <span class="cm-variable-2">width</span>;
  <span class="cm-keyword">var</span> <span class="cm-def">top</span> <span class="cm-operator">=</span> <span class="cm-keyword">this</span>.<span class="cm-property">wrap</span>.<span class="cm-property">scrollTop</span>, <span class="cm-def">bottom</span> <span class="cm-operator">=</span> <span class="cm-variable-2">top</span> <span class="cm-operator">+</span> <span class="cm-variable-2">height</span>;

  <span class="cm-keyword">var</span> <span class="cm-def">player</span> <span class="cm-operator">=</span> <span class="cm-keyword">this</span>.<span class="cm-property">level</span>.<span class="cm-property">player</span>;
  <span class="cm-keyword">var</span> <span class="cm-def">center</span> <span class="cm-operator">=</span> <span class="cm-variable-2">player</span>.<span class="cm-property">pos</span>.<span class="cm-property">plus</span>(<span class="cm-variable-2">player</span>.<span class="cm-property">size</span>.<span class="cm-property">times</span>(<span class="cm-number">0.5</span>))
                 .<span class="cm-property">times</span>(<span class="cm-variable">scale</span>);

  <span class="cm-keyword">if</span> (<span class="cm-variable-2">center</span>.<span class="cm-property">x</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">left</span> <span class="cm-operator">+</span> <span class="cm-variable-2">margin</span>)
    <span class="cm-keyword">this</span>.<span class="cm-property">wrap</span>.<span class="cm-property">scrollLeft</span> <span class="cm-operator">=</span> <span class="cm-variable-2">center</span>.<span class="cm-property">x</span> <span class="cm-operator">-</span> <span class="cm-variable-2">margin</span>;
  <span class="cm-keyword">else</span> <span class="cm-keyword">if</span> (<span class="cm-variable-2">center</span>.<span class="cm-property">x</span> <span class="cm-operator">&gt;</span> <span class="cm-variable-2">right</span> <span class="cm-operator">-</span> <span class="cm-variable-2">margin</span>)
    <span class="cm-keyword">this</span>.<span class="cm-property">wrap</span>.<span class="cm-property">scrollLeft</span> <span class="cm-operator">=</span> <span class="cm-variable-2">center</span>.<span class="cm-property">x</span> <span class="cm-operator">+</span> <span class="cm-variable-2">margin</span> <span class="cm-operator">-</span> <span class="cm-variable-2">width</span>;
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">center</span>.<span class="cm-property">y</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">top</span> <span class="cm-operator">+</span> <span class="cm-variable-2">margin</span>)
    <span class="cm-keyword">this</span>.<span class="cm-property">wrap</span>.<span class="cm-property">scrollTop</span> <span class="cm-operator">=</span> <span class="cm-variable-2">center</span>.<span class="cm-property">y</span> <span class="cm-operator">-</span> <span class="cm-variable-2">margin</span>;
  <span class="cm-keyword">else</span> <span class="cm-keyword">if</span> (<span class="cm-variable-2">center</span>.<span class="cm-property">y</span> <span class="cm-operator">&gt;</span> <span class="cm-variable-2">bottom</span> <span class="cm-operator">-</span> <span class="cm-variable-2">margin</span>)
    <span class="cm-keyword">this</span>.<span class="cm-property">wrap</span>.<span class="cm-property">scrollTop</span> <span class="cm-operator">=</span> <span class="cm-variable-2">center</span>.<span class="cm-property">y</span> <span class="cm-operator">+</span> <span class="cm-variable-2">margin</span> <span class="cm-operator">-</span> <span class="cm-variable-2">height</span>;
};</pre>
<p><a class="p_ident" id="p_3qHzB4KoD+" href="./15_game.html#p_3qHzB4KoD+"></a>Начинът, по който центърът на играча е показан, демонстрира как методите на нашия тип <code>Vector</code> позволяват изчисленията с обекти да бъдат писани по четим начин. За да намерим центъра на актьора, ние добавяме неговата позиция (горния ляв ъгъл) и половината му размер. Това е центърът на координатите на нивото, но имаме нужда от него в пиксели-координати, за да можем след това да умножим резултата от вектора по нашия мащаб на дисплея.</p>
<p><a class="p_ident" id="p_nyYhuiyn32" href="./15_game.html#p_nyYhuiyn32"></a>После, редица проверки проверяват позицията на играча да не е извън допустимия диапазон. Имайте в предвид, че понякога това прави маса глупости с координатите на скрола, под нула или извън скролната зона на елемента. Условие на <code>scrollLeft</code> до -10 ще го превърне в 0.</p>
<p><a class="p_ident" id="p_MFibm1pU7d" href="./15_game.html#p_MFibm1pU7d"></a>Щеше да е малко по-лесно да опитаме да местим играча винаги в центъра на демонстрационния прозорец. Но това създава шокиращ ефект. Когато скача, гледката непрекъснато се мести нагоре и надолу. Ще е по-приятно да има “неутрална” зона в средата на екрана, където можем да се движим без да причиняваме скролване.</p>
<p><a class="p_ident" id="p_5o/NVpkfaU" href="./15_game.html#p_5o/NVpkfaU"></a>И накрая, се нуждаем от начин да изчистим показаното ниво, което да се използва, когато преминаваме в следващото ниво или нулираме сегашното ниво.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_MTWKiFt3b3" href="./15_game.html#c_MTWKiFt3b3"></a><span class="cm-variable">DOMDisplay</span>.<span class="cm-property">prototype</span>.<span class="cm-property">clear</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>() {
  <span class="cm-keyword">this</span>.<span class="cm-property">wrap</span>.<span class="cm-property">parentNode</span>.<span class="cm-property">removeChild</span>(<span class="cm-keyword">this</span>.<span class="cm-property">wrap</span>);
};</pre>
<p><a class="p_ident" id="p_LSD2j1d23Y" href="./15_game.html#p_LSD2j1d23Y"></a>В момента сме в състояние да покажем нашето миниатюрно ниво.</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class="c_ident" id="c_RY/T0/6wz3" href="./15_game.html#c_RY/T0/6wz3"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">link</span> <span class="cm-attribute">rel</span>=<span class="cm-string">"stylesheet"</span> <span class="cm-attribute">href</span>=<span class="cm-string">"css/game.css"</span><span class="cm-tag cm-bracket">&gt;</span>

<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-keyword">var</span> <span class="cm-variable">simpleLevel</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">Level</span>(<span class="cm-variable">simpleLevelPlan</span>);
  <span class="cm-keyword">var</span> <span class="cm-variable">display</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">DOMDisplay</span>(<span class="cm-variable">document</span>.<span class="cm-property">body</span>, <span class="cm-variable">simpleLevel</span>);
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>
<p><a class="p_ident" id="p_CLn8fpSTCw" href="./15_game.html#p_CLn8fpSTCw"></a>The <code>&lt;link&gt;</code> тага в комбинация с <code>rel="stylesheet"</code> е начин да се зареди файл на CSS в страницата. Файла <code>game.css</code> съдържа стиловете необходими за нашата игра.</p>
<h2><a class="h_ident" id="h_zX4xC7JBQU" href="./15_game.html#h_zX4xC7JBQU"></a>Движение  и  сблъсък</h2>
<p><a class="p_ident" id="p_VZl40vezkA" href="./15_game.html#p_VZl40vezkA"></a>Сега сме на мястото, където можем да започнем да добавяме движение, най-интересния аспект от играта. Основният подход, използван в повечето игри, е да се раздели времето на малки стъпки и всяка стъпка премества актьорите на разстояние съответстващо на тяхната скорост (преместване в секунда) умножено по размера на  времето за стъпка (в секунди).</p>
<p><a class="p_ident" id="p_+a3yt6NY8z" href="./15_game.html#p_+a3yt6NY8z"></a>Това е лесно. Трудната част е взаимодействието между елементите. Когато играчът удари стена или под той не може просто да се движи през тях. Играта трябва да забележи, когато дадено движение причинява удар на един обект с друг и реагира по съответния начин. За стени движението трябва да бъде спряно. За монети, монетата трябва да бъде взета и т.н.</p>
<p><a class="p_ident" id="p_AidQCfGku0" href="./15_game.html#p_AidQCfGku0"></a>Решаването на тези общи случаи е голяма задача. Можете да намерите библиотеки, обикновено се наричат физични двигатели, които симулират взаимодействие между физически обекти в две или три измерения. Ще използваме по-скромен подход в тази глава, манипулиране единствено сблъсъците между правоъгълни предмети и обработката им по един доста опростен начин.</p>
<p><a class="p_ident" id="p_qnEGluIxK3" href="./15_game.html#p_qnEGluIxK3"></a>Преди да преместим играч или блок от лава, ние тестваме дали движението не идва от вътрешността на не-празна част на фона. Ако е така, просто спираме движението напълно. Отговорът на такъв сблъсък зависи от вида на актьора: играча ще спре, докато блока на лавата се съвземе.</p>
<p><a class="p_ident" id="p_Y/iDVnt+Uc" href="./15_game.html#p_Y/iDVnt+Uc"></a>Този подход изисква стъпките от време да бъдат по-скоро малки, тъй като това ще доведе до движение, което да спре преди обектите да се докоснат. Ако стъпките от време (и по този начин етапите от време) са твърде големи, играчът ще се окаже в положение да лети на забележимо разстояние над земята. Друг подход, може би по-добър но по-сложен, е да се намери точното място на сблъсъка и да се премести там. Ние ще използваме простия подход и ще скрием проблемите чрез осигуряване на анимация в малки стъпки.</p>
<p><a class="p_ident" id="p_mgrJ3S203s" href="./15_game.html#p_mgrJ3S203s"></a>Този метод ни казва дали един правоъгълник (с посочена позиция и размер) се покрива с всяко празно пространство на мрежата на фона.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_uIS9dqP9so" href="./15_game.html#c_uIS9dqP9so"></a><span class="cm-variable">Level</span>.<span class="cm-property">prototype</span>.<span class="cm-property">obstacleAt</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">pos</span>, <span class="cm-def">size</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">xStart</span> <span class="cm-operator">=</span> <span class="cm-variable">Math</span>.<span class="cm-property">floor</span>(<span class="cm-variable-2">pos</span>.<span class="cm-property">x</span>);
  <span class="cm-keyword">var</span> <span class="cm-def">xEnd</span> <span class="cm-operator">=</span> <span class="cm-variable">Math</span>.<span class="cm-property">ceil</span>(<span class="cm-variable-2">pos</span>.<span class="cm-property">x</span> <span class="cm-operator">+</span> <span class="cm-variable-2">size</span>.<span class="cm-property">x</span>);
  <span class="cm-keyword">var</span> <span class="cm-def">yStart</span> <span class="cm-operator">=</span> <span class="cm-variable">Math</span>.<span class="cm-property">floor</span>(<span class="cm-variable-2">pos</span>.<span class="cm-property">y</span>);
  <span class="cm-keyword">var</span> <span class="cm-def">yEnd</span> <span class="cm-operator">=</span> <span class="cm-variable">Math</span>.<span class="cm-property">ceil</span>(<span class="cm-variable-2">pos</span>.<span class="cm-property">y</span> <span class="cm-operator">+</span> <span class="cm-variable-2">size</span>.<span class="cm-property">y</span>);

  <span class="cm-keyword">if</span> (<span class="cm-variable-2">xStart</span> <span class="cm-operator">&lt;</span> <span class="cm-number">0</span> <span class="cm-operator">||</span> <span class="cm-variable-2">xEnd</span> <span class="cm-operator">&gt;</span> <span class="cm-keyword">this</span>.<span class="cm-property">width</span> <span class="cm-operator">||</span> <span class="cm-variable-2">yStart</span> <span class="cm-operator">&lt;</span> <span class="cm-number">0</span>)
    <span class="cm-keyword">return</span> <span class="cm-string">"wall"</span>;
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">yEnd</span> <span class="cm-operator">&gt;</span> <span class="cm-keyword">this</span>.<span class="cm-property">height</span>)
    <span class="cm-keyword">return</span> <span class="cm-string">"lava"</span>;
  <span class="cm-keyword">for</span> (<span class="cm-keyword">var</span> <span class="cm-def">y</span> <span class="cm-operator">=</span> <span class="cm-variable-2">yStart</span>; <span class="cm-variable-2">y</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">yEnd</span>; <span class="cm-variable-2">y</span><span class="cm-operator">++</span>) {
    <span class="cm-keyword">for</span> (<span class="cm-keyword">var</span> <span class="cm-def">x</span> <span class="cm-operator">=</span> <span class="cm-variable-2">xStart</span>; <span class="cm-variable-2">x</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">xEnd</span>; <span class="cm-variable-2">x</span><span class="cm-operator">++</span>) {
      <span class="cm-keyword">var</span> <span class="cm-def">fieldType</span> <span class="cm-operator">=</span> <span class="cm-keyword">this</span>.<span class="cm-property">grid</span>[<span class="cm-variable-2">y</span>][<span class="cm-variable-2">x</span>];
      <span class="cm-keyword">if</span> (<span class="cm-variable-2">fieldType</span>) <span class="cm-keyword">return</span> <span class="cm-variable-2">fieldType</span>;
    }
  }
};</pre>
<p><a class="p_ident" id="p_PToDD5K9+0" href="./15_game.html#p_PToDD5K9+0"></a>Този метод изчислява набор от мрежови квадрати, с които тялото се препокрива, като използва <code>Math.floor</code>
и <code>Math.ceil</code> за координатите на тялото. Не забравяйте, че мрежата е от квадрати с размер 1х1 единици. Чрез закръгляне страните на кутията на горе и на долу, ние получаваме обхвата на фоновите квадрати, които кутията докосва.</p>
<div class="image">
  <img src="./media/game-grid.svg" alt="Finding collisions on a grid">
</div>
<p><a class="p_ident" id="p_MZ2cPIh/k/" href="./15_game.html#p_MZ2cPIh/k/"></a>Ако тялото стърчи извън нивото, ние винаги връщаме <code>"wall"</code> за страните и тавана и <code>"lava"</code> за дъното. Това гарантира, че играчът винаги умира, когато падне извън света. Когато тялото е точно в рамката на мрежата, ние циклим над блока от мрежови квадрати определени със закръгляне на координатите и връщаме съдържанието на първия  не-празен квадрат, който открием</p>
<p><a class="p_ident" id="p_oAeaIvbuEY" href="./15_game.html#p_oAeaIvbuEY"></a>Сблъсъка между играча и други динамични актьори (монети, лава) се изпълнява, след като играча се премести. Когато движението на играча продължава навътре в друг актьор, се активира подходящ ефект - събиране на монета или умиране.</p>
<p><a class="p_ident" id="p_9zGn/O3Wbz" href="./15_game.html#p_9zGn/O3Wbz"></a>Този метод сканира масива от участници, като търси актьор, който се  припокрива с този, който е даден, като аргумент.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_WU18TYQa9n" href="./15_game.html#c_WU18TYQa9n"></a><span class="cm-variable">Level</span>.<span class="cm-property">prototype</span>.<span class="cm-property">actorAt</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">actor</span>) {
  <span class="cm-keyword">for</span> (<span class="cm-keyword">var</span> <span class="cm-def">i</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>; <span class="cm-variable-2">i</span> <span class="cm-operator">&lt;</span> <span class="cm-keyword">this</span>.<span class="cm-property">actors</span>.<span class="cm-property">length</span>; <span class="cm-variable-2">i</span><span class="cm-operator">++</span>) {
    <span class="cm-keyword">var</span> <span class="cm-def">other</span> <span class="cm-operator">=</span> <span class="cm-keyword">this</span>.<span class="cm-property">actors</span>[<span class="cm-variable-2">i</span>];
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">other</span> <span class="cm-operator">!=</span> <span class="cm-variable-2">actor</span> <span class="cm-operator">&amp;&amp;</span>
        <span class="cm-variable-2">actor</span>.<span class="cm-property">pos</span>.<span class="cm-property">x</span> <span class="cm-operator">+</span> <span class="cm-variable-2">actor</span>.<span class="cm-property">size</span>.<span class="cm-property">x</span> <span class="cm-operator">&gt;</span> <span class="cm-variable-2">other</span>.<span class="cm-property">pos</span>.<span class="cm-property">x</span> <span class="cm-operator">&amp;&amp;</span>
        <span class="cm-variable-2">actor</span>.<span class="cm-property">pos</span>.<span class="cm-property">x</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">other</span>.<span class="cm-property">pos</span>.<span class="cm-property">x</span> <span class="cm-operator">+</span> <span class="cm-variable-2">other</span>.<span class="cm-property">size</span>.<span class="cm-property">x</span> <span class="cm-operator">&amp;&amp;</span>
        <span class="cm-variable-2">actor</span>.<span class="cm-property">pos</span>.<span class="cm-property">y</span> <span class="cm-operator">+</span> <span class="cm-variable-2">actor</span>.<span class="cm-property">size</span>.<span class="cm-property">y</span> <span class="cm-operator">&gt;</span> <span class="cm-variable-2">other</span>.<span class="cm-property">pos</span>.<span class="cm-property">y</span> <span class="cm-operator">&amp;&amp;</span>
        <span class="cm-variable-2">actor</span>.<span class="cm-property">pos</span>.<span class="cm-property">y</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">other</span>.<span class="cm-property">pos</span>.<span class="cm-property">y</span> <span class="cm-operator">+</span> <span class="cm-variable-2">other</span>.<span class="cm-property">size</span>.<span class="cm-property">y</span>)
      <span class="cm-keyword">return</span> <span class="cm-variable-2">other</span>;
  }
};</pre>
<h2 id="actors"><a class="h_ident" id="h_CK9RMsBUn4" href="./15_game.html#h_CK9RMsBUn4"></a>Актьори  и  действия</h2>
<p><a class="p_ident" id="p_HatfNTrDd5" href="./15_game.html#p_HatfNTrDd5"></a>Метода <code>animate</code> на типа <code>Level</code> дава на всички участници в нивото шанс да се движат. Неговия аргумент <code>step</code> е стъпка на времето в секунди. <code>keys</code> съдържа информация за клавишите със стрелки  за играча, когато са натиснати.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_qGNXH1TwL8" href="./15_game.html#c_qGNXH1TwL8"></a><span class="cm-keyword">var</span> <span class="cm-variable">maxStep</span> <span class="cm-operator">=</span> <span class="cm-number">0.05</span>;

<span class="cm-variable">Level</span>.<span class="cm-property">prototype</span>.<span class="cm-property">animate</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">step</span>, <span class="cm-def">keys</span>) {
  <span class="cm-keyword">if</span> (<span class="cm-keyword">this</span>.<span class="cm-property">status</span> <span class="cm-operator">!=</span> <span class="cm-atom">null</span>)
    <span class="cm-keyword">this</span>.<span class="cm-property">finishDelay</span> <span class="cm-operator">-=</span> <span class="cm-variable-2">step</span>;

  <span class="cm-keyword">while</span> (<span class="cm-variable-2">step</span> <span class="cm-operator">&gt;</span> <span class="cm-number">0</span>) {
    <span class="cm-keyword">var</span> <span class="cm-def">thisStep</span> <span class="cm-operator">=</span> <span class="cm-variable">Math</span>.<span class="cm-property">min</span>(<span class="cm-variable-2">step</span>, <span class="cm-variable">maxStep</span>);
    <span class="cm-keyword">this</span>.<span class="cm-property">actors</span>.<span class="cm-property">forEach</span>(<span class="cm-keyword">function</span>(<span class="cm-def">actor</span>) {
      <span class="cm-variable-2">actor</span>.<span class="cm-property">act</span>(<span class="cm-variable-2">thisStep</span>, <span class="cm-keyword">this</span>, <span class="cm-variable-2">keys</span>);
    }, <span class="cm-keyword">this</span>);
    <span class="cm-variable-2">step</span> <span class="cm-operator">-=</span> <span class="cm-variable-2">thisStep</span>;
  }
};</pre>
<p><a class="p_ident" id="p_3CL3X0Momn" href="./15_game.html#p_3CL3X0Momn"></a>Когато свойството <code>status</code> на нивото не е празна стойност (това е случаят, когато играчът е спечелил или загубил) трябва да отчетем резултата със свойството <code>finishDelay</code>, което е точно момента между точката на преминаване към мястото на победа или загуба и на мястото, където искаме да спре да показва нивото.</p>
<p><a class="p_ident" id="p_1RlyY9ZKcW" href="./15_game.html#p_1RlyY9ZKcW"></a><code>While</code> цикъла обхожда стъпките от време, където анимираме в подходящи малки парчета. Той гарантира, че няма взета нито една стъпка по-голяма от <code>maxStep</code> is taken. For example, a <code>step</code>. Например, една стъпка от 0.12 секунди ще бъде нарязана на две стъпки от по 0.05 и една стъпка от 0.02 секунди.</p>
<p><a class="p_ident" id="p_AiCSiwkX6Y" href="./15_game.html#p_AiCSiwkX6Y"></a>Обекта на актьорите има метод <code>act</code>, който приема за аргументи стъпка на времето, обекта ниво и <code>keys</code> обекта. Това е обекта на типа актьор <code>Lava</code>, който игнорира <code>keys</code> обекта.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_y3oz8d4Sdf" href="./15_game.html#c_y3oz8d4Sdf"></a><span class="cm-variable">Lava</span>.<span class="cm-property">prototype</span>.<span class="cm-property">act</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">step</span>, <span class="cm-def">level</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">newPos</span> <span class="cm-operator">=</span> <span class="cm-keyword">this</span>.<span class="cm-property">pos</span>.<span class="cm-property">plus</span>(<span class="cm-keyword">this</span>.<span class="cm-property">speed</span>.<span class="cm-property">times</span>(<span class="cm-variable-2">step</span>));
  <span class="cm-keyword">if</span> (<span class="cm-operator">!</span><span class="cm-variable-2">level</span>.<span class="cm-property">obstacleAt</span>(<span class="cm-variable-2">newPos</span>, <span class="cm-keyword">this</span>.<span class="cm-property">size</span>))
    <span class="cm-keyword">this</span>.<span class="cm-property">pos</span> <span class="cm-operator">=</span> <span class="cm-variable-2">newPos</span>;
  <span class="cm-keyword">else</span> <span class="cm-keyword">if</span> (<span class="cm-keyword">this</span>.<span class="cm-property">repeatPos</span>)
    <span class="cm-keyword">this</span>.<span class="cm-property">pos</span> <span class="cm-operator">=</span> <span class="cm-keyword">this</span>.<span class="cm-property">repeatPos</span>;
  <span class="cm-keyword">else</span>
    <span class="cm-keyword">this</span>.<span class="cm-property">speed</span> <span class="cm-operator">=</span> <span class="cm-keyword">this</span>.<span class="cm-property">speed</span>.<span class="cm-property">times</span>(<span class="cm-operator">-</span><span class="cm-number">1</span>);
};</pre>
<p><a class="p_ident" id="p_hQ66AcUb17" href="./15_game.html#p_hQ66AcUb17"></a>Той изчислява нова позиция чрез добавяне на продукта на стъпка от времето и сегашната скорост от старата позиция. Ако няма пречка, която да блокира тази нова позиция, тя се движи на там. Ако има препятствие поведението зависи от вида на лава блока - капе лава или има свойство <code>repeatPos</code>, с което се връща обратно, когато удари нещо. Изригващата лава просто обръща скоростта (като се умножи по -1), за да започне да се движи в обратна посока.</p>
<p><a class="p_ident" id="p_1RXQ29sidv" href="./15_game.html#p_1RXQ29sidv"></a>Монетите използват своя <code>act</code> метод за да потрепват. Те пренебрегват сблъсъци, тъй като се клатушкат във вътрешноста на собствения си квадрат и сблъсъците ще се обработват от метода <code>act</code> на играча.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_CVksWY2lbJ" href="./15_game.html#c_CVksWY2lbJ"></a><span class="cm-keyword">var</span> <span class="cm-variable">wobbleSpeed</span> <span class="cm-operator">=</span> <span class="cm-number">8</span>, <span class="cm-variable">wobbleDist</span> <span class="cm-operator">=</span> <span class="cm-number">0.07</span>;

<span class="cm-variable">Coin</span>.<span class="cm-property">prototype</span>.<span class="cm-property">act</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">step</span>) {
  <span class="cm-keyword">this</span>.<span class="cm-property">wobble</span> <span class="cm-operator">+=</span> <span class="cm-variable-2">step</span> <span class="cm-operator">*</span> <span class="cm-variable">wobbleSpeed</span>;
  <span class="cm-keyword">var</span> <span class="cm-def">wobblePos</span> <span class="cm-operator">=</span> <span class="cm-variable">Math</span>.<span class="cm-property">sin</span>(<span class="cm-keyword">this</span>.<span class="cm-property">wobble</span>) <span class="cm-operator">*</span> <span class="cm-variable">wobbleDist</span>;
  <span class="cm-keyword">this</span>.<span class="cm-property">pos</span> <span class="cm-operator">=</span> <span class="cm-keyword">this</span>.<span class="cm-property">basePos</span>.<span class="cm-property">plus</span>(<span class="cm-keyword">new</span> <span class="cm-variable">Vector</span>(<span class="cm-number">0</span>, <span class="cm-variable-2">wobblePos</span>));
};</pre>
<p><a class="p_ident" id="p_aXWUL4a4Y+" href="./15_game.html#p_aXWUL4a4Y+"></a>Свойството <code>wobble</code> се актуализира за да следим времето и след това се използва, като аргумент за <code>Math.sin</code> за да създаде вълна, която се използва за изчисляване на нова позиция.</p>
<p><a class="p_ident" id="p_7eSdIMS/wV" href="./15_game.html#p_7eSdIMS/wV"></a>Остана само играча. Движението на <em>Player</em> се обработва отделно за всяка ос, защото когато удря пода не трябва да пречи на хоризонталното движение, както и когато удря стена не трябва спира движението на падане или скачане. следващия метод изпълнява хоризонталната част:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_Fx/WuBkAiY" href="./15_game.html#c_Fx/WuBkAiY"></a><span class="cm-keyword">var</span> <span class="cm-variable">playerXSpeed</span> <span class="cm-operator">=</span> <span class="cm-number">7</span>;

<span class="cm-variable">Player</span>.<span class="cm-property">prototype</span>.<span class="cm-property">moveX</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">step</span>, <span class="cm-def">level</span>, <span class="cm-def">keys</span>) {
  <span class="cm-keyword">this</span>.<span class="cm-property">speed</span>.<span class="cm-property">x</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>;
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">keys</span>.<span class="cm-property">left</span>) <span class="cm-keyword">this</span>.<span class="cm-property">speed</span>.<span class="cm-property">x</span> <span class="cm-operator">-=</span> <span class="cm-variable">playerXSpeed</span>;
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">keys</span>.<span class="cm-property">right</span>) <span class="cm-keyword">this</span>.<span class="cm-property">speed</span>.<span class="cm-property">x</span> <span class="cm-operator">+=</span> <span class="cm-variable">playerXSpeed</span>;

  <span class="cm-keyword">var</span> <span class="cm-def">motion</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">Vector</span>(<span class="cm-keyword">this</span>.<span class="cm-property">speed</span>.<span class="cm-property">x</span> <span class="cm-operator">*</span> <span class="cm-variable-2">step</span>, <span class="cm-number">0</span>);
  <span class="cm-keyword">var</span> <span class="cm-def">newPos</span> <span class="cm-operator">=</span> <span class="cm-keyword">this</span>.<span class="cm-property">pos</span>.<span class="cm-property">plus</span>(<span class="cm-variable-2">motion</span>);
  <span class="cm-keyword">var</span> <span class="cm-def">obstacle</span> <span class="cm-operator">=</span> <span class="cm-variable-2">level</span>.<span class="cm-property">obstacleAt</span>(<span class="cm-variable-2">newPos</span>, <span class="cm-keyword">this</span>.<span class="cm-property">size</span>);
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">obstacle</span>)
    <span class="cm-variable-2">level</span>.<span class="cm-property">playerTouched</span>(<span class="cm-variable-2">obstacle</span>);
  <span class="cm-keyword">else</span>
    <span class="cm-keyword">this</span>.<span class="cm-property">pos</span> <span class="cm-operator">=</span> <span class="cm-variable-2">newPos</span>;
};</pre>
<p><a class="p_ident" id="p_Tdw21cw9Dq" href="./15_game.html#p_Tdw21cw9Dq"></a>Хоризонталното движение се изчислява на базата на състоянието на левия и десния клавиш със стрелка. Когато едно движение е причина играча да удари в нещо в нивото, метода <code>playerTouched</code> който се занимава с неща, като умиране в лава и събиране на монети се извиква. В противен случай обекта актуализира своята позиция</p>
<p><a class="p_ident" id="p_du3894nYAV" href="./15_game.html#p_du3894nYAV"></a>Вертикалното движение работи по подобен начин, но трябва да симулира скок и гравитация.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_G4ZeyHb3zj" href="./15_game.html#c_G4ZeyHb3zj"></a><span class="cm-keyword">var</span> <span class="cm-variable">gravity</span> <span class="cm-operator">=</span> <span class="cm-number">30</span>;
<span class="cm-keyword">var</span> <span class="cm-variable">jumpSpeed</span> <span class="cm-operator">=</span> <span class="cm-number">17</span>;

<span class="cm-variable">Player</span>.<span class="cm-property">prototype</span>.<span class="cm-property">moveY</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">step</span>, <span class="cm-def">level</span>, <span class="cm-def">keys</span>) {
  <span class="cm-keyword">this</span>.<span class="cm-property">speed</span>.<span class="cm-property">y</span> <span class="cm-operator">+=</span> <span class="cm-variable-2">step</span> <span class="cm-operator">*</span> <span class="cm-variable">gravity</span>;
  <span class="cm-keyword">var</span> <span class="cm-def">motion</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">Vector</span>(<span class="cm-number">0</span>, <span class="cm-keyword">this</span>.<span class="cm-property">speed</span>.<span class="cm-property">y</span> <span class="cm-operator">*</span> <span class="cm-variable-2">step</span>);
  <span class="cm-keyword">var</span> <span class="cm-def">newPos</span> <span class="cm-operator">=</span> <span class="cm-keyword">this</span>.<span class="cm-property">pos</span>.<span class="cm-property">plus</span>(<span class="cm-variable-2">motion</span>);
  <span class="cm-keyword">var</span> <span class="cm-def">obstacle</span> <span class="cm-operator">=</span> <span class="cm-variable-2">level</span>.<span class="cm-property">obstacleAt</span>(<span class="cm-variable-2">newPos</span>, <span class="cm-keyword">this</span>.<span class="cm-property">size</span>);
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">obstacle</span>) {
    <span class="cm-variable-2">level</span>.<span class="cm-property">playerTouched</span>(<span class="cm-variable-2">obstacle</span>);
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">keys</span>.<span class="cm-property">up</span> <span class="cm-operator">&amp;&amp;</span> <span class="cm-keyword">this</span>.<span class="cm-property">speed</span>.<span class="cm-property">y</span> <span class="cm-operator">&gt;</span> <span class="cm-number">0</span>)
      <span class="cm-keyword">this</span>.<span class="cm-property">speed</span>.<span class="cm-property">y</span> <span class="cm-operator">=</span> <span class="cm-operator">-</span><span class="cm-variable">jumpSpeed</span>;
    <span class="cm-keyword">else</span>
      <span class="cm-keyword">this</span>.<span class="cm-property">speed</span>.<span class="cm-property">y</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>;
  } <span class="cm-keyword">else</span> {
    <span class="cm-keyword">this</span>.<span class="cm-property">pos</span> <span class="cm-operator">=</span> <span class="cm-variable-2">newPos</span>;
  }
};</pre>
<p><a class="p_ident" id="p_n3f+aTx4m7" href="./15_game.html#p_n3f+aTx4m7"></a>В началото на метода, играча ускорява вертикално за отчитане на гравитацията. Гравитацията, скоростта на скока и почти всички останали константи в тази игра са били определени с опити и грешки. Тествах различни стойности, докато открих комбинация, която да ми хареса.</p>
<p><a class="p_ident" id="p_Vtbh5elQbX" href="./15_game.html#p_Vtbh5elQbX"></a>След това проверяваме за пречки отново. Ако се ударим в нещо има два възможни изхода. Когато стрелката за нагоре е натисната, а ние се движим надолу (което, означава, че сме се ударили в нещо под нас), скоростта е настроена на сравнително голяма отрицателна стойност. Това причинява скок на играча. Ако това не е така, той просто се е блъснал в нещо и скоростта се нулира.</p>
<p><a class="p_ident" id="p_YCAh/Cx+MG" href="./15_game.html#p_YCAh/Cx+MG"></a>Действителния <code>act</code> метод изглежда така:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_xxPyq2OH/6" href="./15_game.html#c_xxPyq2OH/6"></a><span class="cm-variable">Player</span>.<span class="cm-property">prototype</span>.<span class="cm-property">act</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">step</span>, <span class="cm-def">level</span>, <span class="cm-def">keys</span>) {
  <span class="cm-keyword">this</span>.<span class="cm-property">moveX</span>(<span class="cm-variable-2">step</span>, <span class="cm-variable-2">level</span>, <span class="cm-variable-2">keys</span>);
  <span class="cm-keyword">this</span>.<span class="cm-property">moveY</span>(<span class="cm-variable-2">step</span>, <span class="cm-variable-2">level</span>, <span class="cm-variable-2">keys</span>);

  <span class="cm-keyword">var</span> <span class="cm-def">otherActor</span> <span class="cm-operator">=</span> <span class="cm-variable-2">level</span>.<span class="cm-property">actorAt</span>(<span class="cm-keyword">this</span>);
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">otherActor</span>)
    <span class="cm-variable-2">level</span>.<span class="cm-property">playerTouched</span>(<span class="cm-variable-2">otherActor</span>.<span class="cm-property">type</span>, <span class="cm-variable-2">otherActor</span>);

  <span class="cm-comment">// Losing animation</span>
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">level</span>.<span class="cm-property">status</span> <span class="cm-operator">==</span> <span class="cm-string">"lost"</span>) {
    <span class="cm-keyword">this</span>.<span class="cm-property">pos</span>.<span class="cm-property">y</span> <span class="cm-operator">+=</span> <span class="cm-variable-2">step</span>;
    <span class="cm-keyword">this</span>.<span class="cm-property">size</span>.<span class="cm-property">y</span> <span class="cm-operator">-=</span> <span class="cm-variable-2">step</span>;
  }
};</pre>
<p><a class="p_ident" id="p_4WJ+6ygCcZ" href="./15_game.html#p_4WJ+6ygCcZ"></a>След като се премести, следват проверките на метода за други участници, с които играча се сблъсква и отново извиква <code>playerTouched</code> ако намери един. Този път тя приема обекта на актьора, като втори аргумент, защото ако другия участник е монета, <code>playerTouched</code> трябва да знае, че монетите се събират.</p>
<p><a class="p_ident" id="p_ZvTlzr2mKf" href="./15_game.html#p_ZvTlzr2mKf"></a>Накрая, когато играчът умира (докосва лава), ще създадем малко анимация, която го кара да се “свие” или ”потъне”, като намалим височината на обекта на играча.</p>
<p><a class="p_ident" id="p_ax6pc274qT" href="./15_game.html#p_ax6pc274qT"></a>Тук е метода, който обработва сблъсъци между играча и други обекти:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_2WmUjFnyOX" href="./15_game.html#c_2WmUjFnyOX"></a><span class="cm-variable">Level</span>.<span class="cm-property">prototype</span>.<span class="cm-property">playerTouched</span> <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">type</span>, <span class="cm-def">actor</span>) {
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">type</span> <span class="cm-operator">==</span> <span class="cm-string">"lava"</span> <span class="cm-operator">&amp;&amp;</span> <span class="cm-keyword">this</span>.<span class="cm-property">status</span> <span class="cm-operator">==</span> <span class="cm-atom">null</span>) {
    <span class="cm-keyword">this</span>.<span class="cm-property">status</span> <span class="cm-operator">=</span> <span class="cm-string">"lost"</span>;
    <span class="cm-keyword">this</span>.<span class="cm-property">finishDelay</span> <span class="cm-operator">=</span> <span class="cm-number">1</span>;
  } <span class="cm-keyword">else</span> <span class="cm-keyword">if</span> (<span class="cm-variable-2">type</span> <span class="cm-operator">==</span> <span class="cm-string">"coin"</span>) {
    <span class="cm-keyword">this</span>.<span class="cm-property">actors</span> <span class="cm-operator">=</span> <span class="cm-keyword">this</span>.<span class="cm-property">actors</span>.<span class="cm-property">filter</span>(<span class="cm-keyword">function</span>(<span class="cm-def">other</span>) {
      <span class="cm-keyword">return</span> <span class="cm-variable-2">other</span> <span class="cm-operator">!=</span> <span class="cm-variable-2">actor</span>;
    });
    <span class="cm-keyword">if</span> (<span class="cm-operator">!</span><span class="cm-keyword">this</span>.<span class="cm-property">actors</span>.<span class="cm-property">some</span>(<span class="cm-keyword">function</span>(<span class="cm-def">actor</span>) {
      <span class="cm-keyword">return</span> <span class="cm-variable-2">actor</span>.<span class="cm-property">type</span> <span class="cm-operator">==</span> <span class="cm-string">"coin"</span>;
    })) {
      <span class="cm-keyword">this</span>.<span class="cm-property">status</span> <span class="cm-operator">=</span> <span class="cm-string">"won"</span>;
      <span class="cm-keyword">this</span>.<span class="cm-property">finishDelay</span> <span class="cm-operator">=</span> <span class="cm-number">1</span>;
    }
  }
};</pre>
<p><a class="p_ident" id="p_2TZ51jE0Cq" href="./15_game.html#p_2TZ51jE0Cq"></a>Когато се докосне лава, статуса на играта е настроен на “загуба”. Когато се докосне една монета, тя се отстранява от масива с участници и ако тя е последна, статуса на играта е настроен на “победа”.</p>
<p><a class="p_ident" id="p_Tb0QFBJu6P" href="./15_game.html#p_Tb0QFBJu6P"></a>Това ни дава ниво, което действително може да бъде анимирано. Всичко, което липсва в момента е кодът, който задвижва анимацията.</p>
<h2><a class="h_ident" id="h_zKch6Si/SS" href="./15_game.html#h_zKch6Si/SS"></a>Клавиши  за  движение</h2>
<p><a class="p_ident" id="p_6qSDIbEzkh" href="./15_game.html#p_6qSDIbEzkh"></a>За игра, като тази не искаме действие на клавиши с еднократно натискане. Напротив, техният ефект (преместване на фигурата на играча) да продължи да се случва толкова дълго, докато те са натиснати.</p>
<p><a class="p_ident" id="p_kKDop4NY9B" href="./15_game.html#p_kKDop4NY9B"></a>Трябва да създадем основен манипулатор, който съхранява текущото състояние на стрелката за на ляво, на дясно и на горе. Също ще трябва да извикаме <code>preventDefault</code> за тези клавиши, така че да не останат натиснати при скролване на страницата.</p>
<p><a class="p_ident" id="p_oH4kiTyM1E" href="./15_game.html#p_oH4kiTyM1E"></a>Следващата функция, когато се подаде на обект с клавишните кодове и стойностите на клавишните имена, ще върне обект, който следи текущата позиция на тези клавиши. Тя регистрира събитие с манипулаторите <code>"keydown"</code> и <code>"keyup"</code>, когато кода на клавиша присъства в набора от кодове, които се проследяват и актуализира обекта.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_cppQQkFO50" href="./15_game.html#c_cppQQkFO50"></a><span class="cm-keyword">var</span> <span class="cm-variable">arrowCodes</span> <span class="cm-operator">=</span> {<span class="cm-number cm-property">37</span>: <span class="cm-string">"left"</span>, <span class="cm-number cm-property">38</span>: <span class="cm-string">"up"</span>, <span class="cm-number cm-property">39</span>: <span class="cm-string">"right"</span>};

<span class="cm-keyword">function</span> <span class="cm-variable">trackKeys</span>(<span class="cm-def">codes</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">pressed</span> <span class="cm-operator">=</span> <span class="cm-variable">Object</span>.<span class="cm-property">create</span>(<span class="cm-atom">null</span>);
  <span class="cm-keyword">function</span> <span class="cm-def">handler</span>(<span class="cm-def">event</span>) {
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">codes</span>.<span class="cm-property">hasOwnProperty</span>(<span class="cm-variable-2">event</span>.<span class="cm-property">keyCode</span>)) {
      <span class="cm-keyword">var</span> <span class="cm-def">down</span> <span class="cm-operator">=</span> <span class="cm-variable-2">event</span>.<span class="cm-property">type</span> <span class="cm-operator">==</span> <span class="cm-string">"keydown"</span>;
      <span class="cm-variable-2">pressed</span>[<span class="cm-variable-2">codes</span>[<span class="cm-variable-2">event</span>.<span class="cm-property">keyCode</span>]] <span class="cm-operator">=</span> <span class="cm-variable-2">down</span>;
      <span class="cm-variable-2">event</span>.<span class="cm-property">preventDefault</span>();
    }
  }
  <span class="cm-variable">addEventListener</span>(<span class="cm-string">"keydown"</span>, <span class="cm-variable-2">handler</span>);
  <span class="cm-variable">addEventListener</span>(<span class="cm-string">"keyup"</span>, <span class="cm-variable-2">handler</span>);
  <span class="cm-keyword">return</span> <span class="cm-variable-2">pressed</span>;
}</pre>
<p><a class="p_ident" id="p_ijH6rqUGtM" href="./15_game.html#p_ijH6rqUGtM"></a>Забележете, че една и съща функция манипулатор се използва и за двата вида събития. Тя преглежда събитието с типа на свойството на обекта за да определи дали клавишното състояние трябва да се актуализира, с вярно за (<code>"keydown"</code>) или лъжа за (<code>"keyup"</code>).</p>
<h2 id="runAnimation"><a class="h_ident" id="h_/jwYTlYjAy" href="./15_game.html#h_/jwYTlYjAy"></a>Стартиране  на  играта</h2>
<p><a class="p_ident" id="p_3fS5a/SYfz" href="./15_game.html#p_3fS5a/SYfz"></a>Функцията 
<code>requestAnimationFrame</code>, която видяхме в <a href="./13_dom.html#animationFrame">Глава 13</a>, осигурява един добър начин за съживяване на играта. Но нейният интерфейс е доста примитивен - ако го използваме трябва да следим времето, в което нашата функция е била извикана и да извикваме отново <code>requestAnimationFrame</code> след всеки кадър.</p>
<p><a class="p_ident" id="p_6blpyw8yI3" href="./15_game.html#p_6blpyw8yI3"></a>Можем да дефинираме помощна функция, която обвива тези скучни части в удобен интерфейс и ни позволява да я извикаме просто, като <code>runAnimation</code>,  давайки и функция, която проследява времевата разлика, като аргумент и връща един кадър. Когато функцията <em>frame</em> върне <code>false</code>, анимацията спира.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_1AHi38WBun" href="./15_game.html#c_1AHi38WBun"></a><span class="cm-keyword">function</span> <span class="cm-variable">runAnimation</span>(<span class="cm-def">frameFunc</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">lastTime</span> <span class="cm-operator">=</span> <span class="cm-atom">null</span>;
  <span class="cm-keyword">function</span> <span class="cm-def">frame</span>(<span class="cm-def">time</span>) {
    <span class="cm-keyword">var</span> <span class="cm-def">stop</span> <span class="cm-operator">=</span> <span class="cm-atom">false</span>;
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">lastTime</span> <span class="cm-operator">!=</span> <span class="cm-atom">null</span>) {
      <span class="cm-keyword">var</span> <span class="cm-def">timeStep</span> <span class="cm-operator">=</span> <span class="cm-variable">Math</span>.<span class="cm-property">min</span>(<span class="cm-variable-2">time</span> <span class="cm-operator">-</span> <span class="cm-variable-2">lastTime</span>, <span class="cm-number">100</span>) <span class="cm-operator">/</span> <span class="cm-number">1000</span>;
      <span class="cm-variable-2">stop</span> <span class="cm-operator">=</span> <span class="cm-variable-2">frameFunc</span>(<span class="cm-variable-2">timeStep</span>) <span class="cm-operator">===</span> <span class="cm-atom">false</span>;
    }
    <span class="cm-variable-2">lastTime</span> <span class="cm-operator">=</span> <span class="cm-variable-2">time</span>;
    <span class="cm-keyword">if</span> (<span class="cm-operator">!</span><span class="cm-variable-2">stop</span>)
      <span class="cm-variable">requestAnimationFrame</span>(<span class="cm-variable-2">frame</span>);
  }
  <span class="cm-variable">requestAnimationFrame</span>(<span class="cm-variable-2">frame</span>);
}</pre>
<p><a class="p_ident" id="p_qaBaJbkLcb" href="./15_game.html#p_qaBaJbkLcb"></a>Аз поставих максимална стъпка на кадъра от 100 милисекунди(една десета от секундата). Когато раздела на браузъра или прозореца с нашата страница е скрит, извикванията на <code>requestAnimationFrame</code> ще бъдат спрени, докато раздела или прозореца се появят отново. В този случай разликата между <code>lastTime</code> и <code>time</code>ще бъде цялото време, през което страницата е била скрита. Напредъка на играта с много единични етапи ще изглежда глупаво и много натоварващо (запомнянето на времевите отрязъци  в метода на <a href="./15_game.html#actors"><code>анимацията</code></a>).</p>
<p><a class="p_ident" id="p_jKakPLUmwL" href="./15_game.html#p_jKakPLUmwL"></a>Функцията също превръща стъпките на времето в секунди, които са по-лесни, като величина, от колкото милисекунди.</p>
<p><a class="p_ident" id="p_e8mbmQ7w8j" href="./15_game.html#p_e8mbmQ7w8j"></a>Функцията <code>runLevel</code> взема от <code>Level</code> обекта, конструктора за дисплей и по желание функция. Тя показва нивото(в <code>document.body</code>) и позволява на потребителя да играе в него. Когато нивото е завършено (с победа или загуба), <code>runLevel</code> изчиства дисплея, спира анимацията и ако <code>andThen</code> е дадената функция, извиква тази функция със статус на ниво.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_x5O5o5qg7u" href="./15_game.html#c_x5O5o5qg7u"></a><span class="cm-keyword">var</span> <span class="cm-variable">arrows</span> <span class="cm-operator">=</span> <span class="cm-variable">trackKeys</span>(<span class="cm-variable">arrowCodes</span>);

<span class="cm-keyword">function</span> <span class="cm-variable">runLevel</span>(<span class="cm-def">level</span>, <span class="cm-def">Display</span>, <span class="cm-def">andThen</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">display</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable-2">Display</span>(<span class="cm-variable">document</span>.<span class="cm-property">body</span>, <span class="cm-variable-2">level</span>);
  <span class="cm-variable">runAnimation</span>(<span class="cm-keyword">function</span>(<span class="cm-def">step</span>) {
    <span class="cm-variable-2">level</span>.<span class="cm-property">animate</span>(<span class="cm-variable-2">step</span>, <span class="cm-variable">arrows</span>);
    <span class="cm-variable-2">display</span>.<span class="cm-property">drawFrame</span>(<span class="cm-variable-2">step</span>);
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">level</span>.<span class="cm-property">isFinished</span>()) {
      <span class="cm-variable-2">display</span>.<span class="cm-property">clear</span>();
      <span class="cm-keyword">if</span> (<span class="cm-variable-2">andThen</span>)
        <span class="cm-variable-2">andThen</span>(<span class="cm-variable-2">level</span>.<span class="cm-property">status</span>);
      <span class="cm-keyword">return</span> <span class="cm-atom">false</span>;
    }
  });
}</pre>
<p><a class="p_ident" id="p_eyKzVe0sIB" href="./15_game.html#p_eyKzVe0sIB"></a>Една игра е поредица от нива. Всеки път, когато играча умре сегашното ниво се рестартира. Когато нивото е завършено с победа, преминава към следващото ниво. Това може да се изрази със следната функция, която взема масив от планове на нива (масив от <em>strings</em>) и дисплей конструктор.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_ok+t8qqv5E" href="./15_game.html#c_ok+t8qqv5E"></a><span class="cm-keyword">function</span> <span class="cm-variable">runGame</span>(<span class="cm-def">plans</span>, <span class="cm-def">Display</span>) {
  <span class="cm-keyword">function</span> <span class="cm-def">startLevel</span>(<span class="cm-def">n</span>) {
    <span class="cm-variable">runLevel</span>(<span class="cm-keyword">new</span> <span class="cm-variable">Level</span>(<span class="cm-variable-2">plans</span>[<span class="cm-variable-2">n</span>]), <span class="cm-variable-2">Display</span>, <span class="cm-keyword">function</span>(<span class="cm-def">status</span>) {
      <span class="cm-keyword">if</span> (<span class="cm-variable-2">status</span> <span class="cm-operator">==</span> <span class="cm-string">"lost"</span>)
        <span class="cm-variable-2">startLevel</span>(<span class="cm-variable-2">n</span>);
      <span class="cm-keyword">else</span> <span class="cm-keyword">if</span> (<span class="cm-variable-2">n</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">plans</span>.<span class="cm-property">length</span> <span class="cm-operator">-</span> <span class="cm-number">1</span>)
        <span class="cm-variable-2">startLevel</span>(<span class="cm-variable-2">n</span> <span class="cm-operator">+</span> <span class="cm-number">1</span>);
      <span class="cm-keyword">else</span>
        <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"You win!"</span>);
    });
  }
  <span class="cm-variable-2">startLevel</span>(<span class="cm-number">0</span>);
}</pre>
<p><a class="p_ident" id="p_Btjn/eg/VT" href="./15_game.html#p_Btjn/eg/VT"></a>Тази функция показва особен стил на програмиране. И двете <code>runAnimation</code> и <code>runLevel</code> са по-висок порядък функции, но не са в стила, който разгледахме в <a href="./05_higher_order.html#higher_order">Глава 5</a>. Функцията - аргумент се използва за да организира нещата да се случат някъде в бъдещето и нито една от функциите не връща нещо полезно. Тяхната задача е, в известен смисъл, да планират действията. Опаковането на действията във функции ни дава начин да ги съхраним, като стойност, така че да можем да ги извикаме в най-подходящия момент.</p>
<p><a class="p_ident" id="p_HC69jX9E3n" href="./15_game.html#p_HC69jX9E3n"></a>Този стил на програмиране обикновено се нарича асинхронно програмиране. Обработката на  събития също е модел на този стил и ще видим много повече то това, когато работим със задачи, които могат да вземат произволно количество време, както например мрежовите  заявки в <a href="./17_http.html#http">Глава 17</a> и вход и изход-генерално в <a href="./20_node.html#node">Глава 20</a>.</p>
<p><a class="p_ident" id="p_/6dLhjN2fB" href="./15_game.html#p_/6dLhjN2fB"></a>Има набор от планове за нива на разположение в <code>GAME_LEVELS</code> променливата. Тази страница подържа  <code>runGame</code>, действителния старт на играта.</p>
<pre data-language="text/html" class="snippet cm-s-default" data-sandbox="null" data-focus="true"><a class="c_ident" id="c_gt8VjDAEg8" href="./15_game.html#c_gt8VjDAEg8"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">link</span> <span class="cm-attribute">rel</span>=<span class="cm-string">"stylesheet"</span> <span class="cm-attribute">href</span>=<span class="cm-string">"css/game.css"</span><span class="cm-tag cm-bracket">&gt;</span>

<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">body</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
    <span class="cm-variable">runGame</span>(<span class="cm-variable">GAME_LEVELS</span>, <span class="cm-variable">DOMDisplay</span>);
  <span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">body</span><span class="cm-tag cm-bracket">&gt;</span></pre>
<p><a class="p_ident" id="p_MkrZ67rFcA" href="./15_game.html#p_MkrZ67rFcA"></a>Вижте дали можете да победите. Беше ми доста забавно да я изградя.</p>
<h2><a class="h_ident" id="h_TcUD2vzyMe" href="./15_game.html#h_TcUD2vzyMe"></a>Упражнения</h2>
<h3><a class="h_ident" id="h_tFsh86eaJC" href="./15_game.html#h_tFsh86eaJC"></a>Game over</h3>
<p><a class="p_ident" id="p_JkKGPYeFzA" href="./15_game.html#p_JkKGPYeFzA"></a>Традиционната платформа за игри е играча да започне с ограничен брой животи и те се намалят всеки път, когато той умира. Когато му свършат животите играта се рестартира от начало.</p>
<p><a class="p_ident" id="p_oYENd6hUVn" href="./15_game.html#p_oYENd6hUVn"></a>Регулирайте <code>runGame</code> да приложи животите, като стартирате играча с три живота.</p>
<pre data-language="text/html" class="snippet cm-s-default" data-focus="true"><a class="c_ident" id="c_rB2X2oyycK" href="./15_game.html#c_rB2X2oyycK"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">link</span> <span class="cm-attribute">rel</span>=<span class="cm-string">"stylesheet"</span> <span class="cm-attribute">href</span>=<span class="cm-string">"css/game.css"</span><span class="cm-tag cm-bracket">&gt;</span>

<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">body</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-comment">// The old runGame function. Modify it...</span>
  <span class="cm-keyword">function</span> <span class="cm-variable">runGame</span>(<span class="cm-def">plans</span>, <span class="cm-def">Display</span>) {
    <span class="cm-keyword">function</span> <span class="cm-def">startLevel</span>(<span class="cm-def">n</span>) {
      <span class="cm-variable">runLevel</span>(<span class="cm-keyword">new</span> <span class="cm-variable">Level</span>(<span class="cm-variable-2">plans</span>[<span class="cm-variable-2">n</span>]), <span class="cm-variable-2">Display</span>, <span class="cm-keyword">function</span>(<span class="cm-def">status</span>) {
        <span class="cm-keyword">if</span> (<span class="cm-variable-2">status</span> <span class="cm-operator">==</span> <span class="cm-string">"lost"</span>)
          <span class="cm-variable-2">startLevel</span>(<span class="cm-variable-2">n</span>);
        <span class="cm-keyword">else</span> <span class="cm-keyword">if</span> (<span class="cm-variable-2">n</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">plans</span>.<span class="cm-property">length</span> <span class="cm-operator">-</span> <span class="cm-number">1</span>)
          <span class="cm-variable-2">startLevel</span>(<span class="cm-variable-2">n</span> <span class="cm-operator">+</span> <span class="cm-number">1</span>);
        <span class="cm-keyword">else</span>
          <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"You win!"</span>);
      });
    }
    <span class="cm-variable-2">startLevel</span>(<span class="cm-number">0</span>);
  }
  <span class="cm-variable">runGame</span>(<span class="cm-variable">GAME_LEVELS</span>, <span class="cm-variable">DOMDisplay</span>);
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">body</span><span class="cm-tag cm-bracket">&gt;</span></pre>
<div class="solution"><div class="solution-text">
<p><a class="p_ident" id="p_n7botbYRDO" href="./15_game.html#p_n7botbYRDO"></a>Най-очевидното решение би било да се направи <code>lives</code> променлива, която живее в <code>runGame</code> и по този начин е видима за <code>startLevel</code> закриването.</p>
<p><a class="p_ident" id="p_PlMiAVziM0" href="./15_game.html#p_PlMiAVziM0"></a>Друг подход, който се вписва добре в духа на останалата част от функцията, ще бъде да се добави втори параметър, така че <code>startLevel</code> да дава брой животи. Когато цялото състояние на системата се съхранява в аргументите на функцията, извикването на тази функция осигурява елегантен начин за преход към ново състояние.</p>
<p><a class="p_ident" id="p_2xJcBQOfjW" href="./15_game.html#p_2xJcBQOfjW"></a>Във всеки случай, когато нивото е загубено трябва да има два възможни изхода. Ако това е последният живот, трябва да се върнем към ниво нула с първоначален размер на живота. Ако не е, повтаряме сегашното ниво с един живот по-малко.</p>
</div></div>
<h3><a class="h_ident" id="h_cNfzuXtVqI" href="./15_game.html#h_cNfzuXtVqI"></a>Пауза на играта</h3>
<p><a class="p_ident" id="p_GkkSB/bDtt" href="./15_game.html#p_GkkSB/bDtt"></a>Уверете се, че е възможно да направите пауза (спиране) и отменяне на паузата на играта, чрез натискане на клавиш Esc.</p>
<p><a class="p_ident" id="p_FpramcVlTZ" href="./15_game.html#p_FpramcVlTZ"></a>Това може да стане чрез промяна на функцията <code>runLevel</code> да използва друго клавишно събитие манипулатор и да прекъсва и възобновява анимацията, когато клавишът  Esc е натиснат.</p>
<p><a class="p_ident" id="p_vlGSY83Wnl" href="./15_game.html#p_vlGSY83Wnl"></a>Интерфейса <code>runAnimation</code> не изглежда подходящ на пръв поглед за тази задача, но може да стане ако се промени начина му на извикване от <code>runLevel</code>.</p>
<p><a class="p_ident" id="p_0zF8rh7TLp" href="./15_game.html#p_0zF8rh7TLp"></a>Когато имате работещ начин, има нещо друго, което може да се опита. Начинът, по който са регистрирани манипулаторите на клавишните събития е малко проблемен. Обекта <code>arrows</code> в момента е глобална променлива и неговите манипулатори на събития се съхраняват дори, когато играта не работи. Може да се каже, че има изтичане от нашата система. Разширете <code>trackKeys</code> за да осигури начин да опише своите манипулатори и след това променете <code>runLevel</code> да регистрира своите манипулатори, когато се стартира и да ги отписва отново, когато се спира.</p>
<pre data-language="text/html" class="snippet cm-s-default" data-focus="true"><a class="c_ident" id="c_Yc5WbvNGlk" href="./15_game.html#c_Yc5WbvNGlk"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">link</span> <span class="cm-attribute">rel</span>=<span class="cm-string">"stylesheet"</span> <span class="cm-attribute">href</span>=<span class="cm-string">"css/game.css"</span><span class="cm-tag cm-bracket">&gt;</span>

<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">body</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-comment">// The old runLevel function. Modify this...</span>
  <span class="cm-keyword">function</span> <span class="cm-variable">runLevel</span>(<span class="cm-def">level</span>, <span class="cm-def">Display</span>, <span class="cm-def">andThen</span>) {
    <span class="cm-keyword">var</span> <span class="cm-def">display</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable-2">Display</span>(<span class="cm-variable">document</span>.<span class="cm-property">body</span>, <span class="cm-variable-2">level</span>);
    <span class="cm-variable">runAnimation</span>(<span class="cm-keyword">function</span>(<span class="cm-def">step</span>) {
      <span class="cm-variable-2">level</span>.<span class="cm-property">animate</span>(<span class="cm-variable-2">step</span>, <span class="cm-variable">arrows</span>);
      <span class="cm-variable-2">display</span>.<span class="cm-property">drawFrame</span>(<span class="cm-variable-2">step</span>);
      <span class="cm-keyword">if</span> (<span class="cm-variable-2">level</span>.<span class="cm-property">isFinished</span>()) {
        <span class="cm-variable-2">display</span>.<span class="cm-property">clear</span>();
        <span class="cm-keyword">if</span> (<span class="cm-variable-2">andThen</span>)
          <span class="cm-variable-2">andThen</span>(<span class="cm-variable-2">level</span>.<span class="cm-property">status</span>);
        <span class="cm-keyword">return</span> <span class="cm-atom">false</span>;
      }
    });
  }
  <span class="cm-variable">runGame</span>(<span class="cm-variable">GAME_LEVELS</span>, <span class="cm-variable">DOMDisplay</span>);
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">body</span><span class="cm-tag cm-bracket">&gt;</span></pre>
<div class="solution"><div class="solution-text">
<p><a class="p_ident" id="p_83gTFxcRTB" href="./15_game.html#p_83gTFxcRTB"></a>Една анимация може да се прекъсне чрез връщане на <code>false</code> от функцията <code>runAnimation</code>. И може да бъде продължена, като се извика <code>runAnimation</code> отново.</p>
<p><a class="p_ident" id="p_m7CtgKwkDs" href="./15_game.html#p_m7CtgKwkDs"></a>За да се съобщи, че анимацията трябва да се прекъсне се предава на <code>runAnimation</code>, така че тя да може да върне <code>false</code>, за тази цел може да се използва променлива заедно с манипулатор на събитие, до които тази функция трябва да има достъп.</p>
<p><a class="p_ident" id="p_FDlbFLVUQ7" href="./15_game.html#p_FDlbFLVUQ7"></a>При търсенето на начин за отписване на манипулатор регистриран от <code>trackKeys</code>, не забравяйте, че точно същата стойност на функция, която се подава на <code>addEventListener</code> трябва да бъде подадена на <code>removeEventListener</code> за да се премахване успешно. По този начин стойността на функцията манипулатор, създадена в <code>trackKeys</code> трябва да бъде достъпна от кода на <em>unregisters</em> манипулаторите.</p>
<p><a class="p_ident" id="p_mn/dvab7i4" href="./15_game.html#p_mn/dvab7i4"></a>Можете да добавите свойство към обекта, върнат от <code>trackKeys</code> съдържащ тази стойност на функцията или метод, който обработва <em>unregistering</em> директно.</p>
</div></div>
<nav>
  <a href="./14_event.html" title="previous chapter">◀</a>
  <a href="./index.html" title="cover">◆</a>
  <a href="./16_canvas.html" title="next chapter">▶</a>
</nav>
</article>
</body></html>