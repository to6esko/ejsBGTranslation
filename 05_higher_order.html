<!DOCTYPE html>
<!-- saved from url=(0050)./05_higher_order.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <title>Higher-Order Functions :: Eloquent JavaScript</title>
  <link rel="stylesheet" href="./media/codemirror.css">
  <script src="./media/acorn_codemirror.js"></script>
  <link rel="stylesheet" href="./media/ejs.css">
  <script src="./media/sandbox.js"></script>
  <script src="./media/ejs.js"></script>
  <script>var chapNum = 5;var sandboxLoadFiles = ["code/ancestry.js", "code/chapter/05_higher_order.js", "code/intro.js"];</script>
</head>

<body><article>
<nav>
  <a href="./04_data.html" title="previous chapter">◀</a>
  <a href="./index.html" title="cover">◆</a>
  <a href="./06_object.html" title="next chapter">▶</a>
</nav>

<h1><div class="chap_num">Глава 5</div>По-високо ниво функции</h1>
<blockquote>
<p><a class="p_ident" id="p_18CYJsdOxo" href="./05_higher_order.html#p_18CYJsdOxo"></a>Дзъ-ли и Дзъ-су се хвалят с размерите на най-новите си програми. „Двеста хиляди линии”, каза Дзъ-ли „без да броим коментарите!” Дзъ-су му отговорил „Пфу, моята е почти с милион линии повече.” А майстор Ян-Ма, казал „Моята най-добра програма има петстотин линии.” Като чули това, Дзъ-ли и Дзъ-су били просветени.”</p>
 <footer>Master Yuan-Ma, <cite>Книга за програмиране</cite></footer>
</blockquote>
<blockquote>
<p><a class="p_ident" id="p_MZD8y19lPz" href="./05_higher_order.html#p_MZD8y19lPz"></a>Има два начина за конструиране на софтуерен дизайн: Единият от начините е да се направи това толкова просто, че да има очевидни недостатъци, а другият начин е да се направи това, толкова сложно, че да не се виждат явните недостатъци.”</p>
 <footer>C.A.R. Hoare, <cite>1980 ACM Turing Award Lecture</cite></footer>
</blockquote>
<p><a class="p_ident" id="p_1SpKr5NIrc" href="./05_higher_order.html#p_1SpKr5NIrc"></a>Голямата програма е скъпа програма и то не само заради времето необходимо да се изгради. Размера почти винаги включва сложност и комплексност, който объркват програмистите. Обърканите програмисти, от своя страна, са склонни да въвеждат грешки (<em>bugs</em>) в програмите. Голямата програма предлага много място, където могат да се крият грешки, което ги прави трудни за намиране.</p>
<p><a class="p_ident" id="p_ethH+CXxsM" href="./05_higher_order.html#p_ethH+CXxsM"></a>За кратко да се върнем към последните две примерни програми в увода. Първата е автономна и е дълга 6 линии.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_W93KRCwXP0" href="./05_higher_order.html#c_W93KRCwXP0"></a><span class="cm-keyword">var</span> <span class="cm-variable">total</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>, <span class="cm-variable">count</span> <span class="cm-operator">=</span> <span class="cm-number">1</span>;
<span class="cm-keyword">while</span> (<span class="cm-variable">count</span> <span class="cm-operator">&lt;=</span> <span class="cm-number">10</span>) {
  <span class="cm-variable">total</span> <span class="cm-operator">+=</span> <span class="cm-variable">count</span>;
  <span class="cm-variable">count</span> <span class="cm-operator">+=</span> <span class="cm-number">1</span>;
}
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">total</span>);</pre>
<p><a class="p_ident" id="p_Sy8N6Qcb09" href="./05_higher_order.html#p_Sy8N6Qcb09"></a>Втората се позовава на две външни функции и е с дължина едни ред.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_OULOwD7HOm" href="./05_higher_order.html#c_OULOwD7HOm"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">sum</span>(<span class="cm-variable">range</span>(<span class="cm-number">1</span>, <span class="cm-number">10</span>)));</pre>
<p><a class="p_ident" id="p_srOi7846QY" href="./05_higher_order.html#p_srOi7846QY"></a>Коя е по-вероятно да съдържа бъг?</p>
<p><a class="p_ident" id="p_G+ApGqjOk4" href="./05_higher_order.html#p_G+ApGqjOk4"></a>Ако се позовем на размера на определенията за <code>sum</code> и <code>range</code>, втората програма е по-голяма от първата. Но все пак, мога да твърдя, че е по-вероятно да бъде вярна.</p>
<p><a class="p_ident" id="p_pkQRvZqQ0u" href="./05_higher_order.html#p_pkQRvZqQ0u"></a>По-вероятно е да бъде вярна, защото отговорът се изразява в речника, който съответства на решението на проблема. Сумирането на поредица от номера не е за цикли и броячи. Става въпрос за обхват и събиране.</p>
<p><a class="p_ident" id="p_VwxmDNivhe" href="./05_higher_order.html#p_VwxmDNivhe"></a>Определенията на тази лексика (на функциите <code>sum</code> и <code>range</code>), все още включват цикли, броячи и други съпътстващи подробности. Но тъй като са по-прости понятия за изразяване от програмата, като цяло, те са по-вероятно да са правилни.</p>
<h2><a class="h_ident" id="h_j9ps8qrlyo" href="./05_higher_order.html#h_j9ps8qrlyo"></a>Абстракция</h2>
<p><a class="p_ident" id="p_ZPK6t/LrMG" href="./05_higher_order.html#p_ZPK6t/LrMG"></a>В контекста на програмирането, тези видове речници, обикновено се наричат абстракции. Абстракциите крият информация и ни дават възможност да говорим за проблема на по-високо (по- абстрактно) ниво.</p>
<p><a class="p_ident" id="p_XMbJPaIiI4" href="./05_higher_order.html#p_XMbJPaIiI4"></a>Като аналогия, да сравним тези две рецепти за грахова супа:</p>
<blockquote>
<p><a class="p_ident" id="p_F+PunfZCXq" href="./05_higher_order.html#p_F+PunfZCXq"></a>Сложете 1 чаша сушен грах на човек в контейнер. Добавете вода, докато се покрие добре. Оставете граха във водата в продължение на най-малко 12 часа. Вземете граха от контейнера и го сложете в тенджера за готвене. Добавете 4 чаши вода на човек. Покрийте тенджерата с капак и варете граха в продължение на два часа. Вземете половин глава лук на човек. Нарежете го на парчета с нож. Добавете го към граха. Вземете един морков на човек. Нарежете го на парчета. С нож! Добавете го към граха. Гответе още 10 минути.”</p>

</blockquote>
<p><a class="p_ident" id="p_jOZH7oGiYb" href="./05_higher_order.html#p_jOZH7oGiYb"></a>И втората рецепта:</p>
<blockquote>
<p><a class="p_ident" id="p_iNBZReprTd" href="./05_higher_order.html#p_iNBZReprTd"></a>На човек: 1 чаша изсушен грах, половин нарязан лук, стрък целина и морков.</p>
<p><a class="p_ident" id="p_k5rI5P5p5u" href="./05_higher_order.html#p_k5rI5P5p5u"></a>Накиснете граха за 12 часа. Оставете го да къкри 2 часа в 4 чаши вода (на човек). Добавете нарязаните лук и зеленчуци. Гответе още 10 минути.”</p>

</blockquote>
<p><a class="p_ident" id="p_cSeY164LbX" href="./05_higher_order.html#p_cSeY164LbX"></a>Втората е по-кратка и по-лесна да се интерпретира. Но вие трябва да разбирате от някакво готвене свързано със думи, като: накисване, оставете да къкри, нарязване и предполагам зеленчуци.</p>
<p><a class="p_ident" id="p_g/g3l7uyEG" href="./05_higher_order.html#p_g/g3l7uyEG"></a>При програмирането не можем да разчитаме, че всички думи, от които се нуждаем ни чакат в речника. По този начин може да попаднем в схемата на първата рецепта - посочване на работата с конкретните стъпки, които компютъра трябва да извърши, една по една, сляп за концепциите от по-високо ниво, които те изискват.</p>
<p><a class="p_ident" id="p_SfvOkDsRNZ" href="./05_higher_order.html#p_SfvOkDsRNZ"></a>Това трябва да стане втора природа на програмиста, да забележи, когато една концепция се моли да бъде абстрактна нова дума.</p>
<h2><a class="h_ident" id="h_inPZJ813r4" href="./05_higher_order.html#h_inPZJ813r4"></a>Абстрактно прекосяване на масив</h2>
<p><a class="p_ident" id="p_kYV0l7wLUe" href="./05_higher_order.html#p_kYV0l7wLUe"></a>Обикновените функции, които сме виждали до сега са добър пример за изграждане на абстракции. Но понякога те са кратки.</p>
<p><a class="p_ident" id="p_zubh2XbQ26" href="./05_higher_order.html#p_zubh2XbQ26"></a>В <a href="./04_data.html#data">предишната глава</a>, този вид <code>for</code> цикъл направи няколко завъртания:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_LwyYCeYiUF" href="./05_higher_order.html#c_LwyYCeYiUF"></a><span class="cm-keyword">var</span> <span class="cm-variable">array</span> <span class="cm-operator">=</span> [<span class="cm-number">1</span>, <span class="cm-number">2</span>, <span class="cm-number">3</span>];
<span class="cm-keyword">for</span> (<span class="cm-keyword">var</span> <span class="cm-variable">i</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>; <span class="cm-variable">i</span> <span class="cm-operator">&lt;</span> <span class="cm-variable">array</span>.<span class="cm-property">length</span>; <span class="cm-variable">i</span><span class="cm-operator">++</span>) {
  <span class="cm-keyword">var</span> <span class="cm-variable">current</span> <span class="cm-operator">=</span> <span class="cm-variable">array</span>[<span class="cm-variable">i</span>];
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">current</span>);
}</pre>
<p><a class="p_ident" id="p_NFtmq7O3su" href="./05_higher_order.html#p_NFtmq7O3su"></a>Цикъла се опитва да каже: “Вземи всеки елемент от масива и го изведи в конзолата”. Но той използва по-заобиколен начин, който включва променливи - брояч и проверка <code>i</code>, дължина на масива length и допълнителна променлива-декларация за да разберем текущия елемент.
Освен, че е малко грозно, това ни дава много място за потенциални грешки. Ние може случайно да използваме повторно  променливата <code>i</code>, да сбъркаме <code>length</code> с <code>lenght</code>, да объркаме <code>i</code> с <code>current</code> и т.н.</p>
<p><a class="p_ident" id="p_Ij8hUSNURG" href="./05_higher_order.html#p_Ij8hUSNURG"></a>Така, че нека се опитаме да направим това, абстрактно под нова функция. Сещате ли се за начин?</p>
<p><a class="p_ident" id="p_QZzSQpGUXs" href="./05_higher_order.html#p_QZzSQpGUXs"></a>Е, това е лесно да се напише функция, която преминава през масив и извиква <code>console.log</code> на всеки елемент.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_zrjk1tE+gJ" href="./05_higher_order.html#c_zrjk1tE+gJ"></a><span class="cm-keyword">function</span> <span class="cm-variable">logEach</span>(<span class="cm-def">array</span>) {
  <span class="cm-keyword">for</span> (<span class="cm-keyword">var</span> <span class="cm-def">i</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>; <span class="cm-variable-2">i</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">array</span>.<span class="cm-property">length</span>; <span class="cm-variable-2">i</span><span class="cm-operator">++</span>)
    <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable-2">array</span>[<span class="cm-variable-2">i</span>]);
}</pre>
<p id="forEach"><a class="p_ident" id="p_q8hNTrfIYb" href="./05_higher_order.html#p_q8hNTrfIYb"></a>Но какво ако искаме да направим нещо по- различно с взетите елементи? Тъй като “направим нещо” може да бъде представено, като функция, а функциите са само стойности, ние можем да променим нашите действия, като стойност на функция.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_on8vSTDMIU" href="./05_higher_order.html#c_on8vSTDMIU"></a><span class="cm-keyword">function</span> <span class="cm-variable">forEach</span>(<span class="cm-def">array</span>, <span class="cm-def">action</span>) {
  <span class="cm-keyword">for</span> (<span class="cm-keyword">var</span> <span class="cm-def">i</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>; <span class="cm-variable-2">i</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">array</span>.<span class="cm-property">length</span>; <span class="cm-variable-2">i</span><span class="cm-operator">++</span>)
    <span class="cm-variable-2">action</span>(<span class="cm-variable-2">array</span>[<span class="cm-variable-2">i</span>]);
}

<span class="cm-variable">forEach</span>([<span class="cm-string">"Wampeter"</span>, <span class="cm-string">"Foma"</span>, <span class="cm-string">"Granfalloon"</span>], <span class="cm-variable">console</span>.<span class="cm-property">log</span>);
<span class="cm-comment">// → Wampeter</span>
<span class="cm-comment">// → Foma</span>
<span class="cm-comment">// → Granfalloon</span></pre>
<p><a class="p_ident" id="p_gLkhZ+aBcQ" href="./05_higher_order.html#p_gLkhZ+aBcQ"></a>(В някои браузъри, извикана <code>console.log</code> по този начин не работи. Можете да използвате <code>alert</code> вместо <code>console.log</code>, ако този пример не работи.)</p>
<p><a class="p_ident" id="p_TXDEyQXjy/" href="./05_higher_order.html#p_TXDEyQXjy/"></a>Често не минаваме към предварително определена функция, като <code>forEach</code>, но можем да създадем стойност на функцията на място.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_wRpVmSHeqP" href="./05_higher_order.html#c_wRpVmSHeqP"></a><span class="cm-keyword">var</span> <span class="cm-variable">numbers</span> <span class="cm-operator">=</span> [<span class="cm-number">1</span>, <span class="cm-number">2</span>, <span class="cm-number">3</span>, <span class="cm-number">4</span>, <span class="cm-number">5</span>], <span class="cm-variable">sum</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>;
<span class="cm-variable">forEach</span>(<span class="cm-variable">numbers</span>, <span class="cm-keyword">function</span>(<span class="cm-def">number</span>) {
  <span class="cm-variable">sum</span> <span class="cm-operator">+=</span> <span class="cm-variable-2">number</span>;
});
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">sum</span>);
<span class="cm-comment">// → 15</span></pre>
<p><a class="p_ident" id="p_v2REJFVWCD" href="./05_higher_order.html#p_v2REJFVWCD"></a>Това много прилича на класическия <code>for</code> цикъл, с тяло написано, като блок под него. Въпреки това, сега тялото е вътре в стойността на функцията, която е вътре в скобите на извиканата <code>forEach</code>. Ето защо скобите трябва да бъдат затворени със затварящи скоби.</p>
<p><a class="p_ident" id="p_u1F6T5TuZI" href="./05_higher_order.html#p_u1F6T5TuZI"></a>Използвайки този модел, можем да зададем име на променлива за текущия елемент (<code>number</code>), а не да се налага да го вземаме от масива ръчно. </p>
<p><a class="p_ident" id="p_w5leJJdYGK" href="./05_higher_order.html#p_w5leJJdYGK"></a>В действителност, ние не трябва да пишем на ново <code>forEach</code>. Той се предлага, като стандартен метод за масиви. В масива вече е предвидено, как действа метода <code>forEach</code>, вземайки само един задължителен аргумент: функцията ще бъде изпълнена за всеки елемент.</p>
<p><a class="p_ident" id="p_BbxEeZ0Pmw" href="./05_higher_order.html#p_BbxEeZ0Pmw"></a>За да се убедите, колко полезно е това да погледнем назад към функцията от <a href="./04_data.html#analysis">предишната глава</a>. Тя съдържа два цикъла преминаващи през масива.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_1CXbGUgiP6" href="./05_higher_order.html#c_1CXbGUgiP6"></a><span class="cm-keyword">function</span> <span class="cm-variable">gatherCorrelations</span>(<span class="cm-def">journal</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">phis</span> <span class="cm-operator">=</span> {};
  <span class="cm-keyword">for</span> (<span class="cm-keyword">var</span> <span class="cm-def">entry</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>; <span class="cm-variable-2">entry</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">journal</span>.<span class="cm-property">length</span>; <span class="cm-variable-2">entry</span><span class="cm-operator">++</span>) {
    <span class="cm-keyword">var</span> <span class="cm-def">events</span> <span class="cm-operator">=</span> <span class="cm-variable-2">journal</span>[<span class="cm-variable-2">entry</span>].<span class="cm-property">events</span>;
    <span class="cm-keyword">for</span> (<span class="cm-keyword">var</span> <span class="cm-def">i</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>; <span class="cm-variable-2">i</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">events</span>.<span class="cm-property">length</span>; <span class="cm-variable-2">i</span><span class="cm-operator">++</span>) {
      <span class="cm-keyword">var</span> <span class="cm-def">event</span> <span class="cm-operator">=</span> <span class="cm-variable-2">events</span>[<span class="cm-variable-2">i</span>];
      <span class="cm-keyword">if</span> (<span class="cm-operator">!</span>(<span class="cm-variable-2">event</span> <span class="cm-keyword">in</span> <span class="cm-variable-2">phis</span>))
        <span class="cm-variable-2">phis</span>[<span class="cm-variable-2">event</span>] <span class="cm-operator">=</span> <span class="cm-variable">phi</span>(<span class="cm-variable">tableFor</span>(<span class="cm-variable-2">event</span>, <span class="cm-variable-2">journal</span>));
    }
  }
  <span class="cm-keyword">return</span> <span class="cm-variable-2">phis</span>;
}</pre>
<p><a class="p_ident" id="p_CGf69rc/Yq" href="./05_higher_order.html#p_CGf69rc/Yq"></a>Работата с <code>forEach</code> я прави малко по-къса и малко по-чиста.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_gIY8Dk2DPY" href="./05_higher_order.html#c_gIY8Dk2DPY"></a><span class="cm-keyword">function</span> <span class="cm-variable">gatherCorrelations</span>(<span class="cm-def">journal</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">phis</span> <span class="cm-operator">=</span> {};
  <span class="cm-variable-2">journal</span>.<span class="cm-property">forEach</span>(<span class="cm-keyword">function</span>(<span class="cm-def">entry</span>) {
    <span class="cm-variable-2">entry</span>.<span class="cm-property">events</span>.<span class="cm-property">forEach</span>(<span class="cm-keyword">function</span>(<span class="cm-def">event</span>) {
      <span class="cm-keyword">if</span> (<span class="cm-operator">!</span>(<span class="cm-variable-2">event</span> <span class="cm-keyword">in</span> <span class="cm-variable-2">phis</span>))
        <span class="cm-variable-2">phis</span>[<span class="cm-variable-2">event</span>] <span class="cm-operator">=</span> <span class="cm-variable">phi</span>(<span class="cm-variable">tableFor</span>(<span class="cm-variable-2">event</span>, <span class="cm-variable-2">journal</span>));
    });
  });
  <span class="cm-keyword">return</span> <span class="cm-variable-2">phis</span>;
}</pre>
<h2><a class="h_ident" id="h_xxCc98lOBK" href="./05_higher_order.html#h_xxCc98lOBK"></a>По-високо ниво функции</h2>
<p><a class="p_ident" id="p_cao2fH68Tj" href="./05_higher_order.html#p_cao2fH68Tj"></a>Функции, които работят в други функции или ги вземат, като аргументи  или се връщат, като аргументи, се наричат по-високо ниво функции. Ако вече сте приели факта, че функциите са обикновени стойности, няма нищо особено и забележимо във факта, че съществуват такива функции. Терминът идва от математиката, където вземат разграничаването между функциите и другите стойности по-сериозно.</p>
<p><a class="p_ident" id="p_+cgNTV2i2y" href="./05_higher_order.html#p_+cgNTV2i2y"></a>По-високото ниво функции ни позволява абстрактни действия, а не само стойности. Те се прилагат в различни форми. Например, може да имате функции, които създават нови функции.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_9JAVbcWLFt" href="./05_higher_order.html#c_9JAVbcWLFt"></a><span class="cm-keyword">function</span> <span class="cm-variable">greaterThan</span>(<span class="cm-def">n</span>) {
  <span class="cm-keyword">return</span> <span class="cm-keyword">function</span>(<span class="cm-def">m</span>) { <span class="cm-keyword">return</span> <span class="cm-variable-2">m</span> <span class="cm-operator">&gt;</span> <span class="cm-variable-2">n</span>; };
}
<span class="cm-keyword">var</span> <span class="cm-variable">greaterThan10</span> <span class="cm-operator">=</span> <span class="cm-variable">greaterThan</span>(<span class="cm-number">10</span>);
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">greaterThan10</span>(<span class="cm-number">11</span>));
<span class="cm-comment">// → true</span></pre>
<p><a class="p_ident" id="p_MKDSIQ0X9D" href="./05_higher_order.html#p_MKDSIQ0X9D"></a>И може да имаме функции, които променят други функции.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_JVArXJ1Pc1" href="./05_higher_order.html#c_JVArXJ1Pc1"></a><span class="cm-keyword">function</span> <span class="cm-variable">noisy</span>(<span class="cm-def">f</span>) {
  <span class="cm-keyword">return</span> <span class="cm-keyword">function</span>(<span class="cm-def">arg</span>) {
    <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"calling with"</span>, <span class="cm-variable-2">arg</span>);
    <span class="cm-keyword">var</span> <span class="cm-def">val</span> <span class="cm-operator">=</span> <span class="cm-variable-2">f</span>(<span class="cm-variable-2">arg</span>);
    <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"called with"</span>, <span class="cm-variable-2">arg</span>, <span class="cm-string">"- got"</span>, <span class="cm-variable-2">val</span>);
    <span class="cm-keyword">return</span> <span class="cm-variable-2">val</span>;
  };
}
<span class="cm-variable">noisy</span>(<span class="cm-variable">Boolean</span>)(<span class="cm-number">0</span>);
<span class="cm-comment">// → calling with 0</span>
<span class="cm-comment">// → called with 0 - got false</span></pre>
<p><a class="p_ident" id="p_2qBy/XBHVa" href="./05_higher_order.html#p_2qBy/XBHVa"></a>Можем да пишем функции, които осигуряват нови видове контрол на потока.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_IiJsXvslVu" href="./05_higher_order.html#c_IiJsXvslVu"></a><span class="cm-keyword">function</span> <span class="cm-variable">unless</span>(<span class="cm-def">test</span>, <span class="cm-def">then</span>) {
  <span class="cm-keyword">if</span> (<span class="cm-operator">!</span><span class="cm-variable-2">test</span>) <span class="cm-variable-2">then</span>();
}
<span class="cm-keyword">function</span> <span class="cm-variable">repeat</span>(<span class="cm-def">times</span>, <span class="cm-def">body</span>) {
  <span class="cm-keyword">for</span> (<span class="cm-keyword">var</span> <span class="cm-def">i</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>; <span class="cm-variable-2">i</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">times</span>; <span class="cm-variable-2">i</span><span class="cm-operator">++</span>) <span class="cm-variable-2">body</span>(<span class="cm-variable-2">i</span>);
}

<span class="cm-variable">repeat</span>(<span class="cm-number">3</span>, <span class="cm-keyword">function</span>(<span class="cm-def">n</span>) {
  <span class="cm-variable">unless</span>(<span class="cm-variable-2">n</span> <span class="cm-operator">%</span> <span class="cm-number">2</span>, <span class="cm-keyword">function</span>() {
    <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable-2">n</span>, <span class="cm-string">"is even"</span>);
  });
});
<span class="cm-comment">// → 0 is even</span>
<span class="cm-comment">// → 2 is even</span></pre>
<p><a class="p_ident" id="p_i6rGSdWQvz" href="./05_higher_order.html#p_i6rGSdWQvz"></a>Лексикалното определяне на обхвата от правила, което обсъдихме в <a href="./03_functions.html#scoping">Глава 3</a>, работи в наша полза, когато използваме функциите по този начин. В предишния пример, променливата <code>n</code> е параметър към външната функция. Но вътрешната функция живее в средата на външната и тя може да използва <code>n</code>. Органите на такива вътрешни функции могат да получат достъп до променливите около тях. Те могат да играят роля подобна на <code>{}</code> блокове, използвани в редовни линии  и условни конструкции. Важна разлика е, че променливи декларирани вътре във вътрешните функции, не попадат в околната среда на външната функция. И това обикновено е нещо добро.</p>
<h2><a class="h_ident" id="h_7/X8BSjdvi" href="./05_higher_order.html#h_7/X8BSjdvi"></a>Подаване на аргументи</h2>
<p><a class="p_ident" id="p_IYAO9/PwTt" href="./05_higher_order.html#p_IYAO9/PwTt"></a>Функцията <code>noisy</code> определена по-рано, която обвива своя аргумент в друга функция, има доста сериозен пропуск.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_9Deoi4g6M/" href="./05_higher_order.html#c_9Deoi4g6M/"></a><span class="cm-keyword">function</span> <span class="cm-variable">noisy</span>(<span class="cm-def">f</span>) {
  <span class="cm-keyword">return</span> <span class="cm-keyword">function</span>(<span class="cm-def">arg</span>) {
    <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"calling with"</span>, <span class="cm-variable-2">arg</span>);
    <span class="cm-keyword">var</span> <span class="cm-def">val</span> <span class="cm-operator">=</span> <span class="cm-variable-2">f</span>(<span class="cm-variable-2">arg</span>);
    <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"called with"</span>, <span class="cm-variable-2">arg</span>, <span class="cm-string">"- got"</span>, <span class="cm-variable-2">val</span>);
    <span class="cm-keyword">return</span> <span class="cm-variable-2">val</span>;
  };
}</pre>
<p><a class="p_ident" id="p_xa/8T14jAc" href="./05_higher_order.html#p_xa/8T14jAc"></a>Ако <code>f</code> взема повече от един аргумент,  получава само първия. Бихме могли да добавим един куп аргументи към вътрешната функция (<code>arg1</code>,
<code>arg2</code> и т.н.) и да ги прехвърлим към <code>f</code>, но не е ясно, колко от тях ще бъдат достъпни. Това решение също би лишило <code>f</code> от част от информацията в <code>arguments.length</code>. Тъй като винаги ще взема същия брой аргументи, колкото първоначално са му били зададени.</p>
<p><a class="p_ident" id="p_d8oC4azbX1" href="./05_higher_order.html#p_d8oC4azbX1"></a>За тези видове ситуации, функциите в JavaScript имат метода <code>apply</code>. Може да го сложите в масив (или масиво-подобен обект) от аргументи и да извикате функцията с тези аргументи.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_OwePsf3FVa" href="./05_higher_order.html#c_OwePsf3FVa"></a><span class="cm-keyword">function</span> <span class="cm-variable">transparentWrapping</span>(<span class="cm-def">f</span>) {
  <span class="cm-keyword">return</span> <span class="cm-keyword">function</span>() {
    <span class="cm-keyword">return</span> <span class="cm-variable-2">f</span>.<span class="cm-property">apply</span>(<span class="cm-atom">null</span>, <span class="cm-variable-2">arguments</span>);
  };
}</pre>
<p><a class="p_ident" id="p_DzgFx1ko9R" href="./05_higher_order.html#p_DzgFx1ko9R"></a>Това е безполезна функция, но тя показва модела който ни интересува- функцията се връща преминавайки през всички подадени аргументи  и тези аргументи за <code>f</code>. Тя прави това, като взема аргументите от <code>apply</code> за собствени. Първият аргумент, който взема е <code>null</code>, с който може да се симулира метод на извикване. Ще се върнем към това в 
<a href="./06_object.html#call_method">следващата глава</a>.</p>
<h2><a class="h_ident" id="h_AxpOdvCznQ" href="./05_higher_order.html#h_AxpOdvCznQ"></a>JSON</h2>
<p><a class="p_ident" id="p_A2VaNOTR7R" href="./05_higher_order.html#p_A2VaNOTR7R"></a>По-високото ниво функции, които се прилагат за елементите на масив, са широко използвани в JavaScript. Метода <code>forEach</code> е най-примитивната такава функция. Има редица други варианти на методи за масиви. За да се запознаем с тях, нека си поиграем с друг набор от данни.</p>
<p><a class="p_ident" id="p_U8cxfiInkI" href="./05_higher_order.html#p_U8cxfiInkI"></a>Преди няколко години, попаднах на много архиви събрани на едно място в книга посветена на историята на моето семейство (Haverbeke—meaning Oatbrook). Отворих я с надеждата да намеря рицари, пирати и алхимици...., но книгата се оказа пълна най-вече с фламандски фермери. За забавление, извлякох данните на моите преки предци и ги поставих в електронен вид.</p>
<p><a class="p_ident" id="p_kyOqr/Ovkw" href="./05_higher_order.html#p_kyOqr/Ovkw"></a>Файлът изглеждаше нещо такова:</p>
<pre data-language="application/json" class="snippet cm-s-default"><a class="c_ident" id="c_ndJ1dhsRpC" href="./05_higher_order.html#c_ndJ1dhsRpC"></a>[
  {<span class="cm-string cm-property">"name"</span>: <span class="cm-string">"Emma de Milliano"</span>, <span class="cm-string cm-property">"sex"</span>: <span class="cm-string">"f"</span>,
   <span class="cm-string cm-property">"born"</span>: <span class="cm-number">1876</span>, <span class="cm-string cm-property">"died"</span>: <span class="cm-number">1956</span>,
   <span class="cm-string cm-property">"father"</span>: <span class="cm-string">"Petrus de Milliano"</span>,
   <span class="cm-string cm-property">"mother"</span>: <span class="cm-string">"Sophia van Damme"</span>},
  {<span class="cm-string cm-property">"name"</span>: <span class="cm-string">"Carolus Haverbeke"</span>, <span class="cm-string cm-property">"sex"</span>: <span class="cm-string">"m"</span>,
   <span class="cm-string cm-property">"born"</span>: <span class="cm-number">1832</span>, <span class="cm-string cm-property">"died"</span>: <span class="cm-number">1905</span>,
   <span class="cm-string cm-property">"father"</span>: <span class="cm-string">"Carel Haverbeke"</span>,
   <span class="cm-string cm-property">"mother"</span>: <span class="cm-string">"Maria van Brussel"</span>},
  <span class="cm-variable">…</span> <span class="cm-variable">and</span> <span class="cm-variable">so</span> <span class="cm-variable">on</span>
]</pre>
<p><a class="p_ident" id="p_TtSCtpw/XN" href="./05_higher_order.html#p_TtSCtpw/XN"></a>Този формат се нарича JSON (произнася се”Джейсън”), което е съкращение от JavaScript Object Notation. Той се използва широко, както за съхранение на данни, така и за комуникационен формат в Интернет.</p>
<p><a class="p_ident" id="p_LkHACkXND1" href="./05_higher_order.html#p_LkHACkXND1"></a>JSON подобно на JavaScript е начин за писане на масиви и обекти, но с някои ограничения. Всички имена на свойства трябва да бъдат поставени в кавички, позволени са само прости изрази - данни. Не са позволени: извиквания на функции, променливи или нещо, което включва действително изчисление. Коментарите също не са позволени в JSON.</p>
<p><a class="p_ident" id="p_1IU60Zh2Af" href="./05_higher_order.html#p_1IU60Zh2Af"></a>JavaScript ни дава функциите <code>JSON.stringify</code> и <code>JSON.parse</code>, които преобразуват данни от и към този формат. Първата взема стойност от JavaScript и връща кодиран JSON <em>string</em> формат. Втората взема този <em>string</em> и го конвертира в кодирана стойност.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_mzHhvmUWat" href="./05_higher_order.html#c_mzHhvmUWat"></a><span class="cm-keyword">var</span> <span class="cm-variable">string</span> <span class="cm-operator">=</span> <span class="cm-variable">JSON</span>.<span class="cm-property">stringify</span>({<span class="cm-property">name</span>: <span class="cm-string">"X"</span>, <span class="cm-property">born</span>: <span class="cm-number">1980</span>});
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">string</span>);
<span class="cm-comment">// → {"name":"X","born":1980}</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">JSON</span>.<span class="cm-property">parse</span>(<span class="cm-variable">string</span>).<span class="cm-property">born</span>);
<span class="cm-comment">// → 1980</span></pre>
<p><a class="p_ident" id="p_NDrk0od6QR" href="./05_higher_order.html#p_NDrk0od6QR"></a>Променливата <code>ANCESTRY_FILE</code> е налична в пясъчника на тази глава и във <a href="./code/ancestry.js">файл за изтегляне</a> от уеб-сайта, който съдържа моя JSON файл, като <em>string</em>. Нека го декодираме и да видим, колко много хора съдържа.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_iIU5d+0x1R" href="./05_higher_order.html#c_iIU5d+0x1R"></a><span class="cm-keyword">var</span> <span class="cm-variable">ancestry</span> <span class="cm-operator">=</span> <span class="cm-variable">JSON</span>.<span class="cm-property">parse</span>(<span class="cm-variable">ANCESTRY_FILE</span>);
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">ancestry</span>.<span class="cm-property">length</span>);
<span class="cm-comment">// → 39</span></pre>
<h2><a class="h_ident" id="h_1BJbwiI0gI" href="./05_higher_order.html#h_1BJbwiI0gI"></a>Филтриране  на  масив</h2>
<p><a class="p_ident" id="p_Vpf83lHLbL" href="./05_higher_order.html#p_Vpf83lHLbL"></a>Следната функция, може да бъде полезна за да разберем, кои са хората, които са били млади през 1924г.,в масива от данни на моите предци. Тя филтрира елементите, които не минават теста в масива.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_VcGTxSYgrf" href="./05_higher_order.html#c_VcGTxSYgrf"></a><span class="cm-keyword">function</span> <span class="cm-variable">filter</span>(<span class="cm-def">array</span>, <span class="cm-def">test</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">passed</span> <span class="cm-operator">=</span> [];
  <span class="cm-keyword">for</span> (<span class="cm-keyword">var</span> <span class="cm-def">i</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>; <span class="cm-variable-2">i</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">array</span>.<span class="cm-property">length</span>; <span class="cm-variable-2">i</span><span class="cm-operator">++</span>) {
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">test</span>(<span class="cm-variable-2">array</span>[<span class="cm-variable-2">i</span>]))
      <span class="cm-variable-2">passed</span>.<span class="cm-property">push</span>(<span class="cm-variable-2">array</span>[<span class="cm-variable-2">i</span>]);
  }
  <span class="cm-keyword">return</span> <span class="cm-variable-2">passed</span>;
}

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">filter</span>(<span class="cm-variable">ancestry</span>, <span class="cm-keyword">function</span>(<span class="cm-def">person</span>) {
  <span class="cm-keyword">return</span> <span class="cm-variable-2">person</span>.<span class="cm-property">born</span> <span class="cm-operator">&gt;</span> <span class="cm-number">1900</span> <span class="cm-operator">&amp;&amp;</span> <span class="cm-variable-2">person</span>.<span class="cm-property">born</span> <span class="cm-operator">&lt;</span> <span class="cm-number">1925</span>;
}));
<span class="cm-comment">// → [{name: "Philibert Haverbeke", …}, …]</span></pre>
<p><a class="p_ident" id="p_F1sdIqvMdQ" href="./05_higher_order.html#p_F1sdIqvMdQ"></a>Функцията използва аргумент с име <code>test</code>, като стойност на функция за да попълни “разминаването” в изчислението. <code>Test</code> функцията се извиква за всеки елемент и върнатата и стойност определя дали даден елемент е включен във върнатия масив.</p>
<p><a class="p_ident" id="p_l78Pj0p/pD" href="./05_higher_order.html#p_l78Pj0p/pD"></a>Трима души са били млади и живи през 1924г:дядо ми, баба ми и пра-леля ми.</p>
<p><a class="p_ident" id="p_vcnUQxte/7" href="./05_higher_order.html#p_vcnUQxte/7"></a>Забележете как функцията <code>filter</code>, вместо да изтрива елементи от съществуващия масив, изгражда нов масив само с елементите, които преминават теста. Тази функция е чиста. Тя не променя масива, който и е даден.</p>
<p><a class="p_ident" id="p_OduOippCCU" href="./05_higher_order.html#p_OduOippCCU"></a>Както <code>forEach</code>, така и <code>filter</code> е стандартен метод за масиви. Примерът дефинира функция само за да покаже това, което тя прави вътрешно. От сега на татък, ще я използваме, както това:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_V5IGmt9uTK" href="./05_higher_order.html#c_V5IGmt9uTK"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">ancestry</span>.<span class="cm-property">filter</span>(<span class="cm-keyword">function</span>(<span class="cm-def">person</span>) {
  <span class="cm-keyword">return</span> <span class="cm-variable-2">person</span>.<span class="cm-property">father</span> <span class="cm-operator">==</span> <span class="cm-string">"Carel Haverbeke"</span>;
}));
<span class="cm-comment">// → [{name: "Carolus Haverbeke", …}]</span></pre>
<h2><a class="h_ident" id="h_lJEtQ+qjXz" href="./05_higher_order.html#h_lJEtQ+qjXz"></a>Трансформиране  с  карта (map)</h2>
<p><a class="p_ident" id="p_iZsa8JAje9" href="./05_higher_order.html#p_iZsa8JAje9"></a>Имаме масив от обекти представляващ хора, направени чрез филтриране на масива <code>ancestry</code> по някакъв начин. Но ние искаме масив от имена, който е по-лесен за четене.</p>
<p><a class="p_ident" id="p_/HoP3C1P28" href="./05_higher_order.html#p_/HoP3C1P28"></a>Метода <code>map</code> трансформира масив, чрез прилагане на функция върху всички елементи и изгражда нов масив от върнатите стойности. Новият масив има същата дължина, като входящия масив, но съдържанието му е “мапнато” към новата форма на функцията.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_Oc5rRWigBO" href="./05_higher_order.html#c_Oc5rRWigBO"></a><span class="cm-keyword">function</span> <span class="cm-variable">map</span>(<span class="cm-def">array</span>, <span class="cm-def">transform</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">mapped</span> <span class="cm-operator">=</span> [];
  <span class="cm-keyword">for</span> (<span class="cm-keyword">var</span> <span class="cm-def">i</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>; <span class="cm-variable-2">i</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">array</span>.<span class="cm-property">length</span>; <span class="cm-variable-2">i</span><span class="cm-operator">++</span>)
    <span class="cm-variable-2">mapped</span>.<span class="cm-property">push</span>(<span class="cm-variable-2">transform</span>(<span class="cm-variable-2">array</span>[<span class="cm-variable-2">i</span>]));
  <span class="cm-keyword">return</span> <span class="cm-variable-2">mapped</span>;
}

<span class="cm-keyword">var</span> <span class="cm-variable">overNinety</span> <span class="cm-operator">=</span> <span class="cm-variable">ancestry</span>.<span class="cm-property">filter</span>(<span class="cm-keyword">function</span>(<span class="cm-def">person</span>) {
  <span class="cm-keyword">return</span> <span class="cm-variable-2">person</span>.<span class="cm-property">died</span> <span class="cm-operator">-</span> <span class="cm-variable-2">person</span>.<span class="cm-property">born</span> <span class="cm-operator">&gt;</span> <span class="cm-number">90</span>;
});
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">map</span>(<span class="cm-variable">overNinety</span>, <span class="cm-keyword">function</span>(<span class="cm-def">person</span>) {
  <span class="cm-keyword">return</span> <span class="cm-variable-2">person</span>.<span class="cm-property">name</span>;
}));
<span class="cm-comment">// → ["Clara Aernoudts", "Emile Haverbeke",</span>
<span class="cm-comment">//    "Maria Haverbeke"]</span></pre>
<p><a class="p_ident" id="p_Jd3axE7OGU" href="./05_higher_order.html#p_Jd3axE7OGU"></a>Интересно е, че хората, които са живели най-малко до 90г. са същите трима души, които видяхме преди: хората, които са били млади през 1920г., което е най-близкото поколение в моя набор от данни. Предполагам, че медицината е извървяла дълъг път.</p>
<p><a class="p_ident" id="p_kz8fxQbtBm" href="./05_higher_order.html#p_kz8fxQbtBm"></a>Подобно на <code>forEach</code> : <code>filter</code> и <code>map</code> също са стандартни методи за масиви.</p>
<h2><a class="h_ident" id="h_fx3e34kT/k" href="./05_higher_order.html#h_fx3e34kT/k"></a>Обобщаване  с  намаляване</h2>
<p><a class="p_ident" id="p_jc3nW2aN35" href="./05_higher_order.html#p_jc3nW2aN35"></a>Друг често срещан модел за изчисляване на масиви е изчисляване на една стойност от тях. Нашия повтарящ се пример със сумиране на набор от цифри е пример за това. Друг пример ще бъде намирането на лице с най-ранната година на раждане в масива от данни.</p>
<p><a class="p_ident" id="p_AR3Kp1oBC4" href="./05_higher_order.html#p_AR3Kp1oBC4"></a>По-високото ниво на операцията, която представлява този модел се нарича <em>reduce</em> намаляване (или понякога <em>fold</em>). Можете да мислите за нея, като сгъване на масива в един елемент в даден момент. 
Когато сумираме номерата, ще започнем с числото нула за всеки елемент и комбинираме текущата сума с добавяне на две.</p>
<p><a class="p_ident" id="p_2+GsHstzgE" href="./05_higher_order.html#p_2+GsHstzgE"></a>Параметрите на функцията <code>reduce</code> са освен масива, комбинираната сума и старт стойност. Тази функция е малко по-малка от обикновените <code>filter</code> и <code>map</code>, така че и обърнете особено внимание.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_0Tuk2O6cyM" href="./05_higher_order.html#c_0Tuk2O6cyM"></a><span class="cm-keyword">function</span> <span class="cm-variable">reduce</span>(<span class="cm-def">array</span>, <span class="cm-def">combine</span>, <span class="cm-def">start</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">current</span> <span class="cm-operator">=</span> <span class="cm-variable-2">start</span>;
  <span class="cm-keyword">for</span> (<span class="cm-keyword">var</span> <span class="cm-def">i</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>; <span class="cm-variable-2">i</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">array</span>.<span class="cm-property">length</span>; <span class="cm-variable-2">i</span><span class="cm-operator">++</span>)
    <span class="cm-variable-2">current</span> <span class="cm-operator">=</span> <span class="cm-variable-2">combine</span>(<span class="cm-variable-2">current</span>, <span class="cm-variable-2">array</span>[<span class="cm-variable-2">i</span>]);
  <span class="cm-keyword">return</span> <span class="cm-variable-2">current</span>;
}

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">reduce</span>([<span class="cm-number">1</span>, <span class="cm-number">2</span>, <span class="cm-number">3</span>, <span class="cm-number">4</span>], <span class="cm-keyword">function</span>(<span class="cm-def">a</span>, <span class="cm-def">b</span>) {
  <span class="cm-keyword">return</span> <span class="cm-variable-2">a</span> <span class="cm-operator">+</span> <span class="cm-variable-2">b</span>;
}, <span class="cm-number">0</span>));
<span class="cm-comment">// → 10</span></pre>
<p><a class="p_ident" id="p_r9cFmJJTar" href="./05_higher_order.html#p_r9cFmJJTar"></a>Стандартния метод за масиви <code>reduce</code>, който разбира се отговаря на тази функция, има допълнително удобство. Ако вашият масив съдържа поне един елемент, ви е позволено да поставите аргумента <code>start</code> за начало. Методът ще вземе първият елемент на масива, като начална стойност и ще започне намаляване на втория елемент.</p>
<p><a class="p_ident" id="p_I1pmLx5OiJ" href="./05_higher_order.html#p_I1pmLx5OiJ"></a>Като използваме <code>reduce</code> за да намерим най-древния известен мой предшественик, можем да напишем нещо такова:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_yFx+CUT9gj" href="./05_higher_order.html#c_yFx+CUT9gj"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">ancestry</span>.<span class="cm-property">reduce</span>(<span class="cm-keyword">function</span>(<span class="cm-def">min</span>, <span class="cm-def">cur</span>) {
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">cur</span>.<span class="cm-property">born</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">min</span>.<span class="cm-property">born</span>) <span class="cm-keyword">return</span> <span class="cm-variable-2">cur</span>;
  <span class="cm-keyword">else</span> <span class="cm-keyword">return</span> <span class="cm-variable-2">min</span>;
}));
<span class="cm-comment">// → {name: "Pauwels van Haverbeke", born: 1535, …}</span></pre>
<h2><a class="h_ident" id="h_+NeFt8aXxf" href="./05_higher_order.html#h_+NeFt8aXxf"></a>Composability</h2>
<p><a class="p_ident" id="p_UHvCjnmGjM" href="./05_higher_order.html#p_UHvCjnmGjM"></a>Помислете как може да се напише предишния пример( намиране на лице с най-ранната година на раждане), без по-високо ниво на функции. Не че кодът е много зле.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_ZzCa/ILXHh" href="./05_higher_order.html#c_ZzCa/ILXHh"></a><span class="cm-keyword">var</span> <span class="cm-variable">min</span> <span class="cm-operator">=</span> <span class="cm-variable">ancestry</span>[<span class="cm-number">0</span>];
<span class="cm-keyword">for</span> (<span class="cm-keyword">var</span> <span class="cm-variable">i</span> <span class="cm-operator">=</span> <span class="cm-number">1</span>; <span class="cm-variable">i</span> <span class="cm-operator">&lt;</span> <span class="cm-variable">ancestry</span>.<span class="cm-property">length</span>; <span class="cm-variable">i</span><span class="cm-operator">++</span>) {
  <span class="cm-keyword">var</span> <span class="cm-variable">cur</span> <span class="cm-operator">=</span> <span class="cm-variable">ancestry</span>[<span class="cm-variable">i</span>];
  <span class="cm-keyword">if</span> (<span class="cm-variable">cur</span>.<span class="cm-property">born</span> <span class="cm-operator">&lt;</span> <span class="cm-variable">min</span>.<span class="cm-property">born</span>)
    <span class="cm-variable">min</span> <span class="cm-operator">=</span> <span class="cm-variable">cur</span>;
}
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">min</span>);
<span class="cm-comment">// → {name: "Pauwels van Haverbeke", born: 1535, …}</span></pre>
<p><a class="p_ident" id="p_EbeznYJOvD" href="./05_higher_order.html#p_EbeznYJOvD"></a>Има  няколко променливи и програмата е с две линии повече, но още е доста лесно да се разбере.</p>
<p id="average_function"><a class="p_ident" id="p_a0FspsuDHF" href="./05_higher_order.html#p_a0FspsuDHF"></a>По-високото ниво функции започват да сияят, когато създаваме такава функция. Като пример, нека напишем код, който намира средната възраст на мъжете и жените в масива от данни.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_uqgWfWbd7m" href="./05_higher_order.html#c_uqgWfWbd7m"></a><span class="cm-keyword">function</span> <span class="cm-variable">average</span>(<span class="cm-def">array</span>) {
  <span class="cm-keyword">function</span> <span class="cm-def">plus</span>(<span class="cm-def">a</span>, <span class="cm-def">b</span>) { <span class="cm-keyword">return</span> <span class="cm-variable-2">a</span> <span class="cm-operator">+</span> <span class="cm-variable-2">b</span>; }
  <span class="cm-keyword">return</span> <span class="cm-variable-2">array</span>.<span class="cm-property">reduce</span>(<span class="cm-variable-2">plus</span>) <span class="cm-operator">/</span> <span class="cm-variable-2">array</span>.<span class="cm-property">length</span>;
}
<span class="cm-keyword">function</span> <span class="cm-variable">age</span>(<span class="cm-def">p</span>) { <span class="cm-keyword">return</span> <span class="cm-variable-2">p</span>.<span class="cm-property">died</span> <span class="cm-operator">-</span> <span class="cm-variable-2">p</span>.<span class="cm-property">born</span>; }
<span class="cm-keyword">function</span> <span class="cm-variable">male</span>(<span class="cm-def">p</span>) { <span class="cm-keyword">return</span> <span class="cm-variable-2">p</span>.<span class="cm-property">sex</span> <span class="cm-operator">==</span> <span class="cm-string">"m"</span>; }
<span class="cm-keyword">function</span> <span class="cm-variable">female</span>(<span class="cm-def">p</span>) { <span class="cm-keyword">return</span> <span class="cm-variable-2">p</span>.<span class="cm-property">sex</span> <span class="cm-operator">==</span> <span class="cm-string">"f"</span>; }

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">average</span>(<span class="cm-variable">ancestry</span>.<span class="cm-property">filter</span>(<span class="cm-variable">male</span>).<span class="cm-property">map</span>(<span class="cm-variable">age</span>)));
<span class="cm-comment">// → 61.67</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">average</span>(<span class="cm-variable">ancestry</span>.<span class="cm-property">filter</span>(<span class="cm-variable">female</span>).<span class="cm-property">map</span>(<span class="cm-variable">age</span>)));
<span class="cm-comment">// → 54.56</span></pre>
<p><a class="p_ident" id="p_Tnj4SDSgBt" href="./05_higher_order.html#p_Tnj4SDSgBt"></a>(Това е малко глупаво, че трябва да дефинираме <code>plus</code>, като функция, но операторите в JavaScript , за разлика от функциите, не са стойности, така че не можем да ги прехвърлим, като аргументи.)</p>
<p><a class="p_ident" id="p_vIaMNOYUL0" href="./05_higher_order.html#p_vIaMNOYUL0"></a>Вместо да заплетем логиката в един голям цикъл, съставяме спретнати концепции на понятията, които ни интересуват - определящ пол, изчислена възраст и средно-аритметични номера. Можем да ги приложим един по един, за да получим резултата, който търсим.</p>
<p><a class="p_ident" id="p_ZOp8f8zApw" href="./05_higher_order.html#p_ZOp8f8zApw"></a>Това е страхотно за написване на нов кодекс. За съжаление, тази яснота има цена.</p>
<h2><a class="h_ident" id="h_KTy9HpX3R4" href="./05_higher_order.html#h_KTy9HpX3R4"></a>Разходите</h2>
<p><a class="p_ident" id="p_ROxex88LkV" href="./05_higher_order.html#p_ROxex88LkV"></a>В щастливата земя на елегантния код и красивите дъги, живее чудовище наречено <em>неефективност</em>.</p>
<p><a class="p_ident" id="p_KZv3u+lncm" href="./05_higher_order.html#p_KZv3u+lncm"></a>Програма, която обработва масив, най-общо казано, е последователност от стъпки, които разделят масива, правят нещо и създават нов масив. Но изграждането на всички тези междинни масиви е малко скъпо.</p>
<p><a class="p_ident" id="p_fwEhp/GEHu" href="./05_higher_order.html#p_fwEhp/GEHu"></a>По същия начин, преминавайки с функцията <code>forEach</code> и оставяйки този метод да се справи с итерацията на масива е удобно и лесно за четене. Но извикванията на функциите в JavaScript са скъпи в сравнение с прости цикли.</p>
<p><a class="p_ident" id="p_QCCz0cq1ti" href="./05_higher_order.html#p_QCCz0cq1ti"></a>И така нататък, има много техники, които помагат за подобряване на яснотата на програмата. Абстракциите добавят слоеве и концепции между грубите неща, които компютъра прави и по този начин предизвикват машината да свърши повече работа. Това не е железен закон - там са езиците за програмиране, които имат по-добра подкрепа за изграждане на абстракции, без добавяне на неефективност, и дори в JavaScript, опитен програмист може да намери начини да пише абстрактно код, който е по-бърз. Но това е проблем, който идва по нататък.</p>
<p><a class="p_ident" id="p_8YtdVmu3Oc" href="./05_higher_order.html#p_8YtdVmu3Oc"></a>За щастие повечето компютри са безумно бързи. Ако обработвате скромен набор от данни или правите нещо, което трябва да се случи веднага(да речем, всеки път, когато потребителя кликне на бутон), тогава няма значение дали си написал решение, което отнема половин милисекунда или супер - оптимизирано решение, което отнема една десета от секундата.</p>
<p><a class="p_ident" id="p_s9R2GjExxl" href="./05_higher_order.html#p_s9R2GjExxl"></a>Полезно е грубо да следите, колко често парче от вашата програма се пуска. Ако имате един цикъл вътре в друг цикъл(или директно, чрез външния цикъл извиквате функция, която завършва работата на вътрешния цикъл), кодът вътре във вътрешния цикъл ще приключи с <em>N</em>×<em>M</em> пъти, където <em>N</em> е броят пъти, които външният цикъл се повтаря, а <em>M</em> е броят пъти, които вътрешният цикъл се повтаря в рамките на всяка итерация на външния цикъл. Ако този вътрешен цикъл съдържа друг цикъл, който прави P завъртания, тялото му ще се пуска <em>M</em>×<em>N</em>×<em>P</em> пъти и т. н. Това може да бъде в големи количества и когато дадена програма е бавна, често проблемът може да бъде проследен до само една малка част от кода, който стои вътре във вътрешния цикъл.</p>
<h2><a class="h_ident" id="h_XnMZS4zMW6" href="./05_higher_order.html#h_XnMZS4zMW6"></a>Пра-пра-пра-пра...</h2>
<p><a class="p_ident" id="p_Typ91CWfYn" href="./05_higher_order.html#p_Typ91CWfYn"></a>Дядо ми, Philibert Haverbeke, е включен в базата данни. Като се започне с него, мога да проследя родословието му и да разбера дали най-древния човек в данните - Pauwels van Haverbeke, е моя прародител. И ако е той, бих искал да знам колко ДНК теоретично споделям с него.</p>
<p><a class="p_ident" id="p_pwQeT587/V" href="./05_higher_order.html#p_pwQeT587/V"></a>За да мога да стигна до името на действителния обект, който представлява този човек, първо трябва да изградя един обект, който свързва хората.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_/p8Gq6iabK" href="./05_higher_order.html#c_/p8Gq6iabK"></a><span class="cm-keyword">var</span> <span class="cm-variable">byName</span> <span class="cm-operator">=</span> {};
<span class="cm-variable">ancestry</span>.<span class="cm-property">forEach</span>(<span class="cm-keyword">function</span>(<span class="cm-def">person</span>) {
  <span class="cm-variable">byName</span>[<span class="cm-variable-2">person</span>.<span class="cm-property">name</span>] <span class="cm-operator">=</span> <span class="cm-variable-2">person</span>;
});

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">byName</span>[<span class="cm-string">"Philibert Haverbeke"</span>]);
<span class="cm-comment">// → {name: "Philibert Haverbeke", …}</span></pre>
<p><a class="p_ident" id="p_Yko1+UXeBG" href="./05_higher_order.html#p_Yko1+UXeBG"></a>Сега проблемът не е прост, трябва да се следват бащите, които трябва да преброим за да стигнем до Pauwels. Има няколко случая в родословното дърво, където хората се женели за вторите си братовчеди. Това е причина клоните на родословното дърво да се съединяват на няколко места, което означава, че аз споделям повече от 1/2<sup><em>G</em></sup> гените на този човек, като броя <em>G</em> е за поколенията между Pauwels и мен. Тази формула идва от идеята, че всяко поколение разделя генетичния фонд на две.</p>
<p><a class="p_ident" id="p_qznNjPi9uB" href="./05_higher_order.html#p_qznNjPi9uB"></a>Разумен начин да мислим за този проблем е да гледаме на него, като аналогичен <code>reduce</code>, който свива масива до една стойност, чрез многократно съкращаване на стойности от ляво на дясно. В този случай, ние също искаме да съкратим нашата структура от данни до една стойност по начин, който следва семейните линии. Формата на данните е на родословно дърво , а не плосък списък.</p>
<p><a class="p_ident" id="p_1De08sAcOD" href="./05_higher_order.html#p_1De08sAcOD"></a>Начинът, по който искаме да намалим тази форма е с изчисляване на стойност за даден човек, чрез комбиниране на стойности от неговите предци. Това може да стане рекурсивно: ако ние сме заинтересованото лице <em>A</em>, то трябва да изчислим стойностите на родителите на <em>A</em>, което от своя страна трябва да изчисли стойностите на техните родители-“баба и дядо” и т.н. По принцип, това изисква да прегледаме един безкраен брой от хора, но тъй като нашия набор от данни е ограничен, ще трябва да спрем някъде. Ще определим стойност по подразбиране, за да даде намаляване на нашата функция, тъй като ще се използва за хора, които не са в данните. В нашия случай, тази стойност е просто нула, ако се предположи, че хората, които не са в списъка, то те не споделят ДНК с прародителя, който търсим.</p>
<p><a class="p_ident" id="p_B0sEhVOeSP" href="./05_higher_order.html#p_B0sEhVOeSP"></a>При един човек функцията, която комбинира стойностите от двама родители на дадено лице и стойност по подразбиране <code>reduceAncestors</code> съкращава стойност от родословното дърво.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_FR1ZA75xXV" href="./05_higher_order.html#c_FR1ZA75xXV"></a><span class="cm-keyword">function</span> <span class="cm-variable">reduceAncestors</span>(<span class="cm-def">person</span>, <span class="cm-def">f</span>, <span class="cm-def">defaultValue</span>) {
  <span class="cm-keyword">function</span> <span class="cm-def">valueFor</span>(<span class="cm-def">person</span>) {
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">person</span> <span class="cm-operator">==</span> <span class="cm-atom">null</span>)
      <span class="cm-keyword">return</span> <span class="cm-variable-2">defaultValue</span>;
    <span class="cm-keyword">else</span>
      <span class="cm-keyword">return</span> <span class="cm-variable-2">f</span>(<span class="cm-variable-2">person</span>, <span class="cm-variable-2">valueFor</span>(<span class="cm-variable">byName</span>[<span class="cm-variable-2">person</span>.<span class="cm-property">mother</span>]),
                       <span class="cm-variable-2">valueFor</span>(<span class="cm-variable">byName</span>[<span class="cm-variable-2">person</span>.<span class="cm-property">father</span>]));
  }
  <span class="cm-keyword">return</span> <span class="cm-variable-2">valueFor</span>(<span class="cm-variable-2">person</span>);
}</pre>
<p><a class="p_ident" id="p_HK0Nr6MiCM" href="./05_higher_order.html#p_HK0Nr6MiCM"></a>Вътрешната функция (<code>valueFor</code>) взема един човек за аргумент. Чрез магията на рекурсията, тя просто извиква в себе си майката и бащата на този човек. Резултатите, заедно с лицето на самия обект, се предават на <code>f</code>, който връща действителната стойност на този човек.</p>
<p><a class="p_ident" id="p_2Q4JEt3Fiv" href="./05_higher_order.html#p_2Q4JEt3Fiv"></a>След това можем да използваме това за да изчислим количеството на ДНК на дядо ми споделено с Pauwels van Haverbeke разделено на четири..</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_DKCt/KZuIB" href="./05_higher_order.html#c_DKCt/KZuIB"></a><span class="cm-keyword">function</span> <span class="cm-variable">sharedDNA</span>(<span class="cm-def">person</span>, <span class="cm-def">fromMother</span>, <span class="cm-def">fromFather</span>) {
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">person</span>.<span class="cm-property">name</span> <span class="cm-operator">==</span> <span class="cm-string">"Pauwels van Haverbeke"</span>)
    <span class="cm-keyword">return</span> <span class="cm-number">1</span>;
  <span class="cm-keyword">else</span>
    <span class="cm-keyword">return</span> (<span class="cm-variable-2">fromMother</span> <span class="cm-operator">+</span> <span class="cm-variable-2">fromFather</span>) <span class="cm-operator">/</span> <span class="cm-number">2</span>;
}
<span class="cm-keyword">var</span> <span class="cm-variable">ph</span> <span class="cm-operator">=</span> <span class="cm-variable">byName</span>[<span class="cm-string">"Philibert Haverbeke"</span>];
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">reduceAncestors</span>(<span class="cm-variable">ph</span>, <span class="cm-variable">sharedDNA</span>, <span class="cm-number">0</span>) <span class="cm-operator">/</span> <span class="cm-number">4</span>);
<span class="cm-comment">// → 0.00049</span></pre>
<p><a class="p_ident" id="p_+kx1i84Abe" href="./05_higher_order.html#p_+kx1i84Abe"></a>Лицето Pauwels van Haverbeke очевидно има 100% от ДНК-то с Pauwels van Haverbeke( ако не съществуват хора , които да споделят същото име в масива от данни) функцията връща 1 за него. Всички други  хора споделят средна стойност от сумите, които техните родители споделят.</p>
<p><a class="p_ident" id="p_sxFDHiagLr" href="./05_higher_order.html#p_sxFDHiagLr"></a>Така че, статистически погледнато аз споделям около 0.05% от моето ДНК с този човек от 16-ти век. Трябва да се отбележи, че това е само статистическо приближение, а не точен резултат. Това е по-скоро малък брой в предвид  колко генетичен материал носим( около 3 милиарда база двойки), но може би е някакъв аспект, който приближава произхода ми с Pauwels.</p>
<p><a class="p_ident" id="p_9W8GK5HRM6" href="./05_higher_order.html#p_9W8GK5HRM6"></a>Този номер може да се изчисли и без да разчитаме на <code>reduceAncestors</code>. Но разделяне на общото количество(от сгъстеното родословно дърво) на конкретния случай( изчислено споделено ДНК) може да подобри яснотата на кода и ни позволява да използваме повторно абстрактната част от програмата за други случаи. Например, следният код установява процентът на известни предци на човек, който са живели 70г.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_8JFA4YEKi4" href="./05_higher_order.html#c_8JFA4YEKi4"></a><span class="cm-keyword">function</span> <span class="cm-variable">countAncestors</span>(<span class="cm-def">person</span>, <span class="cm-def">test</span>) {
  <span class="cm-keyword">function</span> <span class="cm-def">combine</span>(<span class="cm-def">current</span>, <span class="cm-def">fromMother</span>, <span class="cm-def">fromFather</span>) {
    <span class="cm-keyword">var</span> <span class="cm-def">thisOneCounts</span> <span class="cm-operator">=</span> <span class="cm-variable-2">current</span> <span class="cm-operator">!=</span> <span class="cm-variable-2">person</span> <span class="cm-operator">&amp;&amp;</span> <span class="cm-variable-2">test</span>(<span class="cm-variable-2">current</span>);
    <span class="cm-keyword">return</span> <span class="cm-variable-2">fromMother</span> <span class="cm-operator">+</span> <span class="cm-variable-2">fromFather</span> <span class="cm-operator">+</span> (<span class="cm-variable-2">thisOneCounts</span> <span class="cm-operator">?</span> <span class="cm-number">1</span> : <span class="cm-number">0</span>);
  }
  <span class="cm-keyword">return</span> <span class="cm-variable">reduceAncestors</span>(<span class="cm-variable-2">person</span>, <span class="cm-variable-2">combine</span>, <span class="cm-number">0</span>);
}
<span class="cm-keyword">function</span> <span class="cm-variable">longLivingPercentage</span>(<span class="cm-def">person</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">all</span> <span class="cm-operator">=</span> <span class="cm-variable">countAncestors</span>(<span class="cm-variable-2">person</span>, <span class="cm-keyword">function</span>(<span class="cm-def">person</span>) {
    <span class="cm-keyword">return</span> <span class="cm-atom">true</span>;
  });
  <span class="cm-keyword">var</span> <span class="cm-def">longLiving</span> <span class="cm-operator">=</span> <span class="cm-variable">countAncestors</span>(<span class="cm-variable-2">person</span>, <span class="cm-keyword">function</span>(<span class="cm-def">person</span>) {
    <span class="cm-keyword">return</span> (<span class="cm-variable-2">person</span>.<span class="cm-property">died</span> <span class="cm-operator">-</span> <span class="cm-variable-2">person</span>.<span class="cm-property">born</span>) <span class="cm-operator">&gt;=</span> <span class="cm-number">70</span>;
  });
  <span class="cm-keyword">return</span> <span class="cm-variable-2">longLiving</span> <span class="cm-operator">/</span> <span class="cm-variable-2">all</span>;
}
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">longLivingPercentage</span>(<span class="cm-variable">byName</span>[<span class="cm-string">"Emile Haverbeke"</span>]));
<span class="cm-comment">// → 0.129</span></pre>
<p><a class="p_ident" id="p_yX3KPrQkep" href="./05_higher_order.html#p_yX3KPrQkep"></a>Такива номера не трябва да се вземат прекалено на сериозно, в предвид факта, че нашият набор от данни съдържа доста произволно събиране на хора. Но кода илюстрира факта, че <code>reduceAncestors</code> ни дава полезна част от лексиката за работа с данни - структура от дърво на семейство.</p>
<h2><a class="h_ident" id="h_fwBD5oTMLl" href="./05_higher_order.html#h_fwBD5oTMLl"></a>Свързване</h2>
<p><a class="p_ident" id="p_JR92h9ZvcR" href="./05_higher_order.html#p_JR92h9ZvcR"></a>Метода <code>bind</code>, който имат всички функции, създава нова функция, която ще извика оригиналната функция, но с някои определени вече аргументи.</p>
<p><a class="p_ident" id="p_RpFvD2j6a4" href="./05_higher_order.html#p_RpFvD2j6a4"></a>Следният код показва пример на <code>bind</code> в употреба. Той дефинира функция <code>isInSet</code>, която ни казва дали даден човек е в наборa от strings. За да извикаме <code>filter</code> да събере тези обекти на лица, чиито имена са в специфичния набор от данни, можем да напишем функция, която прави извикване на <code>isInSet</code> с нашия набор от данни, като първи аргумент или частично прилага <code>isInSet</code> функцията.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_P/KGz4FBMo" href="./05_higher_order.html#c_P/KGz4FBMo"></a><span class="cm-keyword">var</span> <span class="cm-variable">theSet</span> <span class="cm-operator">=</span> [<span class="cm-string">"Carel Haverbeke"</span>, <span class="cm-string">"Maria van Brussel"</span>,
              <span class="cm-string">"Donald Duck"</span>];
<span class="cm-keyword">function</span> <span class="cm-variable">isInSet</span>(<span class="cm-def">set</span>, <span class="cm-def">person</span>) {
  <span class="cm-keyword">return</span> <span class="cm-variable-2">set</span>.<span class="cm-property">indexOf</span>(<span class="cm-variable-2">person</span>.<span class="cm-property">name</span>) <span class="cm-operator">&gt;</span> <span class="cm-operator">-</span><span class="cm-number">1</span>;
}

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">ancestry</span>.<span class="cm-property">filter</span>(<span class="cm-keyword">function</span>(<span class="cm-def">person</span>) {
  <span class="cm-keyword">return</span> <span class="cm-variable">isInSet</span>(<span class="cm-variable">theSet</span>, <span class="cm-variable-2">person</span>);
}));
<span class="cm-comment">// → [{name: "Maria van Brussel", …},</span>
<span class="cm-comment">//    {name: "Carel Haverbeke", …}]</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">ancestry</span>.<span class="cm-property">filter</span>(<span class="cm-variable">isInSet</span>.<span class="cm-property">bind</span>(<span class="cm-atom">null</span>, <span class="cm-variable">theSet</span>)));
<span class="cm-comment">// → … same result</span></pre>
<p><a class="p_ident" id="p_P5qnPOIMMg" href="./05_higher_order.html#p_P5qnPOIMMg"></a>Извикването на <code>bind</code> връща функция, която извиква <code>isInSet</code> с <code>theSet</code>, като първи аргумент, последван от всички останали аргументи, подадени на свързващата функция.</p>
<p><a class="p_ident" id="p_j9JPuWJlk7" href="./05_higher_order.html#p_j9JPuWJlk7"></a>Първият аргумент, който е поставен в примера е <code>null</code>, той се използва за извикване на метод, подобно на първия аргумент на <code>apply</code>. Ще опишем това подробно в <a href="./06_object.html#call_method">следващата глава</a>.</p>
<h2><a class="h_ident" id="h_ErccPg/l98" href="./05_higher_order.html#h_ErccPg/l98"></a>Резюме</h2>
<p><a class="p_ident" id="p_EmYdYeFPjo" href="./05_higher_order.html#p_EmYdYeFPjo"></a>Да си в състояние да прехвърляш стойности на функция към други функции, не е просто трик, това е дълбок полезен аспект на JavaScript. Това ни позволява да напишем изчисления с “пропуски” в тях, като функции и има код, който позволява тези функции да попълнят тези пропуски, чрез предоставяне на функционални стойности, които описват липсващите изчисления.</p>
<p><a class="p_ident" id="p_YfXho6cgu+" href="./05_higher_order.html#p_YfXho6cgu+"></a>Масивите предоставят редица полезни по- висок стандарт методи: <code>forEach</code>, който прави нещо с всеки елемент на масива, <code>filter</code>, който изгражда нов масив с филтрираните елементи, <code>map</code>, който изгражда нов масив, където всеки елемент е преминал през функция и <code>reduce</code> който комбинира всички елементи на масива в една стойност.</p>
<p><a class="p_ident" id="p_3UBuCIfCEM" href="./05_higher_order.html#p_3UBuCIfCEM"></a>Функциите имат още и <code>apply</code> метод, който може да се използва за да ги извиква с масив от неговите аргументи. Те имат също и <code>bind</code> метод, който се използва за създаване на частично прилагана версия на функция.</p>
<h2><a class="h_ident" id="h_TcUD2vzyMe" href="./05_higher_order.html#h_TcUD2vzyMe"></a>Упражнения</h2>
<h3><a class="h_ident" id="h_aIOczlLyX1" href="./05_higher_order.html#h_aIOczlLyX1"></a>Сплескване</h3>
<p><a class="p_ident" id="p_RqAkArolEa" href="./05_higher_order.html#p_RqAkArolEa"></a>Използвайте метода <code>reduce</code> в комбинация с метода <code>concat</code> за да “изгладите” масив от масиви в един масив, който има всички елементи на входящия масив.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_HFu+EZSG8B" href="./05_higher_order.html#c_HFu+EZSG8B"></a><span class="cm-keyword">var</span> <span class="cm-variable">arrays</span> <span class="cm-operator">=</span> [[<span class="cm-number">1</span>, <span class="cm-number">2</span>, <span class="cm-number">3</span>], [<span class="cm-number">4</span>, <span class="cm-number">5</span>], [<span class="cm-number">6</span>]];
<span class="cm-comment">// Your code here.</span>
<span class="cm-comment">// → [1, 2, 3, 4, 5, 6]</span></pre>
<h3><a class="h_ident" id="h_I9XoVSLsTV" href="./05_higher_order.html#h_I9XoVSLsTV"></a>Възрастова разлика между майка и дете</h3>
<p><a class="p_ident" id="p_a44KIXR4aT" href="./05_higher_order.html#p_a44KIXR4aT"></a>Използвайте данните от настоящата глава за да изчислите разликата на средната възраст между майки и деца(това е възрастта на майката, когато детето се ражда). Можете да използвате  функцията <code>average</code> дефинирана <a href="./05_higher_order.html#average_function">по-рано</a> в тази глава.</p>
<p><a class="p_ident" id="p_/E+zqsb0UA" href="./05_higher_order.html#p_/E+zqsb0UA"></a>Имайте в предвид, че не всички майки, посочени в данните присъстват в масива. Обекта <code>byName</code>, може да ви е полезен, понеже прави лесно намирането на обекта на едно лице по името му.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_+30TY+6MeW" href="./05_higher_order.html#c_+30TY+6MeW"></a><span class="cm-keyword">function</span> <span class="cm-variable">average</span>(<span class="cm-def">array</span>) {
  <span class="cm-keyword">function</span> <span class="cm-def">plus</span>(<span class="cm-def">a</span>, <span class="cm-def">b</span>) { <span class="cm-keyword">return</span> <span class="cm-variable-2">a</span> <span class="cm-operator">+</span> <span class="cm-variable-2">b</span>; }
  <span class="cm-keyword">return</span> <span class="cm-variable-2">array</span>.<span class="cm-property">reduce</span>(<span class="cm-variable-2">plus</span>) <span class="cm-operator">/</span> <span class="cm-variable-2">array</span>.<span class="cm-property">length</span>;
}

<span class="cm-keyword">var</span> <span class="cm-variable">byName</span> <span class="cm-operator">=</span> {};
<span class="cm-variable">ancestry</span>.<span class="cm-property">forEach</span>(<span class="cm-keyword">function</span>(<span class="cm-def">person</span>) {
  <span class="cm-variable">byName</span>[<span class="cm-variable-2">person</span>.<span class="cm-property">name</span>] <span class="cm-operator">=</span> <span class="cm-variable-2">person</span>;
});

<span class="cm-comment">// Your code here.</span>

<span class="cm-comment">// → 31.2</span></pre>
<div class="solution"><div class="solution-text">
<p><a class="p_ident" id="p_UL/8si2OX7" href="./05_higher_order.html#p_UL/8si2OX7"></a>Тъй като не всички елементи в <code>ancestry</code> масива произвеждат полезни данни (не можем да изчислим разликата във възрастта, освен ако не сме сигурни в датата на раждане на майката) ние трябва да приложим <code>filter</code> по някакъв начин преди да извикаме <code>average</code>. Можете да го направите, като първо го подадете в определянето на <code>hasKnownMother</code> функцията и филтрирате там първо. Алтернативно, можете да извикате <code>map</code> във функция за мапване, за да върне разликата във възрастта или <code>null</code>, ако майката не е известна. След това можем да извикаме <code>filter</code> за премахване на <code>null</code> елементите преди да подадем масива в <code>average</code>.</p>
</div></div>
<h3><a class="h_ident" id="h_FkNn96IrQe" href="./05_higher_order.html#h_FkNn96IrQe"></a>Продължителноста на живота исторически</h3>
<p><a class="p_ident" id="p_ENbLeUYppS" href="./05_higher_order.html#p_ENbLeUYppS"></a>Когато прегледаме всички хора в нашия набор от данни, които са живели повече от 90г., излиза само последното поколение в данните. Нека погледнем по от-близо това явление.</p>
<p><a class="p_ident" id="p_0JOS/ablSJ" href="./05_higher_order.html#p_0JOS/ablSJ"></a>Изчисляват се изходящите данни на средната възраст на хората в потеклото за един век. Лице се определя на един век, когато годината на смъртта се дели на 100 и се закръгля на горе, както в <code>Math.ceil(person.died / 100)</code>.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_Xi4vRpdLx1" href="./05_higher_order.html#c_Xi4vRpdLx1"></a><span class="cm-keyword">function</span> <span class="cm-variable">average</span>(<span class="cm-def">array</span>) {
  <span class="cm-keyword">function</span> <span class="cm-def">plus</span>(<span class="cm-def">a</span>, <span class="cm-def">b</span>) { <span class="cm-keyword">return</span> <span class="cm-variable-2">a</span> <span class="cm-operator">+</span> <span class="cm-variable-2">b</span>; }
  <span class="cm-keyword">return</span> <span class="cm-variable-2">array</span>.<span class="cm-property">reduce</span>(<span class="cm-variable-2">plus</span>) <span class="cm-operator">/</span> <span class="cm-variable-2">array</span>.<span class="cm-property">length</span>;
}

<span class="cm-comment">// Your code here.</span>

<span class="cm-comment">// → 16: 43.5</span>
<span class="cm-comment">//   17: 51.2</span>
<span class="cm-comment">//   18: 52.8</span>
<span class="cm-comment">//   19: 54.8</span>
<span class="cm-comment">//   20: 84.7</span>
<span class="cm-comment">//   21: 94</span></pre>
<div class="solution"><div class="solution-text">
<p><a class="p_ident" id="p_fj5gLJr4+G" href="./05_higher_order.html#p_fj5gLJr4+G"></a>Същността на този пример се крие в групирането на елементите от колекцията с някои аспекти на тяхното разделяне в масива на предците, на по-малки масиви с предци за един век.</p>
<p><a class="p_ident" id="p_Jonw4Z0wbo" href="./05_higher_order.html#p_Jonw4Z0wbo"></a>По време на процеса на групиране, дръжте един обект, който свързва името на века (в цифри) с масива на един обект на човек или с възрастта. Тъй като не знаем предварително, какви категории ще открием, трябва да ги създадем в движение. За всеки човек, след изчисляване на неговия век, трябва да тестваме дали този век вече е бил известен. Ако не е, добавете масив за него. След това добавете лицето (или възрастта) в правилния масив за век.</p>
<p><a class="p_ident" id="p_YoO/BHbTiQ" href="./05_higher_order.html#p_YoO/BHbTiQ"></a>И на края може да използвате <code>for</code>/<code>in</code> цикъл за отпечатване на средната възраст за отделните векове.</p>
</div></div>
<p><a class="p_ident" id="p_yzI++go/yy" href="./05_higher_order.html#p_yzI++go/yy"></a>За бонус точки, напиши абстрактна функция <code>groupBy</code>, която обединява операциите. Тя трябва да приема като аргументи масив и функция, която изчислява групата за даден елемент в масива и връща един обект, който съпоставя групи от имена на групи от масиви.</p>
<h3><a class="h_ident" id="h_jr7hZiuR7+" href="./05_higher_order.html#h_jr7hZiuR7+"></a>Всеки и след това някои</h3>
<p><a class="p_ident" id="p_BZKBxgsPML" href="./05_higher_order.html#p_BZKBxgsPML"></a>Масивите също идват със стандартни методи: <code>every</code> и <code>some</code>. И двата извикват функция, която когато бъде призована с елемент от масив като аргумент, връща истина или лъжа. Точно както <code>&amp;&amp;</code> връща истина само когато всеки от изразите от двете и страни са верни, така и <code>every</code> връща истина, само когато твърдението е вярно за всички елементи от масива. По същия начин и <code>some</code> връща истина, веднага след като, твърдението върне вярно за някой от елементите на масива. Те не обработват повече елементи от колкото е необходимо, например, ако <code>some</code> открие, че твърдението взема първия елемент на масива за верен, той няма да разглежда стойности след това.</p>
<p><a class="p_ident" id="p_aMPYznovUm" href="./05_higher_order.html#p_aMPYznovUm"></a>Напишете две функции <code>every</code> и <code>some</code>, които се държат като тези методи, с изключение на това, че те вземат масива като първи аргумент вместо да са метод.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_EK+njyIMWq" href="./05_higher_order.html#c_EK+njyIMWq"></a><span class="cm-comment">// Your code here.</span>

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">every</span>([<span class="cm-atom">NaN</span>, <span class="cm-atom">NaN</span>, <span class="cm-atom">NaN</span>], <span class="cm-variable">isNaN</span>));
<span class="cm-comment">// → true</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">every</span>([<span class="cm-atom">NaN</span>, <span class="cm-atom">NaN</span>, <span class="cm-number">4</span>], <span class="cm-variable">isNaN</span>));
<span class="cm-comment">// → false</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">some</span>([<span class="cm-atom">NaN</span>, <span class="cm-number">3</span>, <span class="cm-number">4</span>], <span class="cm-variable">isNaN</span>));
<span class="cm-comment">// → true</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">some</span>([<span class="cm-number">2</span>, <span class="cm-number">3</span>, <span class="cm-number">4</span>], <span class="cm-variable">isNaN</span>));
<span class="cm-comment">// → false</span></pre>
<div class="solution"><div class="solution-text">
<p><a class="p_ident" id="p_43tyHVRbBq" href="./05_higher_order.html#p_43tyHVRbBq"></a>Функциите могат да следват подобен модел на поведение, подобен на <a href="./05_higher_order.html#forEach">дефиницията</a> за <code>forEach</code> в началото на тази глава, с изключение на това, че трябва да се върнат незабавно (с правилната стойност), когато функцията <em>predicate</em> връща <em>false</em> или <em>true</em>. Не забравяйте да поставите друго <code>return</code> изявление след края на цикъла, така че функцията също да връща правилните стойности, когато достигне края на масива.</p>
</div></div>
<nav>
  <a href="./04_data.html" title="previous chapter">◀</a>
  <a href="./index.html" title="cover">◆</a>
  <a href="./06_object.html" title="next chapter">▶</a>
</nav>
</article>
</body></html>