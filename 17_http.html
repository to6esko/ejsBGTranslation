<!DOCTYPE html>
<!-- saved from url=(0042)./17_http.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <title>HTTP :: Eloquent JavaScript</title>
  <link rel="stylesheet" href="./media/codemirror.css">
  <script src="./media/acorn_codemirror.js"></script>
  <link rel="stylesheet" href="./media/ejs.css">
  <script src="./media/sandbox.js"></script>
  <script src="./media/ejs.js"></script>
  <script>var chapNum = 17;var sandboxLoadFiles = ["code/chapter/17_http.js", "code/promise.js"];</script>
</head>

<body><article>
<nav>
  <a href="./16_canvas.html" title="previous chapter">◀</a>
  <a href="./index.html" title="cover">◆</a>
  <a href="./18_forms.html" title="next chapter">▶</a>
</nav>

<h1><div class="chap_num">Глава 17</div>HTTP</h1>
<blockquote>
<p><a class="p_ident" id="p_QvqpbswJB1" href="./17_http.html#p_QvqpbswJB1"></a>Мечтата зад Уеб е за общо информационно пространство, в което ние общуваме чрез обмен на информация. Неговата универсалност е от съществено значение: факт е, че хипер-връзката може да сочи към нещо било то индивидуално, местно или глобално е да го проектира или изтъкне.”</p>
 <footer>Tim Berners-Lee, <cite>The World Wide Web: Много кратка лична история</cite></footer>
</blockquote>
<p><a class="p_ident" id="p_C6+RXvCvFu" href="./17_http.html#p_C6+RXvCvFu"></a>Протоколът <em>Hypertext Transfer Protocol</em>, споменат в <a href="./12_browser.html#web">Глава 12</a>, е механизмът, чрез който се изисква информация и в условие на Wrold Wide Web. Тази глава описва протокола по-подробно и обяснява начина, по който браузъра на JavaScript  има достъп до него.</p>
<h2><a class="h_ident" id="h_vXdZCu/Tty" href="./17_http.html#h_vXdZCu/Tty"></a>Протоколът</h2>
<p><a class="p_ident" id="p_uAGANEYkBZ" href="./17_http.html#p_uAGANEYkBZ"></a>Ако изпишете <em>eloquentjavascript.net/17_http.html</em> в адресната лента на браузъра си, той първо поглежда адреса на сървъра, свързан с <em>eloquentjavascript.net</em> и се опитва да открие TCP връзка с нея на порт 80, който по подразбиране е порт за HTTP трафика. Ако сървърът съществува и приеме връзката, браузъра изпраща нещо такова:</p>
<pre data-language="http" class="snippet cm-s-default"><a class="c_ident" id="c_B1oAtzWnlx" href="./17_http.html#c_B1oAtzWnlx"></a><span class="cm-keyword">GET</span> <span class="cm-string-2">/17_http.html</span> <span class="cm-keyword">HTTP/1.1</span>
<span class="cm-atom">Host:</span><span class="cm-string"> eloquentjavascript.net</span>
<span class="cm-atom">User-Agent:</span><span class="cm-string"> Your browser's name</span></pre>
<p><a class="p_ident" id="p_cpaXDnG/vq" href="./17_http.html#p_cpaXDnG/vq"></a>После сървърът отговаря (<em>responds</em>), през същата тази връзка.</p>
<pre data-language="http" class="snippet cm-s-default"><a class="c_ident" id="c_jb8msMtad8" href="./17_http.html#c_jb8msMtad8"></a><span class="cm-keyword">HTTP/1.1</span> <span class="cm-positive cm-success">200</span> OK
<span class="cm-atom">Content-Length:</span><span class="cm-string"> 65585</span>
<span class="cm-atom">Content-Type:</span><span class="cm-string"> text/html</span>
<span class="cm-atom">Last-Modified:</span><span class="cm-string"> Wed, 09 Apr 2014 10:48:09 GMT</span>

&lt;!doctype html&gt;
... the rest of the document</pre>
<p><a class="p_ident" id="p_RRCiB3G5cb" href="./17_http.html#p_RRCiB3G5cb"></a>Браузърът след това взема част от отговора и след празен ред го показва, като HTML документ.</p>
<p><a class="p_ident" id="p_EF5P7+qf9n" href="./17_http.html#p_EF5P7+qf9n"></a>От информацията изпратена от клиента се взема искането <em>request</em>. То започва с този ред:</p>
<pre data-language="http" class="snippet cm-s-default"><a class="c_ident" id="c_/t2TOTMJ5I" href="./17_http.html#c_/t2TOTMJ5I"></a><span class="cm-keyword">GET</span> <span class="cm-string-2">/17_http.html</span> <span class="cm-keyword">HTTP/1.1</span></pre>
<p><a class="p_ident" id="p_0OgmCKjRs2" href="./17_http.html#p_0OgmCKjRs2"></a>Първата дума е методът на искането <code>GET</code>, средство, с което искаме да получим от определен ресурс. Други общи методи са <code>DELETE</code> за изтриване на даден ресурс, <code>PUT</code> да го заменим и <code>POST</code> да изпратим информация за него. Имайте в предвид, че сървърът не е длъжен да изпълнява всяко искане, което получава. Ако отидете на произволен сайт и му кажете <code>DELETE</code> на главната страница, той най-вероятно ще откаже.</p>
<p><a class="p_ident" id="p_dRtHLefq7L" href="./17_http.html#p_dRtHLefq7L"></a>Частта след името на метода е пътя на ресурса на искането, към което се отнася. В най-простия случай, ресурс е просто един файл на сървъра, но протокола не изисква той да бъде файл. Ресурсът може да бъде нещо, което може да се прехвърля, като файл. Много сървъри генерират отговорите, които се произвеждат в движение. Например ако отворим <a href="http://twitter.com/marijnjh"><em>twitter.com/marijnjh</em></a> сървърът поглежда в своята база данни за потребителското име <em>marijnjh</em> и ако установи такова ще генерира страница на профила на този потребител.</p>
<p><a class="p_ident" id="p_M95qaU9kuN" href="./17_http.html#p_M95qaU9kuN"></a>След пътя на ресурсите, на първо място в линията на искането е <code>HTTP/1.1</code> за да покаже, коя версия на HTTP  протокола използва.</p>
<p><a class="p_ident" id="p_pIMelD1mZh" href="./17_http.html#p_pIMelD1mZh"></a>Отговорът на сървъра започва с версията следвана от статуса на отговора, първо като трицифрен код на състоянието и после, като <em>string</em> четим от човек.</p>
<pre data-language="http" class="snippet cm-s-default"><a class="c_ident" id="c_0nHloyp4nW" href="./17_http.html#c_0nHloyp4nW"></a><span class="cm-keyword">HTTP/1.1</span> <span class="cm-positive cm-success">200</span> OK</pre>
<p><a class="p_ident" id="p_I8BGMaErRo" href="./17_http.html#p_I8BGMaErRo"></a>Статус кодове започващи с 2 показват, че искането е успешно. Кодове започващи с 4 означават, че нещо не е наред с искането. 404 е може би най-известният код на HTTP статуса, който означава, че поисканият ресурс не може да бъде намерен. Кодове, които започват с 5 означават, че грешката се е случила на сървъра и искането не е виновно.</p>
<p id="headers"><a class="p_ident" id="p_CA64oLhdLd" href="./17_http.html#p_CA64oLhdLd"></a>Първият ред на искането или отговора може да бъде последвано от произволен брой заглавия. Това са линии във формата: “име: стойност”, които уточняват допълнителната информация  за искането или отговора. Тези заглавия са част от примерен отговор:</p>
<pre>Content-Length: 65585
Content-Type: text/html
Last-Modified: Wed, 09 Apr 2014 10:48:09 GMT</pre>
<p><a class="p_ident" id="p_04zcUGZ8sT" href="./17_http.html#p_04zcUGZ8sT"></a>Това ни казва размера и вида на документа за отговор. В този случай това е HTML документ с 65,585 байта. Той също така ни казва последната промяна на този документ.</p>
<p><a class="p_ident" id="p_dIM0DmAcMY" href="./17_http.html#p_dIM0DmAcMY"></a>В по-голямата си част, клиента или сървъра решават , кои заглавия да включат в рамките на искане или отговор, въпреки че няколко заглавия са необходими. Например, <code>Host</code> заглавието, уточнява името на домейна, което трябва да бъде включено в искането, защото сървъра може да обслужва няколко имена на домейни на един IP адрес и без това заглавие, сървърът няма да знае с кой домейн клиентът се опитва да се свърже.</p>
<p><a class="p_ident" id="p_DeF17lBSIn" href="./17_http.html#p_DeF17lBSIn"></a>След заглавието,  искането и отговора могат да бъдат включени в един празен ред, последван от тяло, което съдържа данните, които се изпращат. <code>GET</code> и <code>DELETE</code> не изпращат всички данни, но <code>PUT</code> и <code>POST</code> заявките го правят. По същия начин, някои видове отговори, като отговори за грешки не се нуждаят от тяло.</p>
<h2><a class="h_ident" id="h_G1xxLfiYeu" href="./17_http.html#h_G1xxLfiYeu"></a>Браузъри  и  HTTP</h2>
<p><a class="p_ident" id="p_FaMpawa4Gl" href="./17_http.html#p_FaMpawa4Gl"></a>Както видяхме в примера, браузъра ще направи искане, когато въведем URL адреса в бара му. Когато получената HTML страница направи препратка към други файлове, като изображения и JavaScript файлове, те също така ще бъдат привлечени.</p>
<p><a class="p_ident" id="p_7zqOoBgyIg" href="./17_http.html#p_7zqOoBgyIg"></a>Умерено сложен сайт може лесно да включва някъде от 10 до 200 ресурса. За да бъде в състояние да ги вземе бързо, браузъра прави няколко искания едновременно, вместо да чака отговорите един по един. Такива документи са винаги извлечени с помощта <code>GET</code> заявки.</p>
<p id="http_forms"><a class="p_ident" id="p_Aub9jfdnAA" href="./17_http.html#p_Aub9jfdnAA"></a>HTML страници могат да включват <em>forms</em> (форми), които позволяват на потребителя да попълни информация и да я изпрати на сървъра. Това е пример на форма:</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class="c_ident" id="c_GZhGQeEihW" href="./17_http.html#c_GZhGQeEihW"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">form</span> <span class="cm-attribute">method</span>=<span class="cm-string">"GET"</span> <span class="cm-attribute">action</span>=<span class="cm-string">"example/message.html"</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>Name: <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">input</span> <span class="cm-attribute">type</span>=<span class="cm-string">"text"</span> <span class="cm-attribute">name</span>=<span class="cm-string">"name"</span><span class="cm-tag cm-bracket">&gt;&lt;/</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>Message:<span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">br</span><span class="cm-tag cm-bracket">&gt;&lt;</span><span class="cm-tag">textarea</span> <span class="cm-attribute">name</span>=<span class="cm-string">"message"</span><span class="cm-tag cm-bracket">&gt;&lt;/</span><span class="cm-tag">textarea</span><span class="cm-tag cm-bracket">&gt;&lt;/</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;&lt;</span><span class="cm-tag">button</span> <span class="cm-attribute">type</span>=<span class="cm-string">"submit"</span><span class="cm-tag cm-bracket">&gt;</span>Send<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">button</span><span class="cm-tag cm-bracket">&gt;&lt;/</span><span class="cm-tag">p</span><span class="cm-tag cm-bracket">&gt;</span>
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">form</span><span class="cm-tag cm-bracket">&gt;</span></pre>
<p><a class="p_ident" id="p_7XkP0qerQY" href="./17_http.html#p_7XkP0qerQY"></a>Този код описва форма с две полета: малко с въпрос за име и по-голямо за писане на съобщение. Когато кликнем върху бутона <em>Send</em>, информацията в тези две полета ще бъде кодирана в <em>query string</em> заявка. Когато <code>&lt;form&gt;</code> елемента съдържа метод атрибут <code>GET</code> (или е пропуснат), тази <em>string</em> заявка се закача върху действащия URL и браузъра прави <code>GET</code> заявка в този URL.</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class="c_ident" id="c_3P+4LKZOZu" href="./17_http.html#c_3P+4LKZOZu"></a>GET /example/message.html?name=Jean<span class="cm-error">&amp;message</span>=Yes%3F HTTP/1.1</pre>
<p><a class="p_ident" id="p_ExLzsDAoPr" href="./17_http.html#p_ExLzsDAoPr"></a>Началото на тази <em>query string</em> заявка се обозначава с въпросителен знак. След това следват двойки имена и стойности, съответстващи на <code>name</code> атрибута на попълнената форма с елементи и съдържанието на тези елементи, съответно. Символът амперсанд (<code>&amp;</code>) се използва  за разделяне на двойките.</p>
<p><a class="p_ident" id="p_4Eo/x5v9Qy" href="./17_http.html#p_4Eo/x5v9Qy"></a>Реалното послание, кодирано в предишния URL адрес  е “Yes?” макар, че въпросителния знак се заменя със странен код. Някои знаци в <em>query string</em> заявките трябва да се ескейпнат. Маркировката за въпрос представена със <code>%3F</code> е един от тях. Има едно неписано правило, че всеки формат се нуждае от свой собствен начин за ескейпинг на характерите. Този начин се нарича <em>URL
encoding</em> (кодиране), който използва знака за процент %, последван от две шестнадестични цифри, които кодират кода на характера. В този случай 3F, което е 63 в десетична бройна система, е кодът на характера за въпросителен знак. JavaScript осигурява  <code>encodeURIComponent</code> и <code>decodeURIComponent</code> функции за кодиране и декодиране на този формат.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_iUqK1/d6dT" href="./17_http.html#c_iUqK1/d6dT"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">encodeURIComponent</span>(<span class="cm-string">"Hello &amp; goodbye"</span>));
<span class="cm-comment">// → Hello%20%26%20goodbye</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">decodeURIComponent</span>(<span class="cm-string">"Hello%20%26%20goodbye"</span>));
<span class="cm-comment">// → Hello &amp; goodbye</span></pre>
<p><a class="p_ident" id="p_l15d9HkVlZ" href="./17_http.html#p_l15d9HkVlZ"></a>Ако променим метод атрибута на HTML формата, в примера, който видяхме по-рано към <code>POST</code>, HTTP искането направено за представяне на формата ще използва метода <code>POST</code> и поставяне на <em>query string</em> запитване в тялото на искането вместо да го добави в URL адреса.</p>
<pre data-language="http" class="snippet cm-s-default"><a class="c_ident" id="c_41i/U10MNd" href="./17_http.html#c_41i/U10MNd"></a><span class="cm-keyword">POST</span> <span class="cm-string-2">/example/message.html</span> <span class="cm-keyword">HTTP/1.1</span>
<span class="cm-atom">Content-length:</span><span class="cm-string"> 24</span>
<span class="cm-atom">Content-type:</span><span class="cm-string"> application/x-www-form-urlencoded</span>

name=Jean&amp;message=Yes%3F</pre>
<p><a class="p_ident" id="p_K5PHhwPNop" href="./17_http.html#p_K5PHhwPNop"></a>По конвенция, <code>GET</code> метода се използва за искания, които нямат странични ефекти, като направата на едно търсене. Исканията, които променят нещо в сървъра, като например създаване на нов акаунт или публикуване на съобщение, следва да бъдат изразени с други методи, като <code>POST</code>. Софтуера от страна на клиента, като браузъра, знае че не трябва сляпо да изпълнява <code>POST</code> заявки, но често мълчаливо прави <code>GET</code>заявки - например <em>prefetch</em> ресурса вярва, че потребителя се нуждае от него.</p>
<p><a class="p_ident" id="p_mOjZBRUuCo" href="./17_http.html#p_mOjZBRUuCo"></a>В <a href="./18_forms.html#forms">следващата глава</a> ще се върнем към форми и ще поговорим за това как можем да ги пишем с JavaScript.</p>
<h2 id="xmlhttprequest"><a class="h_ident" id="h_Gh3HVKEFJQ" href="./17_http.html#h_Gh3HVKEFJQ"></a>XMLHttpRequest</h2>
<p><a class="p_ident" id="p_sEiPS/dTmx" href="./17_http.html#p_sEiPS/dTmx"></a>Интерфейса, с който браузъра  JavaScript  може да направи HTTP заявки се нарича <code>XMLHttpRequest</code> (обърнете внимание на непоследователната капитализация). Той е проектиран от Microsoft за неговия браузър  Internet Explorer в края на 1990г. през това време формата на XML файл е много популярна в света на бизнес софтуера - един свят, където Microsoft винаги е бил у дома си. Всъщност, тя е толкова популярна, че акронимът XML е бил залепен на предната част на името на интерфейса за HTTP, който по никакъв начин не е обвързан с  XML.</p>
<p><a class="p_ident" id="p_ED7N2rpOmD" href="./17_http.html#p_ED7N2rpOmD"></a>Името не е напълно безсмислено все пак. Интерфейса позволява да прави разбор на документи за отговор, като XML ако искате. Смесването на две различни понятия (правене на искане и разбор на отговора) в едно нещо е ужасен дизайн, разбира се , но така стоят нещата.</p>
<p><a class="p_ident" id="p_huklKLNeHt" href="./17_http.html#p_huklKLNeHt"></a>Когато интерфейса <code>XMLHttpRequest</code> е добавен в Internet Explorer, той позволява на хората да правят неща с JavaScript, които са били много трудни преди. Така например, уеб сайтовете започнали да показват списъци с предложения, когато потребителя пише нещо в текстовото поле. Скрипта ще изпрати текста към сървъра през HTTP, който потребителя въведе. Сървърът, който има някаква база данни за възможни входове ще съпостави записите в базата данни със входящите и ще изпрати обратно възможните изпълнения, които да покаже на потребителя. Това се счита за грандиозен замисъл - хората бяха свикнали да чакат пълното зареждане на страницата за някакво взаимодействие с уеб сайта. </p>
<p><a class="p_ident" id="p_yNW5lu4ilN" href="./17_http.html#p_yNW5lu4ilN"></a>Друг значителен браузър по това време е Morzilla (Firefox по-късно) не искаше да бъде забравен. За да даде възможност на хората да правят подобни неща на своя браузър,  Morzilla копират интерфейса включително и сбърканото име. Следващото поколение браузъри последвали този пример и днес <code>XMLHttpRequest</code> е дефакто стандартен интерфейс.</p>
<h2><a class="h_ident" id="h_NfPWoSbXzR" href="./17_http.html#h_NfPWoSbXzR"></a>Изпращане  на  заявка (request)</h2>
<p><a class="p_ident" id="p_EQKwKXO14E" href="./17_http.html#p_EQKwKXO14E"></a>За да се направи просто искане, ние създаваме обект-искане с <code>XMLHttpRequest</code> конструктора и извикваме неговите <code>open</code> и <code>send</code> методи.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_S4pyLFcZea" href="./17_http.html#c_S4pyLFcZea"></a><span class="cm-keyword">var</span> <span class="cm-variable">req</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">XMLHttpRequest</span>();
<span class="cm-variable">req</span>.<span class="cm-property">open</span>(<span class="cm-string">"GET"</span>, <span class="cm-string">"example/data.txt"</span>, <span class="cm-atom">false</span>);
<span class="cm-variable">req</span>.<span class="cm-property">send</span>(<span class="cm-atom">null</span>);
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">req</span>.<span class="cm-property">responseText</span>);
<span class="cm-comment">// → This is the content of data.txt</span></pre>
<p><a class="p_ident" id="p_wgyJl8Iwi6" href="./17_http.html#p_wgyJl8Iwi6"></a>Метода <code>open</code> конфигурира искането. В този случай избираме да направим <code>GET</code> заявка за файла <em>example/data.txt</em> адреси, които не започват с името на протокол (като <em>http:</em>) са относителни, което означава, че те се тълкуват спрямо текущия документ. Когато започват с наклонена черта  / , те заменят текущия път, който е частта след името на сървъра. Когато това не е така, частта на текущия път до и включително последната черта характер се поставят в предната част на относителния URL адрес.</p>
<p><a class="p_ident" id="p_AodYq0EUqt" href="./17_http.html#p_AodYq0EUqt"></a>След отваряне на искането, можем да го изпратим със <code>send</code> метода. Аргументът за изпращане е тялото на запитването. За <code>GET</code> заявки можем да <code>null</code>. Ако третият аргумент за <code>open</code> е <code>false</code>, <code>send</code> ще се върне само, след като е получен отговор на искането. Ние можем да прочетем заявката в свойството на обекта <code>responseText</code>, от тялото на получения отговор.</p>
<p><a class="p_ident" id="p_OWl9lqs7j6" href="./17_http.html#p_OWl9lqs7j6"></a>Друга информация включена в отговора, също може да бъде извлечена от този обект. Кода на статуса е достъпен чрез <code>status</code> свойството, както и статус текста разбираем за човек е достъпен чрез <code>statusText</code>. Заглавията могат да се прочетат с <code>getResponseHeader</code>.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_7D9Ia+cyzu" href="./17_http.html#c_7D9Ia+cyzu"></a><span class="cm-keyword">var</span> <span class="cm-variable">req</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">XMLHttpRequest</span>();
<span class="cm-variable">req</span>.<span class="cm-property">open</span>(<span class="cm-string">"GET"</span>, <span class="cm-string">"example/data.txt"</span>, <span class="cm-atom">false</span>);
<span class="cm-variable">req</span>.<span class="cm-property">send</span>(<span class="cm-atom">null</span>);
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">req</span>.<span class="cm-property">status</span>, <span class="cm-variable">req</span>.<span class="cm-property">statusText</span>);
<span class="cm-comment">// → 200 OK</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">req</span>.<span class="cm-property">getResponseHeader</span>(<span class="cm-string">"content-type"</span>));
<span class="cm-comment">// → text/plain</span></pre>
<p><a class="p_ident" id="p_lJQuRg3OV0" href="./17_http.html#p_lJQuRg3OV0"></a>Заглавията са чуствителни към регистъра. Те обикновено се пишат с главна буква в началото на всяка дума, като “Content-Type” , но “content-type” и “Content-Type” се отнасят за една и съща заглавна част.</p>
<p><a class="p_ident" id="p_UkSLHXvU3D" href="./17_http.html#p_UkSLHXvU3D"></a>Браузърът автоматично ще добави заглавие към заявката, като “Host” (домакин), както и тези необходими за сървъра, за да разбере размера на тялото. Но вие можете да добавите свои собствени заглавия със <code>setRequestHeader</code> метода. Това е необходимо само за модерни приложения, които изискват сътрудничеството на сървъра, с когото говорят - сървърът  е свободен да игнорира заглавия, с които не знае как да се справи.</p>
<h2><a class="h_ident" id="h_B6OtWq8Z7x" href="./17_http.html#h_B6OtWq8Z7x"></a>Асинхронни  заявки</h2>
<p><a class="p_ident" id="p_xK9lUJ4zpm" href="./17_http.html#p_xK9lUJ4zpm"></a>В примерите, които видяхме заявката е приключила, когато <code>send</code> се е върнал. Това е удобно, тъй като свойства, като <code>responseText</code> вече са на разположение. Но също така означава, че нашата програма е на изчакване, докато браузъра и сървъра комуникират. Когато връзката е лоша, сървърът е бавен или файла е голям, това може да отнеме доста време. Още по-лошо е, че манипулаторите на събития могат да работят, докато нашата програма изчаква и целият документ да стане нечуствителен.</p>
<p><a class="p_ident" id="p_zjXoJQW9df" href="./17_http.html#p_zjXoJQW9df"></a>Ако подадем <code>true</code>, като трети аргумент на <code>open</code>, искането ще стане асинхронно. Това означава, че когато извикаме <code>send</code>, единственото нещо, което се случва веднага, е че заявката е планирана да бъде изпратена. Нашата програма може да продължи и браузърът ще се погрижи за изпращане и получаване на данни във фонов режим.</p>
<p><a class="p_ident" id="p_4WsIyXtb4Y" href="./17_http.html#p_4WsIyXtb4Y"></a>Но докато искането се изпълнява ние нямаме достъп до отговора. Имаме нужда от механизъм, който да ни уведоми, когато данните са на разположение.</p>
<p><a class="p_ident" id="p_icR3wVhR/6" href="./17_http.html#p_icR3wVhR/6"></a>За тази цел трябва да ползваме <code>"load"</code> събитие в обекта на заявката.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_Hhajlonku9" href="./17_http.html#c_Hhajlonku9"></a><span class="cm-keyword">var</span> <span class="cm-variable">req</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">XMLHttpRequest</span>();
<span class="cm-variable">req</span>.<span class="cm-property">open</span>(<span class="cm-string">"GET"</span>, <span class="cm-string">"example/data.txt"</span>, <span class="cm-atom">true</span>);
<span class="cm-variable">req</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">"load"</span>, <span class="cm-keyword">function</span>() {
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"Done:"</span>, <span class="cm-variable">req</span>.<span class="cm-property">status</span>);
});
<span class="cm-variable">req</span>.<span class="cm-property">send</span>(<span class="cm-atom">null</span>);</pre>
<p><a class="p_ident" id="p_CAzrPM0mYP" href="./17_http.html#p_CAzrPM0mYP"></a>Точно както използването на <code>requestAnimationFrame</code> в <a href="./15_game.html#game">Глава 15</a> нуждата от използване на асинхронно програмиране, опакова нещата във функция, които трябва да бъдат свършени след подаването на заявката и осигуряването им, когато бъдат поискани в подходящото време. Ще се върнем към това <a href="./17_http.html#promises">по-късно</a>.</p>
<h2><a class="h_ident" id="h_FhSkVawGDi" href="./17_http.html#h_FhSkVawGDi"></a>Fetching XML данни</h2>
<p><a class="p_ident" id="p_96cGuKLvjr" href="./17_http.html#p_96cGuKLvjr"></a>Когато ресурсът, извлечен от обекта на <code>XMLHttpRequest</code> е XML документ, свойството на обекта <code>responseXML</code> ще анализира представянето на този документ. Работата на това представяне много прилича на DOM обсъдено <a href="./13_dom.html#dom">Глава 13</a> с изключение на това, че не разполага с HTML - специфичната функционалност на <code>style</code> свойството. Обекта на <code>responseXML</code> съответства на <code>document</code> обект. Неговото свойство <code>documentElement</code> се отнася до външният етикет на XML документа. В следващият документ (<em>example/fruit.xml</em>) това ще бъде <code>&lt;fruits&gt;</code> тага:</p>
<pre data-language="application/xml" class="snippet cm-s-default"><a class="c_ident" id="c_RtdE6qlfWc" href="./17_http.html#c_RtdE6qlfWc"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">fruits</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">fruit</span> <span class="cm-attribute">name</span>=<span class="cm-string">"banana"</span> <span class="cm-attribute">color</span>=<span class="cm-string">"yellow"</span><span class="cm-tag cm-bracket">/&gt;</span>
  <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">fruit</span> <span class="cm-attribute">name</span>=<span class="cm-string">"lemon"</span> <span class="cm-attribute">color</span>=<span class="cm-string">"yellow"</span><span class="cm-tag cm-bracket">/&gt;</span>
  <span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">fruit</span> <span class="cm-attribute">name</span>=<span class="cm-string">"cherry"</span> <span class="cm-attribute">color</span>=<span class="cm-string">"red"</span><span class="cm-tag cm-bracket">/&gt;</span>
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">fruits</span><span class="cm-tag cm-bracket">&gt;</span></pre>
<p><a class="p_ident" id="p_3NjSjUCAEg" href="./17_http.html#p_3NjSjUCAEg"></a>Ние можем да извлечем такъв файл, подобен на този:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_vkLnjsVdpV" href="./17_http.html#c_vkLnjsVdpV"></a><span class="cm-keyword">var</span> <span class="cm-variable">req</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">XMLHttpRequest</span>();
<span class="cm-variable">req</span>.<span class="cm-property">open</span>(<span class="cm-string">"GET"</span>, <span class="cm-string">"example/fruit.xml"</span>, <span class="cm-atom">false</span>);
<span class="cm-variable">req</span>.<span class="cm-property">send</span>(<span class="cm-atom">null</span>);
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">req</span>.<span class="cm-property">responseXML</span>.<span class="cm-property">querySelectorAll</span>(<span class="cm-string">"fruit"</span>).<span class="cm-property">length</span>);
<span class="cm-comment">// → 3</span></pre>
<p><a class="p_ident" id="p_5fmUcEnbjN" href="./17_http.html#p_5fmUcEnbjN"></a>XML документите могат да се използват за обмен на структурирана информация със сървъра. Тяхната форма с тагове, вложени в други тагове се поддава добре на съхраняване на повечето видове данни или по-добре, от колкото плоски текстови файлове. Интерфейсът на DOM е по-скоро тромав за извличане на информация и XML документите са склонни да бъдат многословни. Често по-добра идея е да общуват с помощта на JSON данни, които са по-лесни за четене и писане, както за програми така и за хора.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_b665cw/Yoz" href="./17_http.html#c_b665cw/Yoz"></a><span class="cm-keyword">var</span> <span class="cm-variable">req</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">XMLHttpRequest</span>();
<span class="cm-variable">req</span>.<span class="cm-property">open</span>(<span class="cm-string">"GET"</span>, <span class="cm-string">"example/fruit.json"</span>, <span class="cm-atom">false</span>);
<span class="cm-variable">req</span>.<span class="cm-property">send</span>(<span class="cm-atom">null</span>);
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">JSON</span>.<span class="cm-property">parse</span>(<span class="cm-variable">req</span>.<span class="cm-property">responseText</span>));
<span class="cm-comment">// → {banana: "yellow", lemon: "yellow", cherry: "red"}</span></pre>
<h2 id="http_sandbox"><a class="h_ident" id="h_4h3DL+zoLY" href="./17_http.html#h_4h3DL+zoLY"></a>Тестова  среда  на  HTTP</h2>
<p><a class="p_ident" id="p_RMl+jfbkqI" href="./17_http.html#p_RMl+jfbkqI"></a>Осъществяването на HTTP заявки в уеб страници отново поражда опасения за сигурността. Човекът, който контролира скриптовете може да няма същите интереси, като лицето на чиито компютър се изпълняват. По конкретно, ако посетим <em>themafia.org</em>, аз не искам неговите скриптове да бъдат в състояние да направят искане до <em>mybank.com</em>, използвайки идентифициращата информация на моя браузър с указания за прехвърляне на всички пари в някоя чужда сметка.</p>
<p><a class="p_ident" id="p_qIXFpjWK5N" href="./17_http.html#p_qIXFpjWK5N"></a>Възможно е уеб сайтовете да се защитят срещу такива атаки, но това изисква усилия и много сайтове не успяват да го направят. Поради тази причина браузърите ни предпазват забранявайки скриптове, които правят заявки към други домейни (като <em>themafia.org</em> и <em>mybank.com</em>).</p>
<p><a class="p_ident" id="p_UCqQ0Yw7G5" href="./17_http.html#p_UCqQ0Yw7G5"></a>Това може да бъде досаден проблем при изграждането на системи, които искат достъп до няколко домейна с основателна причина. За съжаление, сървърите могат да включват глава в случай на изрично указание на браузъра, за одобряване на заявките, които идват от други домейни.</p>
<pre>Access-Control-Allow-Origin: *</pre>
<h2><a class="h_ident" id="h_RR7vot6vKN" href="./17_http.html#h_RR7vot6vKN"></a>Абстрактни  заявки</h2>
<p><a class="p_ident" id="p_3R01AAt3PW" href="./17_http.html#p_3R01AAt3PW"></a>В <a href="./10_modules.html#amd">Глава 10</a>, в изпълнението на модулна система AMD, ние използвахме една хипотетична функция наречена <code>backgroundReadFile</code>. Тя взема името на файла и функцията, и извиква тази функция със съдържанието на файла, когато свърши изтеглянето му. Ето едно просто изпълнение на тази функция</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_db2tCQrwnC" href="./17_http.html#c_db2tCQrwnC"></a><span class="cm-keyword">function</span> <span class="cm-variable">backgroundReadFile</span>(<span class="cm-def">url</span>, <span class="cm-def">callback</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">req</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">XMLHttpRequest</span>();
  <span class="cm-variable-2">req</span>.<span class="cm-property">open</span>(<span class="cm-string">"GET"</span>, <span class="cm-variable-2">url</span>, <span class="cm-atom">true</span>);
  <span class="cm-variable-2">req</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">"load"</span>, <span class="cm-keyword">function</span>() {
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">req</span>.<span class="cm-property">status</span> <span class="cm-operator">&lt;</span> <span class="cm-number">400</span>)
      <span class="cm-variable-2">callback</span>(<span class="cm-variable-2">req</span>.<span class="cm-property">responseText</span>);
  });
  <span class="cm-variable-2">req</span>.<span class="cm-property">send</span>(<span class="cm-atom">null</span>);
}</pre>
<p><a class="p_ident" id="p_nNxmesIyV4" href="./17_http.html#p_nNxmesIyV4"></a>Тази абстракция прави по-лесно използването на <code>XMLHttpRequest</code> за прости <code>GET</code> заявки. Ако пишем програма, която трябва да направи HTTP заявка е добра идея да се използва помощна функция, така че да не се повтаря грозния <code>XMLHttpRequest</code> модел през целия код.</p>
<p><a class="p_ident" id="p_8Shcg3/WzI" href="./17_http.html#p_8Shcg3/WzI"></a>Функцията <code>callback</code>с имената на аргументите е термин, който често се използва за описване на функции, като тази. На функцията <em>callback</em> и се дава друг код, за да сме сигурни, че този код е начин за обратно извикване по-късно.</p>
<p><a class="p_ident" id="p_xKwFWu3zF0" href="./17_http.html#p_xKwFWu3zF0"></a>Не е трудно да се напише функция за HTTP програма, съобразена с това, което и налагаме да прави. Предишната прави само <code>GET</code> заявки и не ни дава контрол върху заглавията и исканията на тялото. Можем да напишем друг вариант на <code>POST</code> заявки или общо един, който поддържа различни видове заявки. Много JavaScript библиотеки също предоставят опаковки за <code>XMLHttpRequest</code>.</p>
<p><a class="p_ident" id="p_2cF6BoTzh8" href="./17_http.html#p_2cF6BoTzh8"></a>Основният проблем на предишната обвивка е манипулирането на грешка. Когато искането връща статус на код, който показва грешка (404 и на горе), тя не прави нищо. Това може да се оправи при някои обстоятелства, но представете си да сложим показател “зареждане” на страницата, за да покаже, че не сме приключили с извличането на информация. Ако искането не успее, понеже сървърът се счупил или връзката прекъсва, страницата просто ще седи там, подвеждащо изглеждаща, че прави нещо там. Потребителя ще изчака известно време, нетърпелив да разгледа безполезно не завършения сайт.</p>
<p><a class="p_ident" id="p_GM6g10t1uS" href="./17_http.html#p_GM6g10t1uS"></a>Ние също трябва да имаме възможност да бъдем уведомени, когато искането не успее, така че да можем да предприемем съответните действия. Например, да отстраним съобщението за "зареждане" и да информираме потребителя, че нещо се е объркало.</p>
<p><a class="p_ident" id="p_qQG5mkGJ5M" href="./17_http.html#p_qQG5mkGJ5M"></a>Обработката на грешки в асинхронен код са още по-сложни, от колкото в синхронен код. Защото често се налага да се отложи част от работата, поставяйки я във функция за обратно извикване, обхвата на <code>try</code> блока става безсмислен. В сления код, изключението няма да се прихваща , защото извикването на <code>backgroundReadFile</code> се връща веднага. Control след това напуска <code>try</code> блока и функцията, която му е дадена, няма да бъде извикана по-късно.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_BOjAGQyuin" href="./17_http.html#c_BOjAGQyuin"></a><span class="cm-keyword">try</span> {
  <span class="cm-variable">backgroundReadFile</span>(<span class="cm-string">"example/data.txt"</span>, <span class="cm-keyword">function</span>(<span class="cm-def">text</span>) {
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">text</span> <span class="cm-operator">!=</span> <span class="cm-string">"expected"</span>)
      <span class="cm-keyword">throw</span> <span class="cm-keyword">new</span> <span class="cm-variable">Error</span>(<span class="cm-string">"That was unexpected"</span>);
  });
} <span class="cm-keyword">catch</span> (<span class="cm-def">e</span>) {
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"Hello from the catch block"</span>);
}</pre>
<p id="getURL"><a class="p_ident" id="p_ZP2klx8rqb" href="./17_http.html#p_ZP2klx8rqb"></a>За да се справим с липсата на заявки, трябва да позволим на допълнителна функция да бъде подадена в нашата обвивка и да я извикаме, когато заявката не е наред. Като алтернатива, можем да използваме конвенцията, че ако искането не успее, допълнителен аргумент описващ проблема се предава на редовната функция за обратно извикване. Ето един пример:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_eZVbiljj+e" href="./17_http.html#c_eZVbiljj+e"></a><span class="cm-keyword">function</span> <span class="cm-variable">getURL</span>(<span class="cm-def">url</span>, <span class="cm-def">callback</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">req</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">XMLHttpRequest</span>();
  <span class="cm-variable-2">req</span>.<span class="cm-property">open</span>(<span class="cm-string">"GET"</span>, <span class="cm-variable-2">url</span>, <span class="cm-atom">true</span>);
  <span class="cm-variable-2">req</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">"load"</span>, <span class="cm-keyword">function</span>() {
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">req</span>.<span class="cm-property">status</span> <span class="cm-operator">&lt;</span> <span class="cm-number">400</span>)
      <span class="cm-variable-2">callback</span>(<span class="cm-variable-2">req</span>.<span class="cm-property">responseText</span>);
    <span class="cm-keyword">else</span>
      <span class="cm-variable-2">callback</span>(<span class="cm-atom">null</span>, <span class="cm-keyword">new</span> <span class="cm-variable">Error</span>(<span class="cm-string">"Request failed: "</span> <span class="cm-operator">+</span>
                               <span class="cm-variable-2">req</span>.<span class="cm-property">statusText</span>));
  });
  <span class="cm-variable-2">req</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">"error"</span>, <span class="cm-keyword">function</span>() {
    <span class="cm-variable-2">callback</span>(<span class="cm-atom">null</span>, <span class="cm-keyword">new</span> <span class="cm-variable">Error</span>(<span class="cm-string">"Network error"</span>));
  });
  <span class="cm-variable-2">req</span>.<span class="cm-property">send</span>(<span class="cm-atom">null</span>);
}</pre>
<p><a class="p_ident" id="p_OwEcgNZRXQ" href="./17_http.html#p_OwEcgNZRXQ"></a>Ние добавихме манипулатор за <code>"error"</code> събитие, което ще сигнализира, когато искането не е успяло напълно. Също извикваме <em>callback</em> функцията с аргумент за грешка, когато заявката завърши със статус на код, който показва грешка.</p>
<p><a class="p_ident" id="p_nye9N1QULd" href="./17_http.html#p_nye9N1QULd"></a>Код използващ <code>getURL</code> после трябва да се провери дали е дал грешка и ако установи една да я манипулира.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_V6+MDOjkL1" href="./17_http.html#c_V6+MDOjkL1"></a><span class="cm-variable">getURL</span>(<span class="cm-string">"data/nonsense.txt"</span>, <span class="cm-keyword">function</span>(<span class="cm-def">content</span>, <span class="cm-def">error</span>) {
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">error</span> <span class="cm-operator">!=</span> <span class="cm-atom">null</span>)
    <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"Failed to fetch nonsense.txt: "</span> <span class="cm-operator">+</span> <span class="cm-variable-2">error</span>);
  <span class="cm-keyword">else</span>
    <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"nonsense.txt: "</span> <span class="cm-operator">+</span> <span class="cm-variable-2">content</span>);
});</pre>
<p><a class="p_ident" id="p_j4unfsTO1z" href="./17_http.html#p_j4unfsTO1z"></a>Това не помага, когато става дума за изключения. Когато оковем няколко асинхронни действия заедно във верига, изключението при всяка точка на веригата ще продължи (освен ако не увием всяка обработка на функцията в собствен <code>try/catch</code> блок) приземявайки се на първото ниво и прекратим действието на веригата.</p>
<h2 id="promises"><a class="h_ident" id="h_sdRy5CTAP/" href="./17_http.html#h_sdRy5CTAP/"></a>Promises  (обещания)</h2>
<p><a class="p_ident" id="p_v7YfQvxwuV" href="./17_http.html#p_v7YfQvxwuV"></a>За сложни проекти, писането на асинхронен код в обикновен <em>callback</em> стил е трудно за правене правилно. Лесно е да се забрави проверката за грешка или да се даде възможност на неочаквано изключение да скъси програмата по кратък суров начин. Освен това, организирането на правилното управление на грешки, когато грешката трябва да премине през множество функции за обратно извикване и <code>catch</code> блокове, е досадно.</p>
<p><a class="p_ident" id="p_mO96gXoG0q" href="./17_http.html#p_mO96gXoG0q"></a>Има много опити за решаване на това с допълнителни абстракции. Един от най-успешните се нарича <em>promises</em> (обещание). Обещанието увива асинхронните действия в обект, който може да бъде разпространен и казва да се направят някои неща, когато завърши действието или се провали. Този интерфейс е настроен да стане част от следващата версия на езика JavaScript, но вече може да се ползва, като библиотека.</p>
<p><a class="p_ident" id="p_HgVayjbMGB" href="./17_http.html#p_HgVayjbMGB"></a>Интерфейса за обещания не е съвсем интуитивен, но е мощен. Тази глава само грубо ще го опише. Можете да намерите по задълбочена тема на <a href="https://www.promisejs.org/"><em>www.promisejs.org</em></a>.</p>
<p><a class="p_ident" id="p_JxpiCLDcQ3" href="./17_http.html#p_JxpiCLDcQ3"></a>За да създадем един обект обещание ние извикваме <code>Promise</code> конструктора, давайки му функция, която инициализира асинхронно действие. Конструктора призовава тази функция подавайки и два аргумента, които сами по себе си са функции. Първият се извиква, когато действието приключи  успешно, а вторият се извиква, когато се провали.</p>
<p><a class="p_ident" id="p_WoWIWkMqow" href="./17_http.html#p_WoWIWkMqow"></a>За пореден път, тука е нашата обвивка за <code>GET</code> заявки, като този път връща обещание. Ние просто ще извикаме <code>get</code> този път.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_oGXXgqh698" href="./17_http.html#c_oGXXgqh698"></a><span class="cm-keyword">function</span> <span class="cm-variable">get</span>(<span class="cm-def">url</span>) {
  <span class="cm-keyword">return</span> <span class="cm-keyword">new</span> <span class="cm-variable">Promise</span>(<span class="cm-keyword">function</span>(<span class="cm-def">succeed</span>, <span class="cm-def">fail</span>) {
    <span class="cm-keyword">var</span> <span class="cm-def">req</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">XMLHttpRequest</span>();
    <span class="cm-variable-2">req</span>.<span class="cm-property">open</span>(<span class="cm-string">"GET"</span>, <span class="cm-variable-2">url</span>, <span class="cm-atom">true</span>);
    <span class="cm-variable-2">req</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">"load"</span>, <span class="cm-keyword">function</span>() {
      <span class="cm-keyword">if</span> (<span class="cm-variable-2">req</span>.<span class="cm-property">status</span> <span class="cm-operator">&lt;</span> <span class="cm-number">400</span>)
        <span class="cm-variable-2">succeed</span>(<span class="cm-variable-2">req</span>.<span class="cm-property">responseText</span>);
      <span class="cm-keyword">else</span>
        <span class="cm-variable-2">fail</span>(<span class="cm-keyword">new</span> <span class="cm-variable">Error</span>(<span class="cm-string">"Request failed: "</span> <span class="cm-operator">+</span> <span class="cm-variable-2">req</span>.<span class="cm-property">statusText</span>));
    });
    <span class="cm-variable-2">req</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">"error"</span>, <span class="cm-keyword">function</span>() {
      <span class="cm-variable-2">fail</span>(<span class="cm-keyword">new</span> <span class="cm-variable">Error</span>(<span class="cm-string">"Network error"</span>));
    });
    <span class="cm-variable-2">req</span>.<span class="cm-property">send</span>(<span class="cm-atom">null</span>);
  });
}</pre>
<p><a class="p_ident" id="p_RE/bEoSIjp" href="./17_http.html#p_RE/bEoSIjp"></a>Имайте в предвид, че интерфейса на самата функция е много по-прост. Можете да го дадете на URL и той да върне обещание. Това обещание действа, като искане за изход. То има <code>then</code> метод, който може да се извика с две функции: едната да обработва успех, а другата провал.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_6FFNJj/UTy" href="./17_http.html#c_6FFNJj/UTy"></a><span class="cm-variable">get</span>(<span class="cm-string">"example/data.txt"</span>).<span class="cm-property">then</span>(<span class="cm-keyword">function</span>(<span class="cm-def">text</span>) {
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"data.txt: "</span> <span class="cm-operator">+</span> <span class="cm-variable-2">text</span>);
}, <span class="cm-keyword">function</span>(<span class="cm-def">error</span>) {
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"Failed to fetch data.txt: "</span> <span class="cm-operator">+</span> <span class="cm-variable-2">error</span>);
});</pre>
<p><a class="p_ident" id="p_4O6znqfcpb" href="./17_http.html#p_4O6znqfcpb"></a>За сега това е още един начин да се изрази същото нещо, което вече изразихме. Но това е само, когато ни трябват верижни действия заедно, обещанията правят значителна разлика.</p>
<p><a class="p_ident" id="p_uiJcYJELKb" href="./17_http.html#p_uiJcYJELKb"></a>Извиквайки <code>then</code> произвежда ново обещание, чийто резултат (стойността подадена към <em>success</em> манипулатора) зависи от стойността върната от първата функция подадена към <code>then</code>. Тази функция може да върне друго обещание за да покаже, че се върши повече асинхронна работа. В този случай, обещанието върнато от <code>then</code>, само ще чака обещанието върнато от функцията манипулатор, успяващо или провалящо се със същата стойност, когато и е разрешено. Когато функцията манипулатор връща <em>nonpromise</em> стойност, обещанието върнато от <code>then</code> веднага успява с тази стойност, като свой резултат.</p>
<p><a class="p_ident" id="p_wC6ZA4AmWr" href="./17_http.html#p_wC6ZA4AmWr"></a>Това означава, че можем да използваме <code>then</code> да се превърне в резултат на обещание. Например, това връща обещание, чийто резултат е съдържанието на даден URL адрес, анализиран с JSON:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_iYJTxgzQ/r" href="./17_http.html#c_iYJTxgzQ/r"></a><span class="cm-keyword">function</span> <span class="cm-variable">getJSON</span>(<span class="cm-def">url</span>) {
  <span class="cm-keyword">return</span> <span class="cm-variable">get</span>(<span class="cm-variable-2">url</span>).<span class="cm-property">then</span>(<span class="cm-variable">JSON</span>.<span class="cm-property">parse</span>);
}</pre>
<p><a class="p_ident" id="p_Cpzqy849cD" href="./17_http.html#p_Cpzqy849cD"></a>Последното извикване на <code>then</code> не определи провал на манипулатора. Той е позволен. Грешката ще бъде приета от обещанието върнато от <code>then</code>, което е точно това, което искаме - <code>getJSON</code> не знае какво да прави ако нещо се обърка, но се надяваме, че извикващия го прави.</p>
<p><a class="p_ident" id="p_xh6XPjbZAz" href="./17_http.html#p_xh6XPjbZAz"></a>Като пример, който показва използването на обещания, ние ще изградим една програма, която извлича редица JSON файлове от сървъра и докато го прави показва думата <em>loading</em>. Файловете с JSON съдържат информация за хората с линкове към файлове, които представляват други хора в свойства, като <code>father</code>, <code>mother</code> или <code>spouse</code>.</p>
<p><a class="p_ident" id="p_JBcCWCd0HV" href="./17_http.html#p_JBcCWCd0HV"></a>Искаме да получим името на майката на съпруга от <em>example/bert.json</em>. И ако нещо се обърка, искаме да се премахне текста <em>loading</em> и вместо него да се покаже съобщение за грешка. Ето как, това може да бъде направено с обещания:</p>
<pre data-language="text/html" class="snippet cm-s-default"><a class="c_ident" id="c_+S6hPuikm/" href="./17_http.html#c_+S6hPuikm/"></a><span class="cm-tag cm-bracket">&lt;</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span>
  <span class="cm-keyword">function</span> <span class="cm-variable">showMessage</span>(<span class="cm-def">msg</span>) {
    <span class="cm-keyword">var</span> <span class="cm-def">elt</span> <span class="cm-operator">=</span> <span class="cm-variable">document</span>.<span class="cm-property">createElement</span>(<span class="cm-string">"div"</span>);
    <span class="cm-variable-2">elt</span>.<span class="cm-property">textContent</span> <span class="cm-operator">=</span> <span class="cm-variable-2">msg</span>;
    <span class="cm-keyword">return</span> <span class="cm-variable">document</span>.<span class="cm-property">body</span>.<span class="cm-property">appendChild</span>(<span class="cm-variable-2">elt</span>);
  }

  <span class="cm-keyword">var</span> <span class="cm-variable">loading</span> <span class="cm-operator">=</span> <span class="cm-variable">showMessage</span>(<span class="cm-string">"Loading..."</span>);
  <span class="cm-variable">getJSON</span>(<span class="cm-string">"example/bert.json"</span>).<span class="cm-property">then</span>(<span class="cm-keyword">function</span>(<span class="cm-def">bert</span>) {
    <span class="cm-keyword">return</span> <span class="cm-variable">getJSON</span>(<span class="cm-variable-2">bert</span>.<span class="cm-property">spouse</span>);
  }).<span class="cm-property">then</span>(<span class="cm-keyword">function</span>(<span class="cm-def">spouse</span>) {
    <span class="cm-keyword">return</span> <span class="cm-variable">getJSON</span>(<span class="cm-variable-2">spouse</span>.<span class="cm-property">mother</span>);
  }).<span class="cm-property">then</span>(<span class="cm-keyword">function</span>(<span class="cm-def">mother</span>) {
    <span class="cm-variable">showMessage</span>(<span class="cm-string">"The name is "</span> <span class="cm-operator">+</span> <span class="cm-variable-2">mother</span>.<span class="cm-property">name</span>);
  }).<span class="cm-property">catch</span>(<span class="cm-keyword">function</span>(<span class="cm-def">error</span>) {
    <span class="cm-variable">showMessage</span>(<span class="cm-variable">String</span>(<span class="cm-variable-2">error</span>));
  }).<span class="cm-property">then</span>(<span class="cm-keyword">function</span>() {
    <span class="cm-variable">document</span>.<span class="cm-property">body</span>.<span class="cm-property">removeChild</span>(<span class="cm-variable">loading</span>);
  });
<span class="cm-tag cm-bracket">&lt;/</span><span class="cm-tag">script</span><span class="cm-tag cm-bracket">&gt;</span></pre>
<p><a class="p_ident" id="p_jx/D3dcS2W" href="./17_http.html#p_jx/D3dcS2W"></a>Получената програма е сравнително компактна и разбираема. Методът <code>catch</code> е подобен на <code>then</code> с изключение на това, че очаква само манипулатор за провал и ще премине през резултата непроменен в случай на успех. Много прилича на 
<code>catch</code> клаузата за <code>try</code> отчета, контролът ще продължи нормално, след като провалът е прихванат. По този начин, финалния <code>then</code>, който премахва <em>loading</em>  съобщението, винаги ще се изпълнява дори ако нещо се обърка.</p>
<p><a class="p_ident" id="p_8DILWnDxzH" href="./17_http.html#p_8DILWnDxzH"></a>Можете да мислите за интерфейса на обещанието, като изпълнение на собствения му език за асинхронен контрол на потока. Допълнителният метод извиква и функции изрази (<em>expressions</em>) необходими за постигане на това, което прави кода да изглежда малко неудобен, но малко по-неудобен от това да изглежда, че се грижи за всичките грешки на работата си.</p>
<h2><a class="h_ident" id="h_OJmHENDG5y" href="./17_http.html#h_OJmHENDG5y"></a>Оценяване  на  HTTP</h2>
<p><a class="p_ident" id="p_dVrq2xCOfJ" href="./17_http.html#p_dVrq2xCOfJ"></a>При изграждането на системата, която изисква комуникация между програмата на JavaScript работеща в браузъра (от страна на клиента) и програмата на сървъра (от страна на сървъра) има няколко различни начина, с които да се моделира тази комуникация.</p>
<p><a class="p_ident" id="p_f4x0TdEU2h" href="./17_http.html#p_f4x0TdEU2h"></a>Най-често използваният модел е този на отдалечено повикване на процедури. В този модел, комуникацията следва моделите на нормалните извиквания на функции, само че функцията работи на друга машина. Извикването съдържа подаване на заявка до сървъра, която включва името и аргументите на функциите. Отговора на това искане съдържа върнатата стойност.</p>
<p><a class="p_ident" id="p_7z+OqsDVUu" href="./17_http.html#p_7z+OqsDVUu"></a>Когато мислим от гледна точка на отдалеченото извикване на процедури, HTTP е просто средство за комуникация и най-вероятно ще напишете слой на абстракция, който да го скрива изцяло.</p>
<p><a class="p_ident" id="p_dOvEvBngFh" href="./17_http.html#p_dOvEvBngFh"></a>Друг подход е да изградим наша комуникация около концепциите за ресурсите и HTTP методите. Вместо отдалечена процедура, наречена <code>addUser</code>, ще използваме <code>PUT</code> заявка до <code>/users/larry</code>. Вместо кодирани потребителски свойства в аргументите на функцията, ще дефинираме формат на документ или ще използваме съществуващ формат, който представлява потребител. Тялото на <code>PUT</code> заявката за създаване на нов ресурс е просто такъв документ. Ресурсът е пресилен, като се прави <code>GET</code> заявка до URL ресурса (например, <code>/user/larry</code>), който връща документ представляващ ресурса.</p>
<p><a class="p_ident" id="p_6PHqO+Vd0H" href="./17_http.html#p_6PHqO+Vd0H"></a>В този втори подход е по-лесно да използвате някои от функциите, които предлага HTTP, като подкрепа за кеширане (складиране) на ресурси (запазване на копие от страна на клиента). Той може да помогне също за съгласуваноста на вашия интерфейс, тъй като ресурсите са по-лесни за разбиране в сравнение с плетеница от функции.</p>
<h2><a class="h_ident" id="h_oDqIFugKX4" href="./17_http.html#h_oDqIFugKX4"></a>Сигурност  и  HTTP</h2>
<p><a class="p_ident" id="p_YUIH84Ok2d" href="./17_http.html#p_YUIH84Ok2d"></a>Данните пътуващи по Интернет имат тенденцията да следват дълъг и опасен път. За да стигнат местоназначението си, те трябва да се качат през някоя от свободните мрежи и да преминат през мрежи контролирани от различни компании и държави. Във всеки един момент по своя маршрут те могат да бъдат инспектирани или дори модифицирани.</p>
<p><a class="p_ident" id="p_FkVKmUiG/R" href="./17_http.html#p_FkVKmUiG/R"></a> Ако това са важни неща, които трябва да останат в тайна, като паролата за вашия емайл акаунт или да стигнат местоназначението си непроменени, като например номера на сметката ви за превод на пари в уеб-сайта на банката, обикновен HTTP не е достатъчно добър.</p>
<p><a class="p_ident" id="p_s1KEZa2j+E" href="./17_http.html#p_s1KEZa2j+E"></a>Защитен HTTP протокол, чийто URL адреси започват с <em>https://</em> опаковайки по този начин HTTP трафика го прави по-труден за четене и фалшифициране. Първо клиента потвърждава, че е сървърът за който се твърди и изисква от този сървър да докаже, че разполага с крипторафско удостоверение издадено от орган за удостоверения, които браузърът разпознава. На следващо място, всички данни преминават през криптираната връзка по начин, който да предотврати подслушване и подправяне.</p>
<p><a class="p_ident" id="p_whG/pc2PK4" href="./17_http.html#p_whG/pc2PK4"></a>По този начин, когато работи добре HTTPS пречи на подмяната на сайта с друг, както и подслушването на вашата комуникация. Той не е съвършен, има различни инциденти, където HTTPS се е провалял заради фалшиви или откраднати удостоверения и счупен софтуер. И все пак, обикновен HTTP е тривиална бъркотия, докато HTTPS за да се счупи изисква усилия, които само държави или сложни престъпни организации могат да направят.</p>
<h2><a class="h_ident" id="h_ErccPg/l98" href="./17_http.html#h_ErccPg/l98"></a>Резюме</h2>
<p><a class="p_ident" id="p_9mkfl3ctRV" href="./17_http.html#p_9mkfl3ctRV"></a>В тази глава видяхме, че HTTP е протокол за достъп до ресурси в Интернет. Клиентът изпраща заявка, която съдържа метод (обикновено <code>GET</code>) и път, който индентифицира ресурс. Сървърът решава, какво да прави с искането и реагира със статус код и отговор с тяло. Заявките и отговорите могат да съдържат заглавия, които предоставят допълнителна информация.</p>
<p><a class="p_ident" id="p_QYlJoeSssL" href="./17_http.html#p_QYlJoeSssL"></a>Браузърите правят <code>GET</code> заявки за получаване на ресурсите необходими за показването на уеб страницата. Уеб страницата може да съдържа форми, които позволяват информация въведена от потребителя да бъде изпратена заедно с искането отправено в момента на подаване на формуляра. Ще научите за това повече в <a href="./18_forms.html#forms">следващата глава</a>.</p>
<p><a class="p_ident" id="p_taYkCAtnud" href="./17_http.html#p_taYkCAtnud"></a>Интерфейса, чрез който браузъра на JavaScript може да направи HTTP заявки се нарича <code>XMLHttpRequest</code>. Обикновено можем да игнорираме XML  частта на това име (но то все още трябва да се  пише). Има два начина, по които може да се използва - синхронен, който блокира всичко докато искането завърши и асинхронен, който изисква боравене със събития за да разберем, че отговорът е дошъл. В почти всички случаи асинхронния начин е за предпочитане. Осъществяването на искане изглежда така:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_8UQ332N0tS" href="./17_http.html#c_8UQ332N0tS"></a><span class="cm-keyword">var</span> <span class="cm-variable">req</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">XMLHttpRequest</span>();
<span class="cm-variable">req</span>.<span class="cm-property">open</span>(<span class="cm-string">"GET"</span>, <span class="cm-string">"example/data.txt"</span>, <span class="cm-atom">true</span>);
<span class="cm-variable">req</span>.<span class="cm-property">addEventListener</span>(<span class="cm-string">"load"</span>, <span class="cm-keyword">function</span>() {
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">req</span>.<span class="cm-property">status</span>);
});
<span class="cm-variable">req</span>.<span class="cm-property">send</span>(<span class="cm-atom">null</span>);</pre>
<p><a class="p_ident" id="p_+TkoeLUgPt" href="./17_http.html#p_+TkoeLUgPt"></a>Асинхронното програмиране е трудно. Обещанието за интерфейс го прави малко по-лесно, като помага пътя на условията за грешки и изключения да мине през правилния манипулатор и чрез абстрахиране далеч на някои от най-повтарящите се грешки и предразположените към грешки елементи в този стил на програмиране.</p>
<h2><a class="h_ident" id="h_TcUD2vzyMe" href="./17_http.html#h_TcUD2vzyMe"></a>Упражнения</h2>
<h3 id="exercise_accept"><a class="h_ident" id="h_uaWwL8WGXf" href="./17_http.html#h_uaWwL8WGXf"></a>Content  преговори</h3>
<p><a class="p_ident" id="p_4RSIQjkFSG" href="./17_http.html#p_4RSIQjkFSG"></a>Едно от нещата, които могат да направят HTTP но не сме обсъдили в тази глава се нарича многоезично съдържание. Заглавието <code>Accept</code> за искане може да се използва за да каже на сървъра, какъв тип документ би искал да получи клиента. Много сървъри игнорират това заглавие, но когато сървърът знае различни начини за кодиране на ресурси, той може да погледне това заглавие и да изпрати този ресурс, който клиента предпочита.</p>
<p><a class="p_ident" id="p_o+GIbRSLtv" href="./17_http.html#p_o+GIbRSLtv"></a>URL <a href="./author"><em>eloquentjavascript.net/author</em></a> e конфигуриран да отговори  в  прав текст, HTML или JSON в зависимост от това, което клиента иска. Тези формати са идентифицирани чрез стандартизирането на типовете входове  <code>text/plain</code>, <code>text/html</code> и <code>application/json</code>.</p>
<p><a class="p_ident" id="p_uUUGBBkyGq" href="./17_http.html#p_uUUGBBkyGq"></a>Изпрати искания за получаване на трите формата на този ресурс. Използвайте метода <code>setRequestHeader</code> във вашия <code>XMLHttpRequest</code> обект, за да настроите заглавието <code>Accept</code> към един от видовете входове дадени по-рано. Уверете се, че сте задали заглавието след извикването на <code>open</code> , но преди да извикате <code>send</code>.</p>
<p><a class="p_ident" id="p_ydN7YyErvr" href="./17_http.html#p_ydN7YyErvr"></a>И накрая, опитайте да попитате приложението с <code>application/rainbows+unicorns</code> и вижте какво ще стане.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_CfkOp8tkUe" href="./17_http.html#c_CfkOp8tkUe"></a><span class="cm-comment">// Your code here.</span></pre>
<div class="solution"><div class="solution-text">
<p><a class="p_ident" id="p_TNktXshv5h" href="./17_http.html#p_TNktXshv5h"></a>Вижте различните примери за използване на <code>XMLHttpRequest</code> в тази глава, за модел на метод за извикванията, участващ в изграждането на искане. Можете да използвате синхронно искане (чрез определяне на трети параметър to <code>open</code> to
<code>false</code>), ако искате.</p>
<p><a class="p_ident" id="p_rvMQauDbd6" href="./17_http.html#p_rvMQauDbd6"></a>Питането за фалшив тип носител ще върне отговор с код 406 "Не се приема.", което е кода на сървъра, който трябва да върне, когато не може да изпълни заглавието <code>Accept</code>.</p>
</div></div>
<h3><a class="h_ident" id="h_MlI+KUOVBK" href="./17_http.html#h_MlI+KUOVBK"></a>Очакване на множество обещания</h3>
<p><a class="p_ident" id="p_bjI0ituzCO" href="./17_http.html#p_bjI0ituzCO"></a>Конструктора <code>Promise</code> има метод <code>all</code>, който при даден масив от обещания, връща обещание, което чака заедно с всички обещания в масива да бъде завършено. След като успее, дава масив със стойностите на резултатите. Ако някое обещание в масива се провали, върнатото обещание от <code>all</code> се проваля също (със стойността на неизпълнение на проваленото обещание).</p>
<p><a class="p_ident" id="p_aWPI8r+IIn" href="./17_http.html#p_aWPI8r+IIn"></a>Опитайте да приложите нещо подобно, като ваша редовна функция извикана върху всички.</p>
<p><a class="p_ident" id="p_n5BsvIT7F5" href="./17_http.html#p_n5BsvIT7F5"></a>Имайте в предвид, че след като обещанието е определено (с успех или провал), то не може да бъде успешно и неуспешно отново и по-нататъшни разговори с функциите, които го решават се игнорират. Това може да опрости начина, по който да се справите с провал на обещанията.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_GcukQjvcmk" href="./17_http.html#c_GcukQjvcmk"></a><span class="cm-keyword">function</span> <span class="cm-variable">all</span>(<span class="cm-def">promises</span>) {
  <span class="cm-keyword">return</span> <span class="cm-keyword">new</span> <span class="cm-variable">Promise</span>(<span class="cm-keyword">function</span>(<span class="cm-def">success</span>, <span class="cm-def">fail</span>) {
    <span class="cm-comment">// Your code here.</span>
  });
}

<span class="cm-comment">// Test code.</span>
<span class="cm-variable">all</span>([]).<span class="cm-property">then</span>(<span class="cm-keyword">function</span>(<span class="cm-def">array</span>) {
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"This should be []:"</span>, <span class="cm-variable-2">array</span>);
});
<span class="cm-keyword">function</span> <span class="cm-variable">soon</span>(<span class="cm-def">val</span>) {
  <span class="cm-keyword">return</span> <span class="cm-keyword">new</span> <span class="cm-variable">Promise</span>(<span class="cm-keyword">function</span>(<span class="cm-def">success</span>) {
    <span class="cm-variable">setTimeout</span>(<span class="cm-keyword">function</span>() { <span class="cm-variable-2">success</span>(<span class="cm-variable-2">val</span>); },
               <span class="cm-variable">Math</span>.<span class="cm-property">random</span>() <span class="cm-operator">*</span> <span class="cm-number">500</span>);
  });
}
<span class="cm-variable">all</span>([<span class="cm-variable">soon</span>(<span class="cm-number">1</span>), <span class="cm-variable">soon</span>(<span class="cm-number">2</span>), <span class="cm-variable">soon</span>(<span class="cm-number">3</span>)]).<span class="cm-property">then</span>(<span class="cm-keyword">function</span>(<span class="cm-def">array</span>) {
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"This should be [1, 2, 3]:"</span>, <span class="cm-variable-2">array</span>);
});
<span class="cm-keyword">function</span> <span class="cm-variable">fail</span>() {
  <span class="cm-keyword">return</span> <span class="cm-keyword">new</span> <span class="cm-variable">Promise</span>(<span class="cm-keyword">function</span>(<span class="cm-def">success</span>, <span class="cm-def">fail</span>) {
    <span class="cm-variable-2">fail</span>(<span class="cm-keyword">new</span> <span class="cm-variable">Error</span>(<span class="cm-string">"boom"</span>));
  });
}
<span class="cm-variable">all</span>([<span class="cm-variable">soon</span>(<span class="cm-number">1</span>), <span class="cm-variable">fail</span>(), <span class="cm-variable">soon</span>(<span class="cm-number">3</span>)]).<span class="cm-property">then</span>(<span class="cm-keyword">function</span>(<span class="cm-def">array</span>) {
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"We should not get here"</span>);
}, <span class="cm-keyword">function</span>(<span class="cm-def">error</span>) {
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">error</span>.<span class="cm-property">message</span> <span class="cm-operator">!=</span> <span class="cm-string">"boom"</span>)
    <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"Unexpected failure:"</span>, <span class="cm-variable-2">error</span>);
});</pre>
<div class="solution"><div class="solution-text">
<p><a class="p_ident" id="p_zV4HNd52Ay" href="./17_http.html#p_zV4HNd52Ay"></a>Функцията подадена към <code>Promise</code> конструктора ще трябва да се извика <code>then</code> (след), като всяко от обещанията е в дадения масив. Когато едно от тях успява, трябва да се случат две неща. Получената стойност трябва да се съхранява на правилната позиция в масива на резултата и ние трябва да проверим дали това е последното очаквано обещание и да завършим нашето собствено обещание, ако е това.</p>
<p><a class="p_ident" id="p_gVL8VQtmdx" href="./17_http.html#p_gVL8VQtmdx"></a>Последното може да се направи с брояч, който се инициализира по дължината на входящия масив и от който се изважда едно всеки път, когато обещание успява. Когато той достигне 0, ние сме се справили. Уверете се, че сте взели под внимание ситуация, в която входящия масив е празен (и по този начин, ако няма обещание никога няма да позволи).</p>
<p><a class="p_ident" id="p_xLxIRNCHYI" href="./17_http.html#p_xLxIRNCHYI"></a>Обработката на провала изисква малко размисъл, но се оказва изключително проста. Просто подайте функцията на провала към обещанието опаковащо всички обещания в масива, така че провала на едно от тях води до провал на цялата обвивка.</p>
</div></div>
<nav>
  <a href="./16_canvas.html" title="previous chapter">◀</a>
  <a href="./index.html" title="cover">◆</a>
  <a href="./18_forms.html" title="next chapter">▶</a>
</nav>
</article>
</body></html>