<!DOCTYPE html>
<!-- saved from url=(0042)./04_data.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <title>Data Structures: Objects and Arrays :: Eloquent JavaScript</title>
  <link rel="stylesheet" href="./media/codemirror.css">
  <script src="./media/acorn_codemirror.js"></script>
  <link rel="stylesheet" href="./media/ejs.css">
  <script src="./media/sandbox.js"></script>
  <script src="./media/ejs.js"></script>
  <script>var chapNum = 4;var sandboxLoadFiles = ["code/jacques_journal.js", "code/chapter/04_data.js"];</script>
</head>

<body><article>
<nav>
  <a href="./03_functions.html" title="previous chapter">◀</a>
  <a href="./index.html" title="cover">◆</a>
  <a href="./05_higher_order.html" title="next chapter">▶</a>
</nav>

<h1><div class="chap_num">Глава 4</div>Структури от данни: Обекти и масиви</h1>
<blockquote>
<p><a class="p_ident" id="p_3DGxnMhaad" href="./04_data.html#p_3DGxnMhaad"></a>На два пъти съм бил питан, „Умоляваме ви, г-н Бабидж, ако поставим грешните данни в машината, ще излязат ли правилните отговори? […]“ Аз не съм в състояние правилно да схвана вида на обърканите идеи, които биха могли да провокират такъв въпрос”</p>
 <footer>Charles Babbage, <cite>Пасажи от живота на един философ(1864)</cite></footer>
</blockquote>
<p><a class="p_ident" id="p_j/UjCN3npi" href="./04_data.html#p_j/UjCN3npi"></a><em>Numbers, Booleans</em> и <em>strings</em> са тухлите, от които структурите от данни са компилирани. Но не можем да построим цяла къща с една- единствена тухла. <em>Objects</em> (обекти) ни позволяват да групираме стойности - включително и други <em>objects</em> - заедно и по този начин да изградим по-сложни структури.</p>
<p><a class="p_ident" id="p_TT9r8Cr1W0" href="./04_data.html#p_TT9r8Cr1W0"></a>Програмите, които сме правили до сега са били сериозно затруднени от факта, че са действали само върху прости типове данни. Тази глава ще добави основно разбиране на структури от данни в нашия инструментариум. До края на тази глава вие ще знаете достатъч но, за да започнете да пишете някои полезни програми.</p>
<p><a class="p_ident" id="p_vL8agXHSiL" href="./04_data.html#p_vL8agXHSiL"></a>Ще работите преминавайки през повече или по-реалистично програмиране, въвеждане на понятия, които се прилагат към разглежданите проблеми. Например кодът, често ще се основава на функции и променливи, които бяха въведени по-рано в текста.</p>
<h2><a class="h_ident" id="h_NvjtahQLlw" href="./04_data.html#h_NvjtahQLlw"></a>The weresquirrel</h2>
<p><a class="p_ident" id="p_2uQlDOT3CH" href="./04_data.html#p_2uQlDOT3CH"></a>Винаги, сега и тогава, обикновено между осем и десет вечерта, Жак се озоваваше трансформиран в малък космат гризач с пухкава опашка.</p>
<p><a class="p_ident" id="p_EIDMzKWaqr" href="./04_data.html#p_EIDMzKWaqr"></a>От една страна, Жак беше доста доволен, че няма класическа ликантропия. Превъплащението в катерица имаше тенденцията да предизвиква по-малко проблеми, от колкото да се превърне във вълк, например. Вместо да се налага да се притеснява за случайно изяждане на съседа(това би било неловко), той се притесняваше да не бъде изяден от котката на съседа. След два случая, когато той се събуди върху несигурно тънък клон в короната на един дъб, гол и дезориентриран, той предприе да заключва вратите и прозорците на стаята си през нощта и пускаше няколко ореха на пода, за да държи себе си зает.</p>
<div class="image">
  <img src="./media/weresquirrel.png" alt="The weresquirrel">
</div>
<p><a class="p_ident" id="p_mMWZqiA+i1" href="./04_data.html#p_mMWZqiA+i1"></a>Това трябваше да се погрижи за проблемите с котката и дъба. Но Жак все още страдаше от състоянието си. Нередовните случаи на трансформация го караха да се съмнява, че тя може да се задейства от нещо. За известно време той вярваше, че това се случва само в дните, когато е докосвал дървета. Така че, той спря да докосва изцяло дървета и дори избягваше случайна близост със тях. Но проблемът продължаваше да съществува.</p>
<p><a class="p_ident" id="p_I4RF6opRCC" href="./04_data.html#p_I4RF6opRCC"></a>Преминавайки към по-научен подход, Жак възнамеряваше да започне воденето на дневник за всичко, което той е правил този ден и дали това променя формата. С тази информация, се надяваше да стесни условията, които задействат трансформациите.</p>
<p><a class="p_ident" id="p_WERwFzJu93" href="./04_data.html#p_WERwFzJu93"></a>Първото нещо, което направи - проектира структура от данни, за да съхранява информацията.</p>
<h2><a class="h_ident" id="h_HjL/otjEJn" href="./04_data.html#h_HjL/otjEJn"></a>Набор от данни</h2>
<p><a class="p_ident" id="p_HFLfyQFSDp" href="./04_data.html#p_HFLfyQFSDp"></a>За да може да работим с парче цифрови данни, ние първо трябва да намерим начин да ги представим в паметта на нашата машина. Ето един прост пример, искаме да представим набор от цифри: 2, 3, 5, 7 и 11.</p>
<p><a class="p_ident" id="p_cnzv4pg+Wz" href="./04_data.html#p_cnzv4pg+Wz"></a>Бихме могли да ги представим творчески със <em>strings</em>, в края на краищата, <em>strings</em> могат да бъдат с всякаква дължина, така че можем да поставим много данни в тях и да ги представим по следния начин  <code>"2 3 5 7 11"</code>. Но това е неудобно. Ще трябва някак да извлечем цифрите и да ги конвертираме обратно в номера за да имаме достъп до тях.</p>
<p><a class="p_ident" id="p_/aFILq7bDn" href="./04_data.html#p_/aFILq7bDn"></a>За щастие, JavaScript  осигурява начин специално за съхранение на поредици от стойности. Той се нарича масив и е написан, като списък от стойности между квадратни скоби, разделени със запетаи.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_WrRipN2I5z" href="./04_data.html#c_WrRipN2I5z"></a><span class="cm-keyword">var</span> <span class="cm-variable">listOfNumbers</span> <span class="cm-operator">=</span> [<span class="cm-number">2</span>, <span class="cm-number">3</span>, <span class="cm-number">5</span>, <span class="cm-number">7</span>, <span class="cm-number">11</span>];
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">listOfNumbers</span>[<span class="cm-number">1</span>]);
<span class="cm-comment">// → 3</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">listOfNumbers</span>[<span class="cm-number">1</span> <span class="cm-operator">-</span> <span class="cm-number">1</span>]);
<span class="cm-comment">// → 2</span></pre>
<p><a class="p_ident" id="p_xu5bhsrvS2" href="./04_data.html#p_xu5bhsrvS2"></a>Системата за отбелязване и получаване на елементите вътре в масива също използва квадратни скоби. Чифт квадратни скоби веднага след израз с друг израз вътре в тях, вижда елементите в израза от лявата страна, които съответстват на индекса даден от израза в скобите.</p>
<p id="array_indexing"><a class="p_ident" id="p_i4f1iEZJFW" href="./04_data.html#p_i4f1iEZJFW"></a>Първият индекс в масива е нула, не едно. Така че, първият елемент може да се вземе с <code>listOfNumbers[0]</code>. Ако нямате познания в програмирането, тази конвенция може да отнеме известно привикване. Нулевата база за преброяване има дълга традиция в областта на технологиите, и стига да бъде следвана последователно (както в JavaScript ), то тя работи добре.</p>
<h2 id="properties"><a class="h_ident" id="h_vGyI2y8HA6" href="./04_data.html#h_vGyI2y8HA6"></a>Свойства</h2>
<p><a class="p_ident" id="p_N/KiJ+p6sy" href="./04_data.html#p_N/KiJ+p6sy"></a>Видяхме няколко подозрителни израза, като <code>myString.length</code> (за да получим дължината на <em>string</em>) и <code>Math.max</code> (максимум функция) в последните примери. Това са изрази, които имат достъп до свойствата на някаква стойност. В първия случай имаме достъп до свойството <code>length</code> на стойността в <code>myString</code>. Във втория, достъп до свойството  <code>max</code> в <code>Math</code> обекта (който е колекция от математически свързани стойности и функции).</p>
<p><a class="p_ident" id="p_dTOk+Nu/lR" href="./04_data.html#p_dTOk+Nu/lR"></a>Почти всички стойности на JavaScript имат свойства. Изключение правят <code>null</code> и <code>undefined</code>. Ако се опитате да получите достъп до свойствата на една от тези <em>nonvalues</em>, ще получите съобщение за грешка.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_ZEvFsOQLc8" href="./04_data.html#c_ZEvFsOQLc8"></a><span class="cm-atom">null</span>.<span class="cm-property">length</span>;
<span class="cm-comment">// → TypeError: Cannot read property 'length' of null</span></pre>
<p><a class="p_ident" id="p_etK6gD7WXZ" href="./04_data.html#p_etK6gD7WXZ"></a>Двата най-често срещани начина за достъп до свойства в JavaScript са точка или квадратни скоби. И двете <code>value.x</code> и <code>value[x]</code> са достъп до свойството <code>value</code> - но не са задължително същото свойство. Разликата е в това, как се тълкува <code>x</code>. При израза с точка, частта след точката трябва да е валидно име на променлива и получавате директно името на свойството. При ползване на квадратни скоби, изразът между скобите се оценява, за да получите името на свойството. Какво имам в предвид, <code>value.x</code> извлича свойството <code>value</code> с име  “x”, а <code>value[x]</code> се опитва да направи оценка на израза <code>x</code> и използва резултата, като име на свойство.</p>
<p><a class="p_ident" id="p_tcrruPP6JD" href="./04_data.html#p_tcrruPP6JD"></a>Така че ако знаете, че свойството, което ви интересува се нарича “дължина” вие казвате <code>value.length</code>. Ако искате да извлечете свойството на израза от името на стойността на променливата <code>i</code>, вие казвате <code>value[i]</code>. И тъй като, име на свойството може да бъде всеки <em>string</em>, ако искате да получите достъп до името на това свойство на “2”или “John Doe”, трябва да използвате квадратни скоби: 
<code>value[2]</code> или <code>value["John Doe"]</code>. Така се прави, въпреки, че знаете името на свойството предварително. Нито “2”, нито “John Doe” са валидно име на променлива и за това не могат да бъдат достъпни чрез точкова нотация.</p>
<p><a class="p_ident" id="p_d0vwHo1UJ1" href="./04_data.html#p_d0vwHo1UJ1"></a>Елементите в масив са съхранени в свойства. Тъй като, имената на тези свойства са числа, а ние често трябва да получим името му от една променлива, трябва да използваме синтаксиса на скобите, за да имаме достъп до тях. Свойството <code>length</code> на масив ни казва колко елемента съдържа. Това име на свойство е валидно име на променлива, а ние знаем това име от по-рано, така че за да се намери дължината на масив, обикновено пишем <code>array.length</code> защото това е по-лесно да се напише, от колкото <code>array["length"]</code>.</p>
<h2 id="methods"><a class="h_ident" id="h_fkrGgDyRWc" href="./04_data.html#h_fkrGgDyRWc"></a>Методи</h2>
<p><a class="p_ident" id="p_1Q3NM3X6G3" href="./04_data.html#p_1Q3NM3X6G3"></a>И двата - <em>string</em> и масива обект, съдържат в допълнение към свойството <code>length</code>, редица свойства, които се отнасят за функционирането на стойностите.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_Crc8UwFnzX" href="./04_data.html#c_Crc8UwFnzX"></a><span class="cm-keyword">var</span> <span class="cm-variable">doh</span> <span class="cm-operator">=</span> <span class="cm-string">"Doh"</span>;
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-keyword">typeof</span> <span class="cm-variable">doh</span>.<span class="cm-property">toUpperCase</span>);
<span class="cm-comment">// → function</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">doh</span>.<span class="cm-property">toUpperCase</span>());
<span class="cm-comment">// → DOH</span></pre>
<p><a class="p_ident" id="p_EmYOwg/BO9" href="./04_data.html#p_EmYOwg/BO9"></a>Всеки <em>string</em> има <code>toUpperCase</code> свойство. Когато се извика, то ще върне копие на <em>string</em>-а, в което всички букви ще са превърнати в главни букви. Също така има и  <code>toLowerCase</code>. Може да се досетите какво означава това.</p>
<p><a class="p_ident" id="p_lNzNM3PoU4" href="./04_data.html#p_lNzNM3PoU4"></a>Интересно е, че въпреки извикването на <code>toUpperCase</code>, то не минава през всички аргументи, функцията по някакъв начин има достъп до стойността на <code>string ”Doh”</code>, чието свойство извикахме. Как става това е описано в <a href="./06_object.html#obj_methods">Глава 6</a>.</p>
<p><a class="p_ident" id="p_gvO150ZgOs" href="./04_data.html#p_gvO150ZgOs"></a>Свойства, които съдържат функции обикновено се наричат методи на стойността към която са извикани. Както “<code>toUpperCase</code> е метод на <em>string</em>”.</p>
<p id="array_methods"><a class="p_ident" id="p_FALcpD+CSn" href="./04_data.html#p_FALcpD+CSn"></a>Този пример показва някои методи за масиви, които имат:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_Ymu7GdxtdT" href="./04_data.html#c_Ymu7GdxtdT"></a><span class="cm-keyword">var</span> <span class="cm-variable">mack</span> <span class="cm-operator">=</span> [];
<span class="cm-variable">mack</span>.<span class="cm-property">push</span>(<span class="cm-string">"Mack"</span>);
<span class="cm-variable">mack</span>.<span class="cm-property">push</span>(<span class="cm-string">"the"</span>, <span class="cm-string">"Knife"</span>);
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">mack</span>);
<span class="cm-comment">// → ["Mack", "the", "Knife"]</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">mack</span>.<span class="cm-property">join</span>(<span class="cm-string">" "</span>));
<span class="cm-comment">// → Mack the Knife</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">mack</span>.<span class="cm-property">pop</span>());
<span class="cm-comment">// → Knife</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">mack</span>);
<span class="cm-comment">// → ["Mack", "the"]</span></pre>
<p><a class="p_ident" id="p_du5uQ2te7B" href="./04_data.html#p_du5uQ2te7B"></a>Метода <code>push</code>, може да се използва за добавяне на стойност в края на масива. Метода <code>pop</code> прави точно обратното: премахва стойност от края на масива и я връща. Масив от <em>strings</em>, може да бъде обединен в един string с метода <code>join</code>. Аргумента дава право на  <code>join</code> да определи  текста за залепяне, който е между елементите на масива.</p>
<h2><a class="h_ident" id="h_cqg63Sxe3o" href="./04_data.html#h_cqg63Sxe3o"></a>Обекти</h2>
<p><a class="p_ident" id="p_D8cm1kz0P8" href="./04_data.html#p_D8cm1kz0P8"></a>Обратно към <em>weresquirrel</em>. Набор от ежедневните записи в регистъра може да бъде представен като масив. Но записите не се състоят от само един номер или <em>string</em> - всеки запис трябва да съхранява списък от дейности и булева стойност, която показва дали Жак се превърнал в катерица. В идеалния случай, бихме могли да групираме тези стойности заедно в една стойност и след това да пуснем тези групирани стойности в масива на записките в дневника.</p>
<p><a class="p_ident" id="p_aZEa6qyMum" href="./04_data.html#p_aZEa6qyMum"></a>Стойности от тип обект са произволни колекции от свойства и ние можем да добавяме или премахваме тези свойства, както преценим. Един от начините  за създаване на обект е с помощта на фигурни скоби.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_pSAc4ib983" href="./04_data.html#c_pSAc4ib983"></a><span class="cm-keyword">var</span> <span class="cm-variable">day1</span> <span class="cm-operator">=</span> {
  <span class="cm-property">squirrel</span>: <span class="cm-atom">false</span>,
  <span class="cm-property">events</span>: [<span class="cm-string">"work"</span>, <span class="cm-string">"touched tree"</span>, <span class="cm-string">"pizza"</span>, <span class="cm-string">"running"</span>,
           <span class="cm-string">"television"</span>]
};
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">day1</span>.<span class="cm-property">squirrel</span>);
<span class="cm-comment">// → false</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">day1</span>.<span class="cm-property">wolf</span>);
<span class="cm-comment">// → undefined</span>
<span class="cm-variable">day1</span>.<span class="cm-property">wolf</span> <span class="cm-operator">=</span> <span class="cm-atom">false</span>;
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">day1</span>.<span class="cm-property">wolf</span>);
<span class="cm-comment">// → false</span></pre>
<p><a class="p_ident" id="p_hxTCt8woA9" href="./04_data.html#p_hxTCt8woA9"></a>Вътре във фигурните скоби, може да дадем списък от свойства, разделени със запетаи. Всяко свойство е написано като име, следвано от двуточие, следвано от израз, който осигурява стойност на свойството. <em>Spaces</em> и нови редове не са от значение. Когато даден обект обхваща, няколко линии, новите редове подобряват четимоста. Информациите чиито имена не са валидни имена на променливи или валидни номера, трябва да бъдат цитирани.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_7B49gkBNPX" href="./04_data.html#c_7B49gkBNPX"></a><span class="cm-keyword">var</span> <span class="cm-variable">descriptions</span> <span class="cm-operator">=</span> {
  <span class="cm-property">work</span>: <span class="cm-string">"Went to work"</span>,
  <span class="cm-string cm-property">"touched tree"</span>: <span class="cm-string">"Touched a tree"</span>
};</pre>
<p><a class="p_ident" id="p_muKvKdGc+G" href="./04_data.html#p_muKvKdGc+G"></a>Това означава, че фигурните скоби имат две значения в JavaScript. В началото на твърдението, те започват блок от твърдения. В друга позиция, те описват обект.</p>
<p><a class="p_ident" id="p_04jR2jxhZ9" href="./04_data.html#p_04jR2jxhZ9"></a>Четене на свойство, което не съществува генерира стойност <code>undefined</code>, което е както се случи с опита да прочетем <code>wolf</code> в предишния пример.</p>
<p><a class="p_ident" id="p_oxubJ4TSX5" href="./04_data.html#p_oxubJ4TSX5"></a>Възможно е да се придаде стойност на свойство с оператора <code>=</code>. Това ще замени стойността на свойството, ако тя вече съществува или да създаде нова стойност в обекта, ако той не го е направил.</p>
<p><a class="p_ident" id="p_FolCMJfte3" href="./04_data.html#p_FolCMJfte3"></a>За кратко да се върнем към нашия пример с пипалата от модела на променливите, модела на свойствата е подобен. Те хващат стойности, но може да има други променливи и свойства, които държат същите стойности. Може да мислите за обекти, като октоподи с произволен брой пипала, всяко от които има име изписано върху него.</p>
<div class="image">
  <img src="./media/octopus-object.jpg" alt="Artist&#39;s representation of an object">
</div>
<p><a class="p_ident" id="p_0r+HcrZzZJ" href="./04_data.html#p_0r+HcrZzZJ"></a>Оператора <code>delete</code> отрязва пипалото на такъв октопод. Това е унарен оператор, който когато се прилага, ще премахне името на свойството от обекта. Това не е често срещано, но е възможно.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_vYNsoXd+S5" href="./04_data.html#c_vYNsoXd+S5"></a><span class="cm-keyword">var</span> <span class="cm-variable">anObject</span> <span class="cm-operator">=</span> {<span class="cm-property">left</span>: <span class="cm-number">1</span>, <span class="cm-property">right</span>: <span class="cm-number">2</span>};
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">anObject</span>.<span class="cm-property">left</span>);
<span class="cm-comment">// → 1</span>
<span class="cm-keyword">delete</span> <span class="cm-variable">anObject</span>.<span class="cm-property">left</span>;
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">anObject</span>.<span class="cm-property">left</span>);
<span class="cm-comment">// → undefined</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"left"</span> <span class="cm-keyword">in</span> <span class="cm-variable">anObject</span>);
<span class="cm-comment">// → false</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"right"</span> <span class="cm-keyword">in</span> <span class="cm-variable">anObject</span>);
<span class="cm-comment">// → true</span></pre>
<p><a class="p_ident" id="p_CuN7Z7VCcF" href="./04_data.html#p_CuN7Z7VCcF"></a>Бинарния оператор <code>in</code>, когато се приложи към <em>string</em> и обект, връща булева стойност, която показва дали този обект има свойство. Разликата между създаването на свойство <code>undefined</code> и действително да го изтриете, е че в първия случай, обекта все още има свойството (то не разполага с определена стойност), докато във втория случай свойството вече не е налично и <code>in</code> ще върне <code>false</code>.</p>
<p><a class="p_ident" id="p_Rl8msr9DUz" href="./04_data.html#p_Rl8msr9DUz"></a>Масивите, а това са само един вид обекти, са специализирани за съхранение на последователности от неща. Ако определите <code>typeof [1, 2]</code>, това ще произведе <code>"object"</code>. Можете да си ги представите, като дълги, плоски октоподи с всичките си пипала по ред, етикетирани с числа.</p>
<div class="image">
  <img src="./media/octopus-array.jpg" alt="Artist&#39;s representation of an array">
</div>
<p><a class="p_ident" id="p_/qn/Ibmvdm" href="./04_data.html#p_/qn/Ibmvdm"></a>Така можем да представим дневника на Жак, като масиви от обекти.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_hO78QsnSY4" href="./04_data.html#c_hO78QsnSY4"></a><span class="cm-keyword">var</span> <span class="cm-variable">journal</span> <span class="cm-operator">=</span> [
  {<span class="cm-property">events</span>: [<span class="cm-string">"work"</span>, <span class="cm-string">"touched tree"</span>, <span class="cm-string">"pizza"</span>,
            <span class="cm-string">"running"</span>, <span class="cm-string">"television"</span>],
   <span class="cm-property">squirrel</span>: <span class="cm-atom">false</span>},
  {<span class="cm-property">events</span>: [<span class="cm-string">"work"</span>, <span class="cm-string">"ice cream"</span>, <span class="cm-string">"cauliflower"</span>,
            <span class="cm-string">"lasagna"</span>, <span class="cm-string">"touched tree"</span>, <span class="cm-string">"brushed teeth"</span>],
   <span class="cm-property">squirrel</span>: <span class="cm-atom">false</span>},
  {<span class="cm-property">events</span>: [<span class="cm-string">"weekend"</span>, <span class="cm-string">"cycling"</span>, <span class="cm-string">"break"</span>,
            <span class="cm-string">"peanuts"</span>, <span class="cm-string">"beer"</span>],
   <span class="cm-property">squirrel</span>: <span class="cm-atom">true</span>},
  <span class="cm-comment">/* and so on... */</span>
];</pre>
<h2><a class="h_ident" id="h_C3n45IkMhg" href="./04_data.html#h_C3n45IkMhg"></a>Изменчивост</h2>
<p><a class="p_ident" id="p_HZ50qDRWmj" href="./04_data.html#p_HZ50qDRWmj"></a>Ще стигнем до реалното програмиране невиждано до сега. Но първо има едно последно парче теория за разбиране.</p>
<p><a class="p_ident" id="p_zvnMtK4gE8" href="./04_data.html#p_zvnMtK4gE8"></a>Видяхме, че стойностите на обекта може да бъдат променяни. Видовете стойности, разгледани в предишните глави, като например номера, <em>string</em> и булев тип, са неизменни - невъзможно е да се промени съществуваща стойност на тези типове. Можете да ги комбинирате и да извличате нови стойности от тях, но когато <em>string</em> се сдобие със специфична стойност, тази стойност винаги ще остане същата. Текстът в него не може да се променя. Ако имате <em>string</em>, който съдържа <code>"cat"</code>, е невъзможно друг код да го промени в string <code>"rat"</code>, например.</p>
<p><a class="p_ident" id="p_pwnQ1xNUOh" href="./04_data.html#p_pwnQ1xNUOh"></a>В обектите, от друга страна, съдържащата се стойност може да се промени с промяна на нейните свойства.</p>
<p><a class="p_ident" id="p_fVZ1xXAqW5" href="./04_data.html#p_fVZ1xXAqW5"></a>Когато имаме две числа, 120 и 120, можем да ги разглеждаме по техния номер, независимо дали се отнасят до едни и същи физически бит. Но в обектите има разлика между двете препратки към същия обект и има два различни обекта, които съдържат едни и същи свойства. Да разгледаме следния код:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_WVXvnjG5+i" href="./04_data.html#c_WVXvnjG5+i"></a><span class="cm-keyword">var</span> <span class="cm-variable">object1</span> <span class="cm-operator">=</span> {<span class="cm-property">value</span>: <span class="cm-number">10</span>};
<span class="cm-keyword">var</span> <span class="cm-variable">object2</span> <span class="cm-operator">=</span> <span class="cm-variable">object1</span>;
<span class="cm-keyword">var</span> <span class="cm-variable">object3</span> <span class="cm-operator">=</span> {<span class="cm-property">value</span>: <span class="cm-number">10</span>};

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">object1</span> <span class="cm-operator">==</span> <span class="cm-variable">object2</span>);
<span class="cm-comment">// → true</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">object1</span> <span class="cm-operator">==</span> <span class="cm-variable">object3</span>);
<span class="cm-comment">// → false</span>

<span class="cm-variable">object1</span>.<span class="cm-property">value</span> <span class="cm-operator">=</span> <span class="cm-number">15</span>;
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">object2</span>.<span class="cm-property">value</span>);
<span class="cm-comment">// → 15</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">object3</span>.<span class="cm-property">value</span>);
<span class="cm-comment">// → 10</span></pre>
<p><a class="p_ident" id="p_RhD+qPB3F0" href="./04_data.html#p_RhD+qPB3F0"></a>Променливите <code>object1</code> и
<code>object2</code>ползват един и същи обект и когато се промени <code>object1</code> също се променя стойността на <code>object2</code>. Променливата <code>object3</code> сочи към друг обект, който първоначално съдържа същите свойства като <code>object1</code>, но живее отделен живот.</p>
<p><a class="p_ident" id="p_S6PAaKQoFH" href="./04_data.html#p_S6PAaKQoFH"></a>Оператора <code>==</code> в JavaScript се използва, когато се сравняват обекти и ще върне <code>true</code> само ако и двата обекта са точно с една и съща стойност. Сравнявайки различни обекти, ще върне  <code>false</code>, дори ако те имат идентично съдържание. Има оператор за сравнение, вграден в JavaScript, който разглежда съдържанието на обекта, но е възможно да напишем наш (което ще бъде една от задачите в <a href="./04_data.html#exercise_deep_compare">упражненията</a> в края на тази глава).</p>
<h2><a class="h_ident" id="h_+q4Ck0/tFV" href="./04_data.html#h_+q4Ck0/tFV"></a>The lycanthrope’s log</h2>
<p><a class="p_ident" id="p_z1vPsL0dwv" href="./04_data.html#p_z1vPsL0dwv"></a>Така Жак, стартира JavaScript интерпретатора си и създаде средата, от която се нуждаеше за да запази своя дневник.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_TfYH6uEY6i" href="./04_data.html#c_TfYH6uEY6i"></a><span class="cm-keyword">var</span> <span class="cm-variable">journal</span> <span class="cm-operator">=</span> [];

<span class="cm-keyword">function</span> <span class="cm-variable">addEntry</span>(<span class="cm-def">events</span>, <span class="cm-def">didITurnIntoASquirrel</span>) {
  <span class="cm-variable">journal</span>.<span class="cm-property">push</span>({
    <span class="cm-property">events</span>: <span class="cm-variable-2">events</span>,
    <span class="cm-property">squirrel</span>: <span class="cm-variable-2">didITurnIntoASquirrel</span>
  });
}</pre>
<p><a class="p_ident" id="p_6o6Q7TaG26" href="./04_data.html#p_6o6Q7TaG26"></a>И след това, всяка вечер в десет или понякога на следващата сутрин, след като се спусне от най-горния рафт на своята библиотека, той записваше случилото се през деня.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_FvNHZMxEXr" href="./04_data.html#c_FvNHZMxEXr"></a><span class="cm-variable">addEntry</span>([<span class="cm-string">"work"</span>, <span class="cm-string">"touched tree"</span>, <span class="cm-string">"pizza"</span>, <span class="cm-string">"running"</span>,
          <span class="cm-string">"television"</span>], <span class="cm-atom">false</span>);
<span class="cm-variable">addEntry</span>([<span class="cm-string">"work"</span>, <span class="cm-string">"ice cream"</span>, <span class="cm-string">"cauliflower"</span>, <span class="cm-string">"lasagna"</span>,
          <span class="cm-string">"touched tree"</span>, <span class="cm-string">"brushed teeth"</span>], <span class="cm-atom">false</span>);
<span class="cm-variable">addEntry</span>([<span class="cm-string">"weekend"</span>, <span class="cm-string">"cycling"</span>, <span class="cm-string">"break"</span>, <span class="cm-string">"peanuts"</span>,
          <span class="cm-string">"beer"</span>], <span class="cm-atom">true</span>);</pre>
<p><a class="p_ident" id="p_+Ih1dpMwEH" href="./04_data.html#p_+Ih1dpMwEH"></a>След като разполага с достатъчно точки от данни, той възнамеряваше да изчисли съотношението между неговата кетерицо-фикация и всяко от събитията през деня, и в идеалния случай да научи нещо полезно от тези корелации.</p>
<p><a class="p_ident" id="p_EedDVNQ30H" href="./04_data.html#p_EedDVNQ30H"></a><em>Correlation</em> (корелацията) е мярка за зависимостта между променливите (променливи в статистическия смисъл, а не в смисъла на JavaScript). Тя обикновено се изразява, като коефициент, който варира между -1 и 1. Нулевата корелация означава, че променливите не са свързани, като се има в предвид, че корелацията на единия показва, че двата са напълно свързани и ако знаете единия, то знаете и другия. <em>Negativ</em> също означава, че променливите са напълно свързани, но са противоположни - когато едното е <em>true</em>, другото е <em>false</em>.</p>
<p><a class="p_ident" id="p_4Rv6gGntx7" href="./04_data.html#p_4Rv6gGntx7"></a>За бинарни (булеви) променливи, коефициента на <em>phi</em> (<em>ϕ</em>) дава добра мярка за корелация и е относително лесно да се изчисли. За да се изчисли <em>ϕ</em>, имаме нужда от една таблица <em>n</em>, която съдържа броя пъти, когато са наблюдавани различни комбинации на двете променливи. Например, може да разгледаме случаите с ядене на пица и ги отбележим в таблица, като тази:</p>
<div class="image">
  <img src="./media/pizza-squirrel.svg" alt="Eating pizza versus turning into a squirrel">
</div>
<p><a class="p_ident" id="p_82L/EowL1c" href="./04_data.html#p_82L/EowL1c"></a><em>ϕ</em> може да се изчисли по следната формула, където <em>n</em> се отнася за  таблицата.</p>
<div>
<style scoped="scoped">sub { font-size: 60%; }</style>
<table style="border-collapse: collapse; margin-left: 1em;"><tbody><tr>
  <td style="vertical-align: middle"><em>ϕ</em> =</td>
  <td style="padding-left: .5em">
    <div style="border-bottom: 1px solid black; padding: 0 7px;">n<sub>11</sub>n<sub>00</sub> - n<sub>10</sub>n<sub>01</sub></div>
    <div style="padding: 0 7px;">√<span style="border-top: 1px solid black; position: relative; top: 2px;">
      <span style="position: relative; top: -4px">n<sub>1•</sub>n<sub>0•</sub>n<sub>•1</sub>n<sub>•0</sub></span>
    </span></div>
  </td>
</tr></tbody></table>
</div>
<p><a class="p_ident" id="p_WPl/XNNv2K" href="./04_data.html#p_WPl/XNNv2K"></a>Нотацията <em>n</em><sub>01</sub> показва броя на измерванията, където първата променлива (<em>squirrelness</em>) е <em>false</em>(0), а втората променлива (пица) е <em>true</em>(1) . В този пример <em>n</em><sub>01</sub> е 9.</p>
<p><a class="p_ident" id="p_pweIXp0GRF" href="./04_data.html#p_pweIXp0GRF"></a>Стойноста <em>n</em><sub>1•</sub> се отнася  за сумата от всички измервания, където първата променлива е  <em>true</em> , като например 5 в таблицата. По същия начин  <em>n</em><sub>•0</sub> се отнася за сумата от измервания, където втората променлива е <em>false</em>.</p>
<p><a class="p_ident" id="p_ACMn7uvFzz" href="./04_data.html#p_ACMn7uvFzz"></a>Така че, таблицата за пица, от горната страна над-линията за разделяне (дивидента) ще бъде 1 х 76 - 4 х 9 = 40, а частта под нея(делителя) ще бъде корен квадратен от 5 х 85 х 10 х 80 или √340000. От това излиза, че <em>ϕ</em> ≈ 0.069, което е малко. Яденето на пица не изглежда да има влияние върху трансформациите.</p>
<h2><a class="h_ident" id="h_YwedOm6SqZ" href="./04_data.html#h_YwedOm6SqZ"></a>Computing correlation</h2>
<p><a class="p_ident" id="p_jn2nhCXEpR" href="./04_data.html#p_jn2nhCXEpR"></a>Можем да представим таблица с две от две в JavaScript с масив от четири елемента (<code>[76, 9,
4, 1]</code>).Бихме могли да използваме и други представителства, като масив съдържащ два масива с елементи (<code>[[76, 9], [4, 1]]</code>) или обект с имена, като <code>"11"</code> и <code>"01"</code>, но масивът е семпъл и прави изразите за достъп до таблицата приятно кратки. Ние ще интерпретираме индексите на масива, като дву-битов бинарен номер, където най-лявата (най-значимата) цифра се отнася до променливата на катерицата и най-дясната (най-маловажната) цифра се отнася до променливата на събитията. Например бинарния номер <code>10</code>се отнася за случаите, когато Жак се превръща в катерица, но събитието (пица) не се е случвало. То се случвало четири пъти. И тъй като бинарно <code>10</code> е 2 в десетична бройна система, ние ще съхраняваме този номер на индекс 2 в масива.</p>
<p><a class="p_ident" id="p_napfsNS5sk" href="./04_data.html#p_napfsNS5sk"></a>Това е функция, която изчислява коефициента на <em>ϕ</em>, като масив от:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_S1PE4hukUi" href="./04_data.html#c_S1PE4hukUi"></a><span class="cm-keyword">function</span> <span class="cm-variable">phi</span>(<span class="cm-def">table</span>) {
  <span class="cm-keyword">return</span> (<span class="cm-variable-2">table</span>[<span class="cm-number">3</span>] <span class="cm-operator">*</span> <span class="cm-variable-2">table</span>[<span class="cm-number">0</span>] <span class="cm-operator">-</span> <span class="cm-variable-2">table</span>[<span class="cm-number">2</span>] <span class="cm-operator">*</span> <span class="cm-variable-2">table</span>[<span class="cm-number">1</span>]) <span class="cm-operator">/</span>
    <span class="cm-variable">Math</span>.<span class="cm-property">sqrt</span>((<span class="cm-variable-2">table</span>[<span class="cm-number">2</span>] <span class="cm-operator">+</span> <span class="cm-variable-2">table</span>[<span class="cm-number">3</span>]) <span class="cm-operator">*</span>
              (<span class="cm-variable-2">table</span>[<span class="cm-number">0</span>] <span class="cm-operator">+</span> <span class="cm-variable-2">table</span>[<span class="cm-number">1</span>]) <span class="cm-operator">*</span>
              (<span class="cm-variable-2">table</span>[<span class="cm-number">1</span>] <span class="cm-operator">+</span> <span class="cm-variable-2">table</span>[<span class="cm-number">3</span>]) <span class="cm-operator">*</span>
              (<span class="cm-variable-2">table</span>[<span class="cm-number">0</span>] <span class="cm-operator">+</span> <span class="cm-variable-2">table</span>[<span class="cm-number">2</span>]));
}

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">phi</span>([<span class="cm-number">76</span>, <span class="cm-number">9</span>, <span class="cm-number">4</span>, <span class="cm-number">1</span>]));
<span class="cm-comment">// → 0.068599434</span></pre>
<p><a class="p_ident" id="p_25QRmcB8ci" href="./04_data.html#p_25QRmcB8ci"></a>Това е просто един директен превод на формулата <em>ϕ</em> в JavaScript. <code>Math.sqrt</code> е функция за корен квадратен, която е предвидена от <code>Math</code>обекта в стандартна JavaScript среда. Ние трябва да сумираме две полета от таблицата, за да получим области, като n<sub>1•</sub>, защото сумите от редовете и колоните не се съхраняват директно в нашата структура от данни.</p>
<p><a class="p_ident" id="p_0u/DATumDu" href="./04_data.html#p_0u/DATumDu"></a>Жак води дневника си за срок от три месеца. Полученият набор от данни е на разположение в кодиращия пясъчник на тази глава, където той се съхранява в променливата <code>JOURNAL</code> и в достъпен файл за теглене.
<a href="./code/jacques_journal.js">file</a>.</p>
<p><a class="p_ident" id="p_sM+4QT8FKs" href="./04_data.html#p_sM+4QT8FKs"></a>За да се извлече таблица с две по две за конкретно събитие от този журнал, ние трябва да поставим всички записи в цикъл и да видим колко пъти дадено събитие се случва по отношение на трансформацията в катерица.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_eFskSRBd2j" href="./04_data.html#c_eFskSRBd2j"></a><span class="cm-keyword">function</span> <span class="cm-variable">hasEvent</span>(<span class="cm-def">event</span>, <span class="cm-def">entry</span>) {
  <span class="cm-keyword">return</span> <span class="cm-variable-2">entry</span>.<span class="cm-property">events</span>.<span class="cm-property">indexOf</span>(<span class="cm-variable-2">event</span>) <span class="cm-operator">!=</span> <span class="cm-operator">-</span><span class="cm-number">1</span>;
}

<span class="cm-keyword">function</span> <span class="cm-variable">tableFor</span>(<span class="cm-def">event</span>, <span class="cm-def">journal</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">table</span> <span class="cm-operator">=</span> [<span class="cm-number">0</span>, <span class="cm-number">0</span>, <span class="cm-number">0</span>, <span class="cm-number">0</span>];
  <span class="cm-keyword">for</span> (<span class="cm-keyword">var</span> <span class="cm-def">i</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>; <span class="cm-variable-2">i</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">journal</span>.<span class="cm-property">length</span>; <span class="cm-variable-2">i</span><span class="cm-operator">++</span>) {
    <span class="cm-keyword">var</span> <span class="cm-def">entry</span> <span class="cm-operator">=</span> <span class="cm-variable-2">journal</span>[<span class="cm-variable-2">i</span>], <span class="cm-def">index</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>;
    <span class="cm-keyword">if</span> (<span class="cm-variable">hasEvent</span>(<span class="cm-variable-2">event</span>, <span class="cm-variable-2">entry</span>)) <span class="cm-variable-2">index</span> <span class="cm-operator">+=</span> <span class="cm-number">1</span>;
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">entry</span>.<span class="cm-property">squirrel</span>) <span class="cm-variable-2">index</span> <span class="cm-operator">+=</span> <span class="cm-number">2</span>;
    <span class="cm-variable-2">table</span>[<span class="cm-variable-2">index</span>] <span class="cm-operator">+=</span> <span class="cm-number">1</span>;
  }
  <span class="cm-keyword">return</span> <span class="cm-variable-2">table</span>;
}

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">tableFor</span>(<span class="cm-string">"pizza"</span>, <span class="cm-variable">JOURNAL</span>));
<span class="cm-comment">// → [76, 9, 4, 1]</span></pre>
<p><a class="p_ident" id="p_3pgyJn7mEy" href="./04_data.html#p_3pgyJn7mEy"></a>Функцията <code>hasEvent</code> тества дали даден запис съдържа дадено събитие. Масивите имат <code>indexOf</code>метод, който се опитва да намери дадена стойност (в този случай име на събитие) в масива и връща индекса, при който е установено или -1 ако не е намерено. Така че, ако метода <code>indexOf</code> не връща -1, тогава знаем събитието, което е намерено вътре.</p>
<p><a class="p_ident" id="p_6jCcm4ltfJ" href="./04_data.html#p_6jCcm4ltfJ"></a>Тялото на цикъла в <code>tableFor</code> разбира в коя кутия на таблицата попада при всяко влизане, чрез проверка дали вписаното съдържа конкретно събитие и дали събитието съвпада с инцидента с катерицата. След това, цикъла добавя едно към броя в масива, който съответства на това поле в таблицата.</p>
<p><a class="p_ident" id="p_PId7X0fpkS" href="./04_data.html#p_PId7X0fpkS"></a>Сега имаме инструментите, които трябва да изчислят индивидуалните корелации. Единствената стъпка, която остава е да се намери съответствието за всеки тип събитие, което е записано и да видим дали нещо се откроява. Но как трябва да се съхраняват тези корелации, след като сме ги изчислили?</p>
<h2><a class="h_ident" id="h_mrW9RQxlGk" href="./04_data.html#h_mrW9RQxlGk"></a>Обекти като карти (map)</h2>
<p><a class="p_ident" id="p_IdpwDMsKm8" href="./04_data.html#p_IdpwDMsKm8"></a>Един възможен начин да се съхраняват всички корелации е в масив, използвайки обекти с <code>name</code> и <code>value</code> свойства. Но това прави прегледа на корелация за дадено събитие тромаво: ще трябва да мине цикъл през целия масив, за да намери обекта с правилното име. Ние можем да приключим това търсене във функция, но щяхме да пишем повече код и компютъра щеше да върши повече работа, от колкото е необходимо.</p>
<p id="object_map"><a class="p_ident" id="p_cZSsd9wDlN" href="./04_data.html#p_cZSsd9wDlN"></a>По-добър начин е да се използва обектното свойство, кръстено на видовете събития <em>event</em>. Можем да използваме квадратни скоби за нотация при създаването и четенето на свойствата и да използваме оператора <code>in</code>, за да провери дали съществува дадено свойство.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_+2/ib0YcAS" href="./04_data.html#c_+2/ib0YcAS"></a><span class="cm-keyword">var</span> <span class="cm-variable">map</span> <span class="cm-operator">=</span> {};
<span class="cm-keyword">function</span> <span class="cm-variable">storePhi</span>(<span class="cm-def">event</span>, <span class="cm-def">phi</span>) {
  <span class="cm-variable">map</span>[<span class="cm-variable-2">event</span>] <span class="cm-operator">=</span> <span class="cm-variable-2">phi</span>;
}

<span class="cm-variable">storePhi</span>(<span class="cm-string">"pizza"</span>, <span class="cm-number">0.069</span>);
<span class="cm-variable">storePhi</span>(<span class="cm-string">"touched tree"</span>, <span class="cm-operator">-</span><span class="cm-number">0.081</span>);
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"pizza"</span> <span class="cm-keyword">in</span> <span class="cm-variable">map</span>);
<span class="cm-comment">// → true</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">map</span>[<span class="cm-string">"touched tree"</span>]);
<span class="cm-comment">// → -0.081</span></pre>
<p><a class="p_ident" id="p_OlrE0O0+IT" href="./04_data.html#p_OlrE0O0+IT"></a>Картата <em>map</em> е начин да се премине от стойности в дадена област ( в този случай, имена на събития) в съответните стойности в друга област (в този случай, <em>ϕ</em> коефициенти).</p>
<p><a class="p_ident" id="p_Geo6ELctAH" href="./04_data.html#p_Geo6ELctAH"></a>Има няколко потенциални проблема при използването на обекти по този начин, които ние ще обсъдим в <a href="./06_object.html#prototypes">Глава 6</a>, но за момента няма да се притесняваме за това.</p>
<p><a class="p_ident" id="p_esSmj3VTX0" href="./04_data.html#p_esSmj3VTX0"></a>Какво става, ако искаме да намерим всички събития, за които съхраняваме коефициент? Свойствата не образуват предсказуема серия, когато са в масив, така че не можем да използваме нормален <code>for</code> цикъл. JavaScript осигурява специален цикъл за преминаване през свойствата на даден обект. Той изглежда, като нормален <code>for</code>цикъл, но се отличава с използването на думата <code>in</code>.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_fVra/BEVfu" href="./04_data.html#c_fVra/BEVfu"></a><span class="cm-keyword">for</span> (<span class="cm-keyword">var</span> <span class="cm-variable">event</span> <span class="cm-keyword">in</span> <span class="cm-variable">map</span>)
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"The correlation for '"</span> <span class="cm-operator">+</span> <span class="cm-variable">event</span> <span class="cm-operator">+</span>
              <span class="cm-string">"' is "</span> <span class="cm-operator">+</span> <span class="cm-variable">map</span>[<span class="cm-variable">event</span>]);
<span class="cm-comment">// → The correlation for 'pizza' is 0.069</span>
<span class="cm-comment">// → The correlation for 'touched tree' is -0.081</span></pre>
<h2 id="analysis"><a class="h_ident" id="h_Lg5n7mjqw/" href="./04_data.html#h_Lg5n7mjqw/"></a>Финален анализ</h2>
<p><a class="p_ident" id="p_o0qm2V9nGm" href="./04_data.html#p_o0qm2V9nGm"></a>За да намерим всички видове събития, които се намират в масива от данни, ние просто обработваме всяко влизане на ред от данните и след това с цикъл в събитията на това вписване. Ние пазим обект <code>phis</code>, който получава коефициенти за всички видове събития, които сме виждали досега. Всеки път когато се натъкнем на тип, който не е в обекта <code>phis</code>, ние изчисляваме неговата взаимообвързаност и го добавяме към обекта.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_NNtQBmsHS2" href="./04_data.html#c_NNtQBmsHS2"></a><span class="cm-keyword">function</span> <span class="cm-variable">gatherCorrelations</span>(<span class="cm-def">journal</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">phis</span> <span class="cm-operator">=</span> {};
  <span class="cm-keyword">for</span> (<span class="cm-keyword">var</span> <span class="cm-def">entry</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>; <span class="cm-variable-2">entry</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">journal</span>.<span class="cm-property">length</span>; <span class="cm-variable-2">entry</span><span class="cm-operator">++</span>) {
    <span class="cm-keyword">var</span> <span class="cm-def">events</span> <span class="cm-operator">=</span> <span class="cm-variable-2">journal</span>[<span class="cm-variable-2">entry</span>].<span class="cm-property">events</span>;
    <span class="cm-keyword">for</span> (<span class="cm-keyword">var</span> <span class="cm-def">i</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>; <span class="cm-variable-2">i</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">events</span>.<span class="cm-property">length</span>; <span class="cm-variable-2">i</span><span class="cm-operator">++</span>) {
      <span class="cm-keyword">var</span> <span class="cm-def">event</span> <span class="cm-operator">=</span> <span class="cm-variable-2">events</span>[<span class="cm-variable-2">i</span>];
      <span class="cm-keyword">if</span> (<span class="cm-operator">!</span>(<span class="cm-variable-2">event</span> <span class="cm-keyword">in</span> <span class="cm-variable-2">phis</span>))
        <span class="cm-variable-2">phis</span>[<span class="cm-variable-2">event</span>] <span class="cm-operator">=</span> <span class="cm-variable">phi</span>(<span class="cm-variable">tableFor</span>(<span class="cm-variable-2">event</span>, <span class="cm-variable-2">journal</span>));
    }
  }
  <span class="cm-keyword">return</span> <span class="cm-variable-2">phis</span>;
}

<span class="cm-keyword">var</span> <span class="cm-variable">correlations</span> <span class="cm-operator">=</span> <span class="cm-variable">gatherCorrelations</span>(<span class="cm-variable">JOURNAL</span>);
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">correlations</span>.<span class="cm-property">pizza</span>);
<span class="cm-comment">// → 0.068599434</span></pre>
<p><a class="p_ident" id="p_XUj02Go7DR" href="./04_data.html#p_XUj02Go7DR"></a>Да видим какво ще излезе:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_9AY4PathBr" href="./04_data.html#c_9AY4PathBr"></a><span class="cm-keyword">for</span> (<span class="cm-keyword">var</span> <span class="cm-variable">event</span> <span class="cm-keyword">in</span> <span class="cm-variable">correlations</span>)
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">event</span> <span class="cm-operator">+</span> <span class="cm-string">": "</span> <span class="cm-operator">+</span> <span class="cm-variable">correlations</span>[<span class="cm-variable">event</span>]);
<span class="cm-comment">// → carrot:   0.0140970969</span>
<span class="cm-comment">// → exercise: 0.0685994341</span>
<span class="cm-comment">// → weekend:  0.1371988681</span>
<span class="cm-comment">// → bread:   -0.0757554019</span>
<span class="cm-comment">// → pudding: -0.0648203724</span>
<span class="cm-comment">// and so on...</span></pre>
<p><a class="p_ident" id="p_TiI6dIjE18" href="./04_data.html#p_TiI6dIjE18"></a>Повечето корелации изглеждат близки до нула. Яденето на моркови, хляб или пудинг очевидно не задействат катерицо-трансформацията. Тя изглежда се появява малко по-често в събота и неделя обаче. Нека филтрираме резултатите да покажат само корелации  по-големи от 0.1 или по-малки от - 0.1.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_TLJ4VeMVj7" href="./04_data.html#c_TLJ4VeMVj7"></a><span class="cm-keyword">for</span> (<span class="cm-keyword">var</span> <span class="cm-variable">event</span> <span class="cm-keyword">in</span> <span class="cm-variable">correlations</span>) {
  <span class="cm-keyword">var</span> <span class="cm-variable">correlation</span> <span class="cm-operator">=</span> <span class="cm-variable">correlations</span>[<span class="cm-variable">event</span>];
  <span class="cm-keyword">if</span> (<span class="cm-variable">correlation</span> <span class="cm-operator">&gt;</span> <span class="cm-number">0.1</span> <span class="cm-operator">||</span> <span class="cm-variable">correlation</span> <span class="cm-operator">&lt;</span> <span class="cm-operator">-</span><span class="cm-number">0.1</span>)
    <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">event</span> <span class="cm-operator">+</span> <span class="cm-string">": "</span> <span class="cm-operator">+</span> <span class="cm-variable">correlation</span>);
}
<span class="cm-comment">// → weekend:        0.1371988681</span>
<span class="cm-comment">// → brushed teeth: -0.3805211953</span>
<span class="cm-comment">// → candy:          0.1296407447</span>
<span class="cm-comment">// → work:          -0.1371988681</span>
<span class="cm-comment">// → spaghetti:      0.2425356250</span>
<span class="cm-comment">// → reading:        0.1106828054</span>
<span class="cm-comment">// → peanuts:        0.5902679812</span></pre>
<p><a class="p_ident" id="p_V2ZEhvkhz3" href="./04_data.html#p_V2ZEhvkhz3"></a>А - ха! Има два фактора, чието съотношение е по-ясно изразено от другите. Яденето на фъстъци има силен, положителен ефект върху шанса да се превърне в катерица, докато миенето на зъби има значителен отрицателен ефект.</p>
<p><a class="p_ident" id="p_xpRHDuufcX" href="./04_data.html#p_xpRHDuufcX"></a>Интересно нека опитаме нещо.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_xlu1nixXWv" href="./04_data.html#c_xlu1nixXWv"></a><span class="cm-keyword">for</span> (<span class="cm-keyword">var</span> <span class="cm-variable">i</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>; <span class="cm-variable">i</span> <span class="cm-operator">&lt;</span> <span class="cm-variable">JOURNAL</span>.<span class="cm-property">length</span>; <span class="cm-variable">i</span><span class="cm-operator">++</span>) {
  <span class="cm-keyword">var</span> <span class="cm-variable">entry</span> <span class="cm-operator">=</span> <span class="cm-variable">JOURNAL</span>[<span class="cm-variable">i</span>];
  <span class="cm-keyword">if</span> (<span class="cm-variable">hasEvent</span>(<span class="cm-string">"peanuts"</span>, <span class="cm-variable">entry</span>) <span class="cm-operator">&amp;&amp;</span>
     <span class="cm-operator">!</span><span class="cm-variable">hasEvent</span>(<span class="cm-string">"brushed teeth"</span>, <span class="cm-variable">entry</span>))
    <span class="cm-variable">entry</span>.<span class="cm-property">events</span>.<span class="cm-property">push</span>(<span class="cm-string">"peanut teeth"</span>);
}
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">phi</span>(<span class="cm-variable">tableFor</span>(<span class="cm-string">"peanut teeth"</span>, <span class="cm-variable">JOURNAL</span>)));
<span class="cm-comment">// → 1</span></pre>
<p><a class="p_ident" id="p_WUlOiYWV3C" href="./04_data.html#p_WUlOiYWV3C"></a>Well, няма грешка! Явлението се случва само когато Жак яде фъстъци и не си мие зъбите. Само ако той не беше такъв мърлю на зъбна хигиена, нямаше никога да се сблъска с нещастието си.</p>
<p><a class="p_ident" id="p_tPNATV9wwS" href="./04_data.html#p_tPNATV9wwS"></a>Знаейки това, Жак просто спря да яде фъстъци и установи, че това напълно слага край на неговите трансформации.</p>
<p><a class="p_ident" id="p_DXAwHKoLIY" href="./04_data.html#p_DXAwHKoLIY"></a>Сега с Жак всичко е на ред за известно време. Но няколко години по-късно, той загубва работата си и в крайна сметка е принуден да работи в един цирк, където изпълнява номера - Невероятната Катерицо-трансформация, тъпчейки устата си фъстъчено масло преди всяко шоу. Един ден, отвратен от това жалко съществуване, Жак не успя да се върне в неговата човешка форма и през една цепнатина в цирковата шатра, изчезна в гората. Никой никога не го е виждал отново.</p>
<h2><a class="h_ident" id="h_GFaxee4PuU" href="./04_data.html#h_GFaxee4PuU"></a>Допълнителна масиво-логия</h2>
<p><a class="p_ident" id="p_U0+LZH9g+H" href="./04_data.html#p_U0+LZH9g+H"></a>Преди да завършим тази глава, искам да ви запозная с още няколко понятия свързани с обекти. Ще започнем с въвеждането на някои по принцип полезни методи за масиви.</p>
<p><a class="p_ident" id="p_Wl9gXY97xi" href="./04_data.html#p_Wl9gXY97xi"></a>Видяхме  <code>push</code> и <code>pop</code>, които добавят и премахват елементи в края на масива, <a href="./04_data.html#array_methods">по-рано</a> в тази глава. Съответните методи за добавяне и премахване на елементи в началото на масива се наричат <code>unshift</code> и <code>shift</code>.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_9It3VS5zI/" href="./04_data.html#c_9It3VS5zI/"></a><span class="cm-keyword">var</span> <span class="cm-variable">todoList</span> <span class="cm-operator">=</span> [];
<span class="cm-keyword">function</span> <span class="cm-variable">rememberTo</span>(<span class="cm-def">task</span>) {
  <span class="cm-variable">todoList</span>.<span class="cm-property">push</span>(<span class="cm-variable-2">task</span>);
}
<span class="cm-keyword">function</span> <span class="cm-variable">whatIsNext</span>() {
  <span class="cm-keyword">return</span> <span class="cm-variable">todoList</span>.<span class="cm-property">shift</span>();
}
<span class="cm-keyword">function</span> <span class="cm-variable">urgentlyRememberTo</span>(<span class="cm-def">task</span>) {
  <span class="cm-variable">todoList</span>.<span class="cm-property">unshift</span>(<span class="cm-variable-2">task</span>);
}</pre>
<p><a class="p_ident" id="p_msNR9KyjFO" href="./04_data.html#p_msNR9KyjFO"></a>Тази програма управлява списъци от задачи. Можете да добавите задачи в края на списъка, като извикате <code>rememberTo("eat")</code> и когато сте готови да направите нещо, извикайте <code>whatIsNext()</code> за да вземете( и премахнете) предния елемент от списъка. Функцията <code>urgentlyRememberTo</code> добавя задачи, но ги добавя към предната вместо към задната част на списъка.</p>
<p><a class="p_ident" id="p_V9yB5Z4xWA" href="./04_data.html#p_V9yB5Z4xWA"></a>Метода <code>indexOf</code> има братче, наречено <code>lastIndexOf</code>, който започва да търси дадения елемент от края на масива вместо отпред.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_li2m9Gen8Q" href="./04_data.html#c_li2m9Gen8Q"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>([<span class="cm-number">1</span>, <span class="cm-number">2</span>, <span class="cm-number">3</span>, <span class="cm-number">2</span>, <span class="cm-number">1</span>].<span class="cm-property">indexOf</span>(<span class="cm-number">2</span>));
<span class="cm-comment">// → 1</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>([<span class="cm-number">1</span>, <span class="cm-number">2</span>, <span class="cm-number">3</span>, <span class="cm-number">2</span>, <span class="cm-number">1</span>].<span class="cm-property">lastIndexOf</span>(<span class="cm-number">2</span>));
<span class="cm-comment">// → 3</span></pre>
<p><a class="p_ident" id="p_hZ181L7UrW" href="./04_data.html#p_hZ181L7UrW"></a>И двата <code>indexOf</code> и <code>lastIndexOf</code> вземат втори не задължителен аргумент, който показва от къде да започнете да търсите.</p>
<p><a class="p_ident" id="p_wxgx//Le/b" href="./04_data.html#p_wxgx//Le/b"></a>Друг основен метод е <code>slice</code>, който взема индекс за начало и индекс за край, и връща масив, който има елементите между тези индекси. Стартовия индекс е приобщаващ, крайният индекс е изключващ.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_uRogoaHL4B" href="./04_data.html#c_uRogoaHL4B"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>([<span class="cm-number">0</span>, <span class="cm-number">1</span>, <span class="cm-number">2</span>, <span class="cm-number">3</span>, <span class="cm-number">4</span>].<span class="cm-property">slice</span>(<span class="cm-number">2</span>, <span class="cm-number">4</span>));
<span class="cm-comment">// → [2, 3]</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>([<span class="cm-number">0</span>, <span class="cm-number">1</span>, <span class="cm-number">2</span>, <span class="cm-number">3</span>, <span class="cm-number">4</span>].<span class="cm-property">slice</span>(<span class="cm-number">2</span>));
<span class="cm-comment">// → [2, 3, 4]</span></pre>
<p><a class="p_ident" id="p_Z01yQe26G8" href="./04_data.html#p_Z01yQe26G8"></a>Когато крайният индекс не е зададен, <code>slice</code> ще вземе всички елементи, след стартовия индекс. <em>Strings</em> също имат <code>slice</code> метод, който има подобен ефект.</p>
<p><a class="p_ident" id="p_1mS9LYSSFD" href="./04_data.html#p_1mS9LYSSFD"></a>Метода <code>concat</code> може да се използва за залепване на масиви заедно, подобно на това, което оператора <code>+</code> прави със <em>strings</em>. Следващия пример показва <code>concat</code> и <code>slice</code> в действие. Те вземат <em>array</em> и <em>index</em> и връщат нов масив, който е копие на оригиналния масив с елемента премахнат от дадения индекс.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_ai2SwbDs5w" href="./04_data.html#c_ai2SwbDs5w"></a><span class="cm-keyword">function</span> <span class="cm-variable">remove</span>(<span class="cm-def">array</span>, <span class="cm-def">index</span>) {
  <span class="cm-keyword">return</span> <span class="cm-variable-2">array</span>.<span class="cm-property">slice</span>(<span class="cm-number">0</span>, <span class="cm-variable-2">index</span>)
    .<span class="cm-property">concat</span>(<span class="cm-variable-2">array</span>.<span class="cm-property">slice</span>(<span class="cm-variable-2">index</span> <span class="cm-operator">+</span> <span class="cm-number">1</span>));
}
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">remove</span>([<span class="cm-string">"a"</span>, <span class="cm-string">"b"</span>, <span class="cm-string">"c"</span>, <span class="cm-string">"d"</span>, <span class="cm-string">"e"</span>], <span class="cm-number">2</span>));
<span class="cm-comment">// → ["a", "b", "d", "e"]</span></pre>
<h2><a class="h_ident" id="h_mT4YQfwHp6" href="./04_data.html#h_mT4YQfwHp6"></a>Strings и техните свойства</h2>
<p><a class="p_ident" id="p_ZbMq0Cy4Fu" href="./04_data.html#p_ZbMq0Cy4Fu"></a>Можем да четем свойства, като <code>length</code> и <code>toUpperCase</code>от <em>strings</em> стойности. Но ако се опитате да добавите ново свойство, то не залепва.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_kuUv1PH55x" href="./04_data.html#c_kuUv1PH55x"></a><span class="cm-keyword">var</span> <span class="cm-variable">myString</span> <span class="cm-operator">=</span> <span class="cm-string">"Fido"</span>;
<span class="cm-variable">myString</span>.<span class="cm-property">myProperty</span> <span class="cm-operator">=</span> <span class="cm-string">"value"</span>;
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">myString</span>.<span class="cm-property">myProperty</span>);
<span class="cm-comment">// → undefined</span></pre>
<p><a class="p_ident" id="p_B+oSPYAIbV" href="./04_data.html#p_B+oSPYAIbV"></a>Стойности на <em>strings, nuber</em> и <em>Boolean</em> не са обекти, и въпреки, че езикът не се оплаква, ако се опитате да им зададете нови свойства, те всъщност не съхраняват тези свойства. Стойностите са неизменни и не могат да бъдат променяни.</p>
<p><a class="p_ident" id="p_8L2ib2beYN" href="./04_data.html#p_8L2ib2beYN"></a>Но тези видове имат някои вградени свойства. Всяка стойност на <em>string</em> има редица методи. Най-полезните от тях вероятно са <code>slice</code> и <code>indexOf</code>, които приличат на методите на масива със същото име.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_rZojswAQFV" href="./04_data.html#c_rZojswAQFV"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"coconuts"</span>.<span class="cm-property">slice</span>(<span class="cm-number">4</span>, <span class="cm-number">7</span>));
<span class="cm-comment">// → nut</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"coconut"</span>.<span class="cm-property">indexOf</span>(<span class="cm-string">"u"</span>));
<span class="cm-comment">// → 5</span></pre>
<p><a class="p_ident" id="p_RUd6q+Q4dc" href="./04_data.html#p_RUd6q+Q4dc"></a>Една от разликите е, че <em>string</em>-а на <code>indexOf</code> може да е <em>string</em> съдържащ повече от един символ, докато съответния метод на масив е само за един елемент.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_sW/DJiLrM1" href="./04_data.html#c_sW/DJiLrM1"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"one two three"</span>.<span class="cm-property">indexOf</span>(<span class="cm-string">"ee"</span>));
<span class="cm-comment">// → 11</span></pre>
<p><a class="p_ident" id="p_iSAQfJDhu8" href="./04_data.html#p_iSAQfJDhu8"></a>Метода <code>trim</code> премахва празното пространство (интервали, нови редове, раздели и др. подобни символи) от началото и края на <em>string</em>-a.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_Bm4kTTYcF2" href="./04_data.html#c_Bm4kTTYcF2"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"  okay \n "</span>.<span class="cm-property">trim</span>());
<span class="cm-comment">// → okay</span></pre>
<p><a class="p_ident" id="p_J4kiFmHyRO" href="./04_data.html#p_J4kiFmHyRO"></a>Вече видяхме, свойството <code>length</code>на вида <em>string</em>. Достъп до характерите на отделните елементи в <em>string</em>-a може да бъде направено с метода <code>charAt</code>, но също и като просто се четат числовите свойства, както бихме направили в масив.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_+uFPZG6blX" href="./04_data.html#c_+uFPZG6blX"></a><span class="cm-keyword">var</span> <span class="cm-variable">string</span> <span class="cm-operator">=</span> <span class="cm-string">"abc"</span>;
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">string</span>.<span class="cm-property">length</span>);
<span class="cm-comment">// → 3</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">string</span>.<span class="cm-property">charAt</span>(<span class="cm-number">0</span>));
<span class="cm-comment">// → a</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">string</span>[<span class="cm-number">1</span>]);
<span class="cm-comment">// → b</span></pre>
<h2 id="arguments_object"><a class="h_ident" id="h_GstIcsgxyb" href="./04_data.html#h_GstIcsgxyb"></a>Аргументи обекти</h2>
<p><a class="p_ident" id="p_8jQc6BP3jE" href="./04_data.html#p_8jQc6BP3jE"></a>Всеки път, когато дадена функция се извиква, специална променлива наречена <code>arguments</code> се добавя към средата, в която тялото на функцията работи. Тази променлива се отнася до обект, който притежава всички аргументи подадени на функцията. Не забравяйте, че в JavaScript ви е позволено да подадете повече (или по-малко ) аргументи към функция, от броя на параметрите които функцията обявява.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_vGR3ohSBVO" href="./04_data.html#c_vGR3ohSBVO"></a><span class="cm-keyword">function</span> <span class="cm-variable">noArguments</span>() {}
<span class="cm-variable">noArguments</span>(<span class="cm-number">1</span>, <span class="cm-number">2</span>, <span class="cm-number">3</span>); <span class="cm-comment">// This is okay</span>
<span class="cm-keyword">function</span> <span class="cm-variable">threeArguments</span>(<span class="cm-def">a</span>, <span class="cm-def">b</span>, <span class="cm-def">c</span>) {}
<span class="cm-variable">threeArguments</span>(); <span class="cm-comment">// And so is this</span></pre>
<p><a class="p_ident" id="p_X05+xpRc+j" href="./04_data.html#p_X05+xpRc+j"></a><code>Arguments</code> обекта има свойството <code>length</code>, което ни казва броят на аргументите, които се подават на функцията. Тя също има свойство за всеки аргумент, 0, 1, 2 и т.н.</p>
<p><a class="p_ident" id="p_r7f/a3/GFP" href="./04_data.html#p_r7f/a3/GFP"></a>Ако това ви прилича на масив сте прави, това много прилича на масив. Но този обект за съжаление, няма никакви методи, като масиви (като <code>slice</code> или
<code>indexOf</code>), така че е малко по-труден за използване от истински масив.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_MLV9gPSdx9" href="./04_data.html#c_MLV9gPSdx9"></a><span class="cm-keyword">function</span> <span class="cm-variable">argumentCounter</span>() {
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"You gave me"</span>, <span class="cm-variable-2">arguments</span>.<span class="cm-property">length</span>, <span class="cm-string">"arguments."</span>);
}
<span class="cm-variable">argumentCounter</span>(<span class="cm-string">"Straw man"</span>, <span class="cm-string">"Tautology"</span>, <span class="cm-string">"Ad hominem"</span>);
<span class="cm-comment">// → You gave me 3 arguments.</span></pre>
<p><a class="p_ident" id="p_MIxvg5Tzop" href="./04_data.html#p_MIxvg5Tzop"></a>Някои функции могат да имат произволен брой аргументи, като <code>console.log</code>. Те обикновено са цикъл върху стойностите <code>arguments</code> обекти. И могат да бъдат използвани за създаване на много приятни интерфейси. Например да си спомним как създадохме вписванията за журнала на Жак.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_HkIRWLvq7y" href="./04_data.html#c_HkIRWLvq7y"></a><span class="cm-variable">addEntry</span>([<span class="cm-string">"work"</span>, <span class="cm-string">"touched tree"</span>, <span class="cm-string">"pizza"</span>, <span class="cm-string">"running"</span>,
          <span class="cm-string">"television"</span>], <span class="cm-atom">false</span>);</pre>
<p><a class="p_ident" id="p_2WHMCXaaIn" href="./04_data.html#p_2WHMCXaaIn"></a>Тъй като, ще трябва да извикваме тази функция много пъти, бихме могли да създадем алтернатива , която е по-лесна за извикване.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_mJiHtSVFDT" href="./04_data.html#c_mJiHtSVFDT"></a><span class="cm-keyword">function</span> <span class="cm-variable">addEntry</span>(<span class="cm-def">squirrel</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">entry</span> <span class="cm-operator">=</span> {<span class="cm-property">events</span>: [], <span class="cm-property">squirrel</span>: <span class="cm-variable-2">squirrel</span>};
  <span class="cm-keyword">for</span> (<span class="cm-keyword">var</span> <span class="cm-def">i</span> <span class="cm-operator">=</span> <span class="cm-number">1</span>; <span class="cm-variable-2">i</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">arguments</span>.<span class="cm-property">length</span>; <span class="cm-variable-2">i</span><span class="cm-operator">++</span>)
    <span class="cm-variable-2">entry</span>.<span class="cm-property">events</span>.<span class="cm-property">push</span>(<span class="cm-variable-2">arguments</span>[<span class="cm-variable-2">i</span>]);
  <span class="cm-variable">journal</span>.<span class="cm-property">push</span>(<span class="cm-variable-2">entry</span>);
}
<span class="cm-variable">addEntry</span>(<span class="cm-atom">true</span>, <span class="cm-string">"work"</span>, <span class="cm-string">"touched tree"</span>, <span class="cm-string">"pizza"</span>,
         <span class="cm-string">"running"</span>, <span class="cm-string">"television"</span>);</pre>
<p><a class="p_ident" id="p_o3+Bq1M1pm" href="./04_data.html#p_o3+Bq1M1pm"></a>Тази версия чете първия си аргумент (<code>squirrel</code>) по нормален начин, а след това отива върху останалата част от аргументите (цикъла започва от индекс 1, като прескача първия), за да ги събере в масив.</p>
<h2><a class="h_ident" id="h_C51DnYk8WZ" href="./04_data.html#h_C51DnYk8WZ"></a>Math обект</h2>
<p><a class="p_ident" id="p_9S5JZybGFD" href="./04_data.html#p_9S5JZybGFD"></a>Както сме виждали, <code>Math</code> e пакет от свързани с цифри функции за комунални услуги, като например <code>Math.max</code> (максимум), <code>Math.min</code> (минимум) и <code>Math.sqrt</code> (корен квадратен).</p>
<p id="namespace_pollution"><a class="p_ident" id="p_YvGRywRVYj" href="./04_data.html#p_YvGRywRVYj"></a>Обекта <code>Math</code> се ползва просто, като контейнер на група от свързана функционалност. Има само един обект <code>Math</code> и почти никога полезен само като стойност. Вместо това, той осигурява пространство от имена, така че всички тези стойности на функции, да не трябва да бъдат глобални променливи. </p>
<p><a class="p_ident" id="p_fGEMziAXhp" href="./04_data.html#p_fGEMziAXhp"></a>Имайки твърде много глобални променливи се “замърсява” пространството от имена. Колкото повече имена са въведени, толкова по вероятно е случайно презаписване на стойността на някои променливи. Например, това не е малко вероятно, вие ще искате да назовете нещо с <code>max</code> max във вашата програма. Тъй като <code>max</code> е вградена функция в JavaScript, закътана безопасно вътре в <code>Math</code> обекта, не трябва да се притесняваме за това презаписване.</p>
<p><a class="p_ident" id="p_tEjnm+nh21" href="./04_data.html#p_tEjnm+nh21"></a>Много езици ще ви спрат или поне предупредят, когато дефинирате променлива с име, което вече е заето, JavaScript не го прави, така че бъдете внимателни.</p>
<p><a class="p_ident" id="p_zWXQRNgLI/" href="./04_data.html#p_zWXQRNgLI/"></a>Обратно към <code>Math</code> обекта. Ако правите някаква тригонометрия, <code>Math</code> може да помогне. Той съдържа <code>cos</code> косинус), <code>sin</code> (синус) и <code>tan</code> (тангенс), както и техните обратни функции <code>acos</code>, <code>asin</code>, and <code>atan</code> респективно. Числото π (пи) - или поне най-близкото приближение, което се вписва в JavaScript, като номер е на разположение с <code>Math.PI</code>. (Има една стара традиция за писане на програмни имена на постоянни стойности (константи) с главни букви.)</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_2uZIZgWSsu" href="./04_data.html#c_2uZIZgWSsu"></a><span class="cm-keyword">function</span> <span class="cm-variable">randomPointOnCircle</span>(<span class="cm-def">radius</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">angle</span> <span class="cm-operator">=</span> <span class="cm-variable">Math</span>.<span class="cm-property">random</span>() <span class="cm-operator">*</span> <span class="cm-number">2</span> <span class="cm-operator">*</span> <span class="cm-variable">Math</span>.<span class="cm-property">PI</span>;
  <span class="cm-keyword">return</span> {<span class="cm-property">x</span>: <span class="cm-variable-2">radius</span> <span class="cm-operator">*</span> <span class="cm-variable">Math</span>.<span class="cm-property">cos</span>(<span class="cm-variable-2">angle</span>),
          <span class="cm-property">y</span>: <span class="cm-variable-2">radius</span> <span class="cm-operator">*</span> <span class="cm-variable">Math</span>.<span class="cm-property">sin</span>(<span class="cm-variable-2">angle</span>)};
}
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">randomPointOnCircle</span>(<span class="cm-number">2</span>));
<span class="cm-comment">// → {x: 0.3667, y: 1.966}</span></pre>
<p><a class="p_ident" id="p_4kTWFGWGMm" href="./04_data.html#p_4kTWFGWGMm"></a>Ако <em>sin</em> и <em>cos</em> са нещо, с което не сте много добре запознати, не се притеснявайте. Когато ще ги използваме в <a href="./13_dom.html#sin_cos">Глава 13</a>, аз ще ги обясня.</p>
<p><a class="p_ident" id="p_a6xMq73yCc" href="./04_data.html#p_a6xMq73yCc"></a>Предишният пример използва <code>Math.random</code>. Това е функция, която връща нов случаен номер, между нула (включително) и едно, всеки път когато се извика.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_wJKP6sIzSp" href="./04_data.html#c_wJKP6sIzSp"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">Math</span>.<span class="cm-property">random</span>());
<span class="cm-comment">// → 0.36993729369714856</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">Math</span>.<span class="cm-property">random</span>());
<span class="cm-comment">// → 0.727367032552138</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">Math</span>.<span class="cm-property">random</span>());
<span class="cm-comment">// → 0.40180766698904335</span></pre>
<p><a class="p_ident" id="p_LqSZpx/sgf" href="./04_data.html#p_LqSZpx/sgf"></a>Въпреки, че компютрите са детерминирани машини - те винаги реагират по един и същи начин, ако се подават едни и същи входни данни - е възможно да произвеждат номера на случаен принцип. За да направи това, устройството поддържа редица(или един куп) номера във вътрешната си памет. След това, всеки път, когато се искат случайни числа, тя изпълнява някои сложни детерминирани изчисления във вътрешността и връща част от резултата на тези изчисления. Машината използва резултата  за да промени вътрешното си състояние, така че произведените следващи случайни числа да бъдат различни.</p>
<p><a class="p_ident" id="p_WnBKL1c/CF" href="./04_data.html#p_WnBKL1c/CF"></a>Ако искаме цели случайни числа вместо дробни, можем да използваме <code>Math.floor</code> (което закръгля към най-близкото цяло число)преди резултата на <code>Math.random</code>.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_bBGTtB+AvR" href="./04_data.html#c_bBGTtB+AvR"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">Math</span>.<span class="cm-property">floor</span>(<span class="cm-variable">Math</span>.<span class="cm-property">random</span>() <span class="cm-operator">*</span> <span class="cm-number">10</span>));
<span class="cm-comment">// → 2</span></pre>
<p><a class="p_ident" id="p_52aDRkOsyH" href="./04_data.html#p_52aDRkOsyH"></a>Умножаването на случайни числа по 10, ни дава число по-голямо или равно на нула, но по-малко от 10. Тъй като <code>Math.floor</code> закръгля на долу, този израз ще произведе с равен шанс всяко число от 0 до 9.</p>
<p><a class="p_ident" id="p_1pKvkjRw0T" href="./04_data.html#p_1pKvkjRw0T"></a>There are also the
functions <code>Math.ceil</code> (for “ceiling”, which rounds up to a whole
number) and <code>Math.round</code> (to the nearest whole number).</p>
<h2><a class="h_ident" id="h_lRBZxXmo93" href="./04_data.html#h_lRBZxXmo93"></a>Глобален  обект</h2>
<p><a class="p_ident" id="p_+IF2SIC4YV" href="./04_data.html#p_+IF2SIC4YV"></a>Глобален обект е пространство, в което живеят глобални променливи и към него може да се подхожда, като към всеки обект в JavaScript. Всяка глобална променлива присъства, като свойство на този обект. В браузърите, глобалния обхват на обекта се съхранява в <code>window</code> променлива.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_3k/DIzi9mB" href="./04_data.html#c_3k/DIzi9mB"></a><span class="cm-keyword">var</span> <span class="cm-variable">myVar</span> <span class="cm-operator">=</span> <span class="cm-number">10</span>;
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">"myVar"</span> <span class="cm-keyword">in</span> <span class="cm-variable">window</span>);
<span class="cm-comment">// → true</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">window</span>.<span class="cm-property">myVar</span>);
<span class="cm-comment">// → 10</span></pre>
<h2><a class="h_ident" id="h_ErccPg/l98" href="./04_data.html#h_ErccPg/l98"></a>Резюме</h2>
<p><a class="p_ident" id="p_78ZfHX5x1B" href="./04_data.html#p_78ZfHX5x1B"></a>Обекти и масиви (които са специфични видове обекти) осигуряват начини за групиране на няколко стойности в една единствена стойност. Концептуално, това ни позволява да сложим един куп неща свързани в един пакет, с който да тичаме наоколо, вместо да се опитваме да приключим всички отделни неща и да ги ползваме по отделно.</p>
<p><a class="p_ident" id="p_ayhyxvWlMH" href="./04_data.html#p_ayhyxvWlMH"></a>Повечето стойности в JavaScript имат свойства с изключение на <code>null</code> и <code>undefined</code>.  Информацията се достига чрез <code>value.propName</code> или <code>value["propName"]</code>. Обектите са склонни да използват имена за техните свойства и съхранение на повече или по-малко фиксиран набор от тях. Масивите, от друга страна, обикновено съдържат различни номера на концептуално идентични стойности и използват номера(започвайки от 0) за имена на техните свойства.</p>
<p><a class="p_ident" id="p_1lcitbawCQ" href="./04_data.html#p_1lcitbawCQ"></a>Там са някои свойства на масивите, като <code>length</code> и редица методи. Методите са функции, които живеят в свойства и (обикновено) влияят на стойността, на която са свойство</p>
<p><a class="p_ident" id="p_ZtRACiqRCK" href="./04_data.html#p_ZtRACiqRCK"></a>Обектите могат да служат и като карти, за асоцииране на стойността с имена. Оператора <code>in</code> може да се използва , за да се разбере, дали даден обект съдържа свойство с дадено име. Същата ключова дума може да се използва и за цикъл (<code>for (var name in object)</code>), който минава през свойствата на даден обект.</p>
<h2><a class="h_ident" id="h_TcUD2vzyMe" href="./04_data.html#h_TcUD2vzyMe"></a>Упражнения</h2>
<h3><a class="h_ident" id="h_8ZspxiCEC/" href="./04_data.html#h_8ZspxiCEC/"></a>Сумата на редица</h3>
<p><a class="p_ident" id="p_fpyyiv/hm1" href="./04_data.html#p_fpyyiv/hm1"></a>В <a href="./00_intro.html#intro">увода</a> на тази книга, споменах за следното: един добър начин да се изчисли сумата на обхвата от номера:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_OULOwD7HOm" href="./04_data.html#c_OULOwD7HOm"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">sum</span>(<span class="cm-variable">range</span>(<span class="cm-number">1</span>, <span class="cm-number">10</span>)));</pre>
<p><a class="p_ident" id="p_PkFb/61ecP" href="./04_data.html#p_PkFb/61ecP"></a>Напиши функция <code>range</code>, която използва два аргумента, за начало <code>start</code> и край <code>end</code> и връща масив, който съдържа числата от началото до края(включително)..</p>
<p><a class="p_ident" id="p_0GiJNcBSop" href="./04_data.html#p_0GiJNcBSop"></a>На следващо място, напиши сумираща функция <code>sum</code>, която използва този масив от числа и връща сумата от тези числа. Стартирайте предишната програма и вижте дали наистина връща 55.</p>
<p><a class="p_ident" id="p_T5lVUHvYnd" href="./04_data.html#p_T5lVUHvYnd"></a>Като бонус задача, модифицирайте обхвата на функция, за да взима по желание трети аргумент, който показва стойността на стъпката, която се използва за изграждане на масива. Ако не е дадена стъпката елементите на масива вървят на горе със стъпка едно, съответстващо на стария вид поведение. Функцията извикана в диапазон (1, 10, 2), трябва да върне [1, 3, 5, 7, 9]. Уверете се, че тя работи и с отрицателни стойности, така че диапазон(5, 2, -1) произвежда [5, 4, 3, 2].</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_BUhKzmRiGU" href="./04_data.html#c_BUhKzmRiGU"></a><span class="cm-comment">// Your code here.</span>

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">range</span>(<span class="cm-number">1</span>, <span class="cm-number">10</span>));
<span class="cm-comment">// → [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">range</span>(<span class="cm-number">5</span>, <span class="cm-number">2</span>, <span class="cm-operator">-</span><span class="cm-number">1</span>));
<span class="cm-comment">// → [5, 4, 3, 2]</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">sum</span>(<span class="cm-variable">range</span>(<span class="cm-number">1</span>, <span class="cm-number">10</span>)));
<span class="cm-comment">// → 55</span></pre>
<div class="solution"><div class="solution-text">
<p><a class="p_ident" id="p_AzWVqPrlre" href="./04_data.html#p_AzWVqPrlre"></a>Изграждането на масив най-лесно може да се направи, като първо се инициализира променлива <code>[]</code> (нов празен масив) и многократно извиква своя <code>push</code> метод за добавяне на стойност. Не забравяйте да върнете масива в края на функцията.</p>
<p><a class="p_ident" id="p_eu6MUPwjEb" href="./04_data.html#p_eu6MUPwjEb"></a>За край на границата включително, ще трябва да използвате оператора <code>&lt;=</code>, вместо <code>&lt;</code>, за да проверите края на своя цикъл.</p>
<p><a class="p_ident" id="p_gp8gSa5PFL" href="./04_data.html#p_gp8gSa5PFL"></a>Трябва също да проверите дали е даден аргумент за стъпката, или <code>arguments.length</code>,  или да сравните стойността на аргумента с <code>undefined</code>. Ако не е даден, просто го настройте на стойност по подразбиране (1) в горната част на функцията.</p>
<p><a class="p_ident" id="p_xfC3xdBYBn" href="./04_data.html#p_xfC3xdBYBn"></a>Когато знаете, че имате в обхвата отрицателни стойности, най-добре е да се напишат два отделни цикъла- един за броене на горе и един за броене на долу, защото сравнението, което проверява дали един цикъл е завършен трябва да бъде <code>&gt;=</code> вместо <code>&lt;=</code>, когато се бори на долу.</p>
<p><a class="p_ident" id="p_kHSmZmF/0k" href="./04_data.html#p_kHSmZmF/0k"></a>Може също така да бъде полезно да се използва различен етап по подразбиране, а именно -1, когато края на обхвата е по-малък, от колкото в началото. По този начин <code>range(5, 2)</code> връща нещо смислено, а не става един безкраен цикъл.</p>
</div></div>
<h3><a class="h_ident" id="h_6xTmjj4Rf5" href="./04_data.html#h_6xTmjj4Rf5"></a>Обръщане на масив</h3>
<p><a class="p_ident" id="p_0ysB6LgssH" href="./04_data.html#p_0ysB6LgssH"></a>Масивите имат метод <code>reverse</code>, който променя масива, като обръща реда, в който се появяват неговите елементи. За това упражнение напишете две функции, <code>reverseArray</code> и <code>reverseArrayInPlace</code>. Първата, <code>reverseArray</code>, взема масива, като аргумент и произвежда нов масив, който има същите елементи в обратен ред. Втората <code>reverseArrayInPlace</code>, прави това, което метода <code>reverse</code> прави: променя масива, като дава аргумент за да обърне неговите елементи. Не може да се използва стандартния метод <code>reverse</code>.</p>
<p><a class="p_ident" id="p_0WdqLyJAyQ" href="./04_data.html#p_0WdqLyJAyQ"></a>Мисля си за бележките за страничните ефекти и чистите функции в <a href="./03_functions.html#pure">предишната глава</a>, кой вариант очаквате да бъде по-полезен в повечето ситуации? Кой е по-ефективен?</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_F3JsLaIs+m" href="./04_data.html#c_F3JsLaIs+m"></a><span class="cm-comment">// Your code here.</span>

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">reverseArray</span>([<span class="cm-string">"A"</span>, <span class="cm-string">"B"</span>, <span class="cm-string">"C"</span>]));
<span class="cm-comment">// → ["C", "B", "A"];</span>
<span class="cm-keyword">var</span> <span class="cm-variable">arrayValue</span> <span class="cm-operator">=</span> [<span class="cm-number">1</span>, <span class="cm-number">2</span>, <span class="cm-number">3</span>, <span class="cm-number">4</span>, <span class="cm-number">5</span>];
<span class="cm-variable">reverseArrayInPlace</span>(<span class="cm-variable">arrayValue</span>);
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">arrayValue</span>);
<span class="cm-comment">// → [5, 4, 3, 2, 1]</span></pre>
<div class="solution"><div class="solution-text">
<p><a class="p_ident" id="p_pyY1QGL0wk" href="./04_data.html#p_pyY1QGL0wk"></a>Има два очевидни начина за изпълнение на <code>. Първият е просто да минем през входящия масив отпред назад и използвайки <code>unshift</code> метода на новия масив и да вмъкнем всеки елемент в неговото начало. Вторият е да минем с цикъл над входящия масив назад и използваме <code>push</code> метода. Итерациите над масива назад изискват (донякъде неудобна) <code>for</code> спецификация, като <code>(var i =
array.length - 1; i &gt;= 0; i--)</code>.</p>
<p><a class="p_ident" id="p_Y08sN3Yej5" href="./04_data.html#p_Y08sN3Yej5"></a>Обръщането на масива на място е по-трудно. Вие трябва да внимавате да не презапишете елементи, от които ще се нуждаете по-късно. Използването на <code>reverseArray</code> или друго копиране на целия масив (като <code>array.slice(0)</code> е един добър начин за копиране на масиви) работи, но е измама.</p>
<p><a class="p_ident" id="p_hzYSkS4zzl" href="./04_data.html#p_hzYSkS4zzl"></a>Номерът е да се сменят първите и последните елементи, а след това на втория и след втория следващия и т.н. Можете да направите това с цикъл над половината от дължината на масива (използвайте <code>Math.floor</code> за да закръгляте надолу - не е нужно да се достига средата на елементите в масив с нечетна дължина) и смяна на елемент на позиция <code>i</code> с един от позицията на <code>array.length - 1 - i</code>. Може да използвате локална променлива, да държи за кратко един от елементите, презаписвайки го с неговия огледален образ и след това пускане на стойността от локалната променлива на мястото, където огледалния образ да бъде използван.</p>
</div></div>
<h3 id="list"><a class="h_ident" id="h_nSTX34CM1M" href="./04_data.html#h_nSTX34CM1M"></a>Списък</h3>
<p><a class="p_ident" id="p_7AnSuS26HF" href="./04_data.html#p_7AnSuS26HF"></a>Обектите, като общи очертания на стойности, могат да бъдат използвани за изграждане на всички видове структури от данни. Една обща структура от данни е списък (да не се бърка с масив). Списъкът е вложен набор от обекти, като с първия обект се позовава на втория , втория - третия и т.н.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_WcmR7ylTJy" href="./04_data.html#c_WcmR7ylTJy"></a><span class="cm-keyword">var</span> <span class="cm-variable">list</span> <span class="cm-operator">=</span> {
  <span class="cm-property">value</span>: <span class="cm-number">1</span>,
  <span class="cm-property">rest</span>: {
    <span class="cm-property">value</span>: <span class="cm-number">2</span>,
    <span class="cm-property">rest</span>: {
      <span class="cm-property">value</span>: <span class="cm-number">3</span>,
      <span class="cm-property">rest</span>: <span class="cm-atom">null</span>
    }
  }
};</pre>
<p><a class="p_ident" id="p_2un5u6U14Q" href="./04_data.html#p_2un5u6U14Q"></a>Получените обекти образуват верига, подобна на тази:</p>
<div class="image">
  <img src="./media/linked-list.svg" alt="A linked list">
</div>
<p><a class="p_ident" id="p_NaI0fhp38z" href="./04_data.html#p_NaI0fhp38z"></a>Известно нещо за списъците, е че могат да споделят част от своята структура. Например, ако аз създам две нови стойности <code>{value: 0, rest: list}</code> и <code>{value: -1, rest: list}</code> (със <code>list</code> позовавайки се на променливата определена по-рано), и двата списъка са независими, но те споделят структурата, която прави последните три елемента. В допълнение, първоначалният списък също е все още валиден списък с три елемента.</p>
<p><a class="p_ident" id="p_iPlgVCeZGh" href="./04_data.html#p_iPlgVCeZGh"></a>Напишете функция <code>arrayToList</code>, която изгражда структура от данни, като предишната, на която се дава <code>[1, 2, 3]</code>, като аргумент и напишете функция <code>listToArray</code>, която произвежда масив от списък. Също напишете помощни функции - <code>prepend</code>, която взема елемент и списък и създават нов списък, като добавя елемента към списъка отпред на входа и <code>nth</code>, която взема номер от списъка и връща елемент от дадена позиция в списъка или <code>undefined</code>, когато няма такъв елемент.</p>
<p><a class="p_ident" id="p_IZMCvYT0l2" href="./04_data.html#p_IZMCvYT0l2"></a>Още не сте готови, напишете също и рекурсивна версия на <code>nth</code>.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_F73m7OkLk8" href="./04_data.html#c_F73m7OkLk8"></a><span class="cm-comment">// Your code here.</span>

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">arrayToList</span>([<span class="cm-number">10</span>, <span class="cm-number">20</span>]));
<span class="cm-comment">// → {value: 10, rest: {value: 20, rest: null}}</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">listToArray</span>(<span class="cm-variable">arrayToList</span>([<span class="cm-number">10</span>, <span class="cm-number">20</span>, <span class="cm-number">30</span>])));
<span class="cm-comment">// → [10, 20, 30]</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">prepend</span>(<span class="cm-number">10</span>, <span class="cm-variable">prepend</span>(<span class="cm-number">20</span>, <span class="cm-atom">null</span>)));
<span class="cm-comment">// → {value: 10, rest: {value: 20, rest: null}}</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">nth</span>(<span class="cm-variable">arrayToList</span>([<span class="cm-number">10</span>, <span class="cm-number">20</span>, <span class="cm-number">30</span>]), <span class="cm-number">1</span>));
<span class="cm-comment">// → 20</span></pre>
<div class="solution"><div class="solution-text">
<p><a class="p_ident" id="p_gUGYq9Tjlx" href="./04_data.html#p_gUGYq9Tjlx"></a>Изграждане на списък е най-добре отзад напред. Така <code>arrayToList</code> може да обхожда масива назад (виж предишното упражнение) и за всеки елемент да добавя един обект в списъка. Можете да използвате локална променлива да държи част от списъка, който е направен до сега, като използвате модела <code>list = {value: X, rest: list}</code> за да добавя елемент.</p>
<p><a class="p_ident" id="p_+rJULr60CD" href="./04_data.html#p_+rJULr60CD"></a>За да обработите списъка (в  <code>listToArray</code> и <code>nth</code>), може да използвате <code>for</code> цикъл:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_ozaUfY2r+R" href="./04_data.html#c_ozaUfY2r+R"></a><span class="cm-keyword">for</span> (<span class="cm-keyword">var</span> <span class="cm-variable">node</span> <span class="cm-operator">=</span> <span class="cm-variable">list</span>; <span class="cm-variable">node</span>; <span class="cm-variable">node</span> <span class="cm-operator">=</span> <span class="cm-variable">node</span>.<span class="cm-property">rest</span>) {}</pre>
<p><a class="p_ident" id="p_LnwEAnSmsp" href="./04_data.html#p_LnwEAnSmsp"></a>Можете ли да видите как става това? Във всяка итерация на цикъла, <code>node</code> е точка към текущия под-списък и тялото му може да чете свойството на стойността за да получите текущия елемент. В края на итерацията <code>node</code> преминава към следващия под-списък. Когато това е <em>null</em>, то той е стигнал края на списъка и цикъла е завършен.</p>
<p><a class="p_ident" id="p_vwViRUdBme" href="./04_data.html#p_vwViRUdBme"></a>Рекурсивна версия на <code>nth</code>, по същия начин ще погледне все по-малката част от "опашката" на списъка и в същото време ще брои индекса, докато достигне нула, при което може да върне свойството на стойността, която <em>node</em> гледа. За да получите <em>zeroeth</em> елемент от списъка, можете просто да вземете свойството на стойността от нейния главен <em>node</em>. За да получите елемент <em>N</em> + 1 вземете <em>N</em>-тия елемент от списъка, който е в списъка на <code>rest</code> свойството.</p>
</div></div>
<h3 id="exercise_deep_compare"><a class="h_ident" id="h_IJBU+aXOIC" href="./04_data.html#h_IJBU+aXOIC"></a>Дълбоко сравнение</h3>
<p><a class="p_ident" id="p_xTwbRlqHNJ" href="./04_data.html#p_xTwbRlqHNJ"></a>Оператора <code>==</code> сравнява обекти за идентичност. Но понякога, бихме предпочели да сравним стойностите по действителните им свойства.</p>
<p><a class="p_ident" id="p_gndt0hmgga" href="./04_data.html#p_gndt0hmgga"></a>Напишете функция <code>deepEqual</code>, кято взема две стойности и връща true, само ако те са една и съща стойност или обекти със същите свойства, чиито стойности също са равни, когато се сравнят с рекурсивното извикване на <code>deepEqual</code>.</p>
<p><a class="p_ident" id="p_kFIc5gkwlo" href="./04_data.html#p_kFIc5gkwlo"></a>За да разберете дали се сравняват две неща за идентичност (използвайте оператора <code>===</code> за това) или за да видите техните свойства, използвайте оператора <code>typeof</code>. Ако произвежда обект за двете стойности, трябва да направите дълбоко сравнение. Но трябва да вземете едно глупаво изключение в предвид: от една историческа случайност, <code>typeof null</code> също произвежда обект.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class="c_ident" id="c_JMI8a18DSU" href="./04_data.html#c_JMI8a18DSU"></a><span class="cm-comment">// Your code here.</span>

<span class="cm-keyword">var</span> <span class="cm-variable">obj</span> <span class="cm-operator">=</span> {<span class="cm-property">here</span>: {<span class="cm-property">is</span>: <span class="cm-string">"an"</span>}, <span class="cm-property">object</span>: <span class="cm-number">2</span>};
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">deepEqual</span>(<span class="cm-variable">obj</span>, <span class="cm-variable">obj</span>));
<span class="cm-comment">// → true</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">deepEqual</span>(<span class="cm-variable">obj</span>, {<span class="cm-property">here</span>: <span class="cm-number">1</span>, <span class="cm-property">object</span>: <span class="cm-number">2</span>}));
<span class="cm-comment">// → false</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">deepEqual</span>(<span class="cm-variable">obj</span>, {<span class="cm-property">here</span>: {<span class="cm-property">is</span>: <span class="cm-string">"an"</span>}, <span class="cm-property">object</span>: <span class="cm-number">2</span>}));
<span class="cm-comment">// → true</span></pre>
<div class="solution"><div class="solution-text">
<p><a class="p_ident" id="p_t3z+oosxP9" href="./04_data.html#p_t3z+oosxP9"></a>Вашият тест за това дали се занимавате с истинския обект ще изглежда нещо, като <code>typeof x == "object" &amp;&amp; x != null</code>. Бъдете внимателни при сравняване на свойства, когато и двата аргумента са обекти. Във всички други случаи може просто да върнете незабавно резултата от прилагането на <code>===</code>.</p>
<p><a class="p_ident" id="p_fyoBIInROR" href="./04_data.html#p_fyoBIInROR"></a>Използвайте <code>for</code>/<code>in</code> цикъл да минете през свойствата. Трябва да се провери дали двата обекта са с едни и същи набори от имена на свойства и дали тези свойства имат еднакви стойности. Първият тест може да се направи чрез преброяване на свойствата на двата обекта и връщане на <em>false</em>, ако номерата на свойствата са различни. Ако те са едни и същи, след това отидете на свойствата на единия обект и за всяко от тях потвърдете, че другия обект също има това свойство. Стойностите на свойствата се сравняват с рекурсивно извикване на <code>deepEqual</code>.</p>
<p><a class="p_ident" id="p_ECXa1sWg6+" href="./04_data.html#p_ECXa1sWg6+"></a>Връщането на правилната стойност от функцията се прави най-добре, когато незабавно върне <em>false</em>, ако забележи разминаване и върне true в края на функцията.</p>
</div></div>
<nav>
  <a href="./03_functions.html" title="previous chapter">◀</a>
  <a href="./index.html" title="cover">◆</a>
  <a href="./05_higher_order.html" title="next chapter">▶</a>
</nav>
</article>
</body></html>